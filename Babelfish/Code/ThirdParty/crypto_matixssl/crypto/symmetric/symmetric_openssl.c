/**
 *      @file    symmetric_openssl.c
 *
 *
 *      Symmetric compatibility layer between MatrixSSL and OpenSSL.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

/******************************************************************************/

/* TODO aesni_cbc_sha256_enc */
#ifdef USE_OPENSSL_AES_CBC

static inline const EVP_CIPHER *EVP_aes_cbc(uint8_t keylen)
{
    switch (keylen)
    {
    case AES128_KEYLEN:
        return EVP_get_cipherbyname("aes-128-cbc");
/*              return EVP_aes_128_cbc(); */
    case AES192_KEYLEN:
        return EVP_get_cipherbyname("aes-192-cbc");
/*              return EVP_aes_192_cbc(); */
    case AES256_KEYLEN:
        return EVP_get_cipherbyname("aes-256-cbc");
/*              return EVP_aes_256_cbc(); */
    }
    return NULL;
}

int32_t psAesInitCBC(psAesCbc_t *ctx,
    const unsigned char IV[AES_IVLEN],
    const unsigned char key[AES_MAXKEYLEN], uint8_t keylen,
    uint32_t flags)
{
    OpenSSL_add_all_algorithms();
    EVP_CIPHER_CTX_init(ctx);
    if (EVP_CipherInit_ex(ctx, EVP_aes_cbc(keylen), NULL, key, IV,
            flags & PS_AES_ENCRYPT ? 1 : 0))
    {
        /* Turn off padding so all the encrypted/decrypted data will be
            returned in the single call to Update.  This will require that
            all the incoming data be an exact block multiple (which is true
            for TLS usage where all padding is accounted for) */
        EVP_CIPHER_CTX_set_padding(ctx, 0);
        return PS_SUCCESS;
    }
    EVP_CIPHER_CTX_cleanup(ctx);
    psAssert(0);
    return PS_FAIL;
}

void psAesClearCBC(psAesCbc_t *ctx)
{
    EVP_CIPHER_CTX_cleanup(ctx);
}

void psAesDecryptCBC(psAesCbc_t *ctx,
    const unsigned char *ct, unsigned char *pt,
    uint32_t len)
{
    int outl = len;

    if (!EVP_DecryptUpdate(ctx, pt, &outl, ct, len))
    {
        EVP_CIPHER_CTX_cleanup(ctx);
        psAssert(0);
    }
    psAssert(outl == len);
}

void psAesEncryptCBC(psAesCbc_t *ctx,
    const unsigned char *pt, unsigned char *ct,
    uint32_t len)
{
    int outl = len;

    if (!EVP_EncryptUpdate(ctx, ct, &outl, pt, len))
    {
        EVP_CIPHER_CTX_cleanup(ctx);
        psAssert(0);
    }
    psAssert(outl == len);
}

#endif /* USE_OPENSSL_AES_CBC */

/******************************************************************************/

