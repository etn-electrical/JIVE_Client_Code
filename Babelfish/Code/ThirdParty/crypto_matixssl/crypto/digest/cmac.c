/**
 *      @file    cmac.c
 *
 *
 *      AES-CMAC hash.
 */
/*
 *      Copyright (c) 2014-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

#ifdef USE_MATRIX_AES_CMAC
/******************************************************************************/
# ifndef USE_AES_BLOCK
#  error USE_AES_BLOCK required
# endif

static void UpdateFunc(psAesCmac_t *ctx, const unsigned char *buf, uint32_t size);
static void FLFCMACMult128(unsigned char *array);
static inline void flf_blocker(psAesCmac_t *Context_p, const unsigned char *Data_p,
                                 uint32_t DataCount);
static inline void FLGXor(void *s1, const void *s2, size_t n);

# define FLFBLOCKSIZE 128 /* Maximum block size of a hash function. */

/* Output 'mac' must be a 16 byte allocated storage location */
int32_t psCmacGenerate(psPool_t *pool,
    const unsigned char *key, psSize_t keyLen,
    const unsigned char *data, uint32_t dataLen,
    unsigned char *mac)
{
    psAesCmac_t cmacCtx;

    if (psCmacInit(key, keyLen, &cmacCtx) < 0)
    {
        return PS_FAILURE;
    }
    psCmacUpdate(&cmacCtx, data, dataLen);
    psCmacFinal(&cmacCtx, mac);
    return PS_SUCCESS;
}

int32_t psCmacInit(const unsigned char *key, psSize_t keyLen,
    psAesCmac_t *aesCmacCtx)
{
    psAesKey_t aesKey;
    int32_t err;

    Memset(aesCmacCtx, 0x0, sizeof(psAesCmac_t));
    if ((err = psAesInitBlockKey(&aesKey, key, keyLen, PS_AES_ENCRYPT))
        != PS_SUCCESS)
    {
        return err;
    }

    psAesEncryptBlock(&aesKey, aesCmacCtx->subKey, aesCmacCtx->subKey);

    FLFCMACMult128(aesCmacCtx->subKey);

    aesCmacCtx->inputBufferCount = 0;
    Memcpy(aesCmacCtx->key, key, keyLen);
    aesCmacCtx->keyLen = keyLen;
    return PS_SUCCESS;
}

void psCmacUpdate(psAesCmac_t *aesCmacCtx, const unsigned char *data,
    uint32_t dataLen)
{
    flf_blocker(aesCmacCtx, data, dataLen);
}

void psCmacFinal(psAesCmac_t *aesCmacCtx, unsigned char *hash)
{
    uint32_t BytesNotLast;

    /* Count buffered bytes not belonging in the last block. */
    BytesNotLast = (aesCmacCtx->inputBufferCount / 16) * 16;
    if (BytesNotLast == aesCmacCtx->inputBufferCount && BytesNotLast > 0)
    {
        /* The Last Block is complete. */
        BytesNotLast -= 16;
    }
    else
    {
        /* The Last Block is incomplete: Terminate Last Block and
            calculate SubKey [K2]. */
        Memset(&aesCmacCtx->Input.Buffer[aesCmacCtx->inputBufferCount], 0x0,
            sizeof(aesCmacCtx->Input.Buffer) - aesCmacCtx->inputBufferCount);
        aesCmacCtx->Input.Buffer[aesCmacCtx->inputBufferCount] = 0x80;
        FLFCMACMult128(aesCmacCtx->subKey);
    }

    /* Process non-final buffered bytes. */
    if (BytesNotLast > 0)
    {
        UpdateFunc(aesCmacCtx, aesCmacCtx->Input.Buffer, BytesNotLast);
    }

    /* Final block handling. */
    /* Xor final block with SubKey (in CMAC). */
    FLGXor(&aesCmacCtx->Input.Buffer[BytesNotLast], &aesCmacCtx->subKey, 16);

    UpdateFunc(aesCmacCtx, &aesCmacCtx->Input.Buffer[BytesNotLast], 16);

    Memcpy(hash, &aesCmacCtx->IV, 16);

    Memset(aesCmacCtx, 0x0, sizeof(psAesCmac_t));
}

/******************************************************************************/

static inline void FLGXor(void *s1, const void *s2, size_t n)
{
    unsigned char *p1 = s1;
    const unsigned char *p2 = s2;

    while (n--)
    {
        *(p1++) ^= *(p2++);
    }
}

static void FLFCMACMult128(unsigned char *array)
{
    unsigned char mem, iter, next_iter;
    uint32_t i;

    mem = iter = array[0];
    for (i = 0; i < 15; i++)
    {
        next_iter = array[i + 1];
        array[i] = (iter << 1) | (next_iter >> 7);
        iter = next_iter;
    }

    array[15] = (iter << 1) ^ ((mem & 128) == 0 ? 0x00 : 0x87);
}

static void UpdateFunc(psAesCmac_t *ctx, const unsigned char *buf,
    uint32_t size)
{
    psAesKey_t key;
    uint32_t *IV = ctx->IV;

    psAesInitBlockKey(&key, ctx->key, ctx->keyLen, PS_AES_ENCRYPT);
    while (size >= 16)
    {
        union
        {
            uint32_t alignment;
            uint32_t block_32[4];
            uint8_t block[16];
        } u;

        Memcpy(u.block_32, buf, 16);
        u.block_32[0] ^= IV[0];
        u.block_32[1] ^= IV[1];
        u.block_32[2] ^= IV[2];
        u.block_32[3] ^= IV[3];

        psAesEncryptBlock(&key, u.block, (unsigned char *) IV);

        buf += 16;
        size -= 16;
    }
    Memset(&key, 0x0, sizeof(psAesKey_t));
}

static inline void flf_blocker(psAesCmac_t *Context_p, const unsigned char *Data_p,
    uint32_t DataCount)
{
    while (DataCount > 0)
    {
        if (Context_p->inputBufferCount == FLFBLOCKSIZE)
        {
            UpdateFunc(Context_p, Context_p->Input.Buffer,
                Context_p->inputBufferCount);
            Context_p->inputBufferCount = 0;
        }
        if (Context_p->inputBufferCount < FLFBLOCKSIZE)
        {
            uint32_t BytesProcess =
                min(DataCount, FLFBLOCKSIZE - Context_p->inputBufferCount);

            Memcpy(Context_p->Input.Buffer + Context_p->inputBufferCount,
                Data_p, BytesProcess);
            DataCount -= BytesProcess;
            Context_p->inputBufferCount += BytesProcess;
            Data_p += BytesProcess;
        }
    }
}

#endif /* USE_MATRIX_AES_CMAC */

/******************************************************************************/

