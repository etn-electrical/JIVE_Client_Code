/**
 *      @file    rsa_write_mem.c
 *
 *
 *      Functions for writing RSA keys to memory.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

#ifdef USE_RSA
#ifdef USE_CERT_GEN
/******************************************************************************/
/**
    Memory version of private key creation.  Returns the ASN.1 encoding
    of the private key.  Not password protecting memory buffers.

    The caller must free the 'keyMem' parameter
 */
int32_t psRsaWritePrivKeyMem(psPool_t *pool, const psRsaKey_t *key,
    unsigned char **keyMem, psSize_t *keyMemLen)
{
    psBuf_t *keyOut;
    psSize_t binLen, totalLen;

    *keyMem = NULL;
    *keyMemLen = 0;

    /* Determine raw length of keys to estimate asn.1 length */
    der_length_integer(&key->N, &binLen);
    totalLen = binLen;
    der_length_integer(&key->e, &binLen);
    totalLen += binLen;
    der_length_integer(&key->d, &binLen);
    totalLen += binLen;
    der_length_integer(&key->p, &binLen);
    totalLen += binLen;
    der_length_integer(&key->q, &binLen);
    totalLen += binLen;
    der_length_integer(&key->dP, &binLen);
    totalLen += binLen;
    der_length_integer(&key->dQ, &binLen);
    totalLen += binLen;
    der_length_integer(&key->qP, &binLen);
    totalLen += binLen;
/*
    Get a maximum of how much mem is needed to hold all the binary
    keys along with the asn overhead. The number is the number of bigs (8)
    and the maximum amount of ASN overhead each could have.  The additional
    ASN_INTEGER is the ASN version 0 entry. The additional 8 bytes are for
    potential block cipher padding if this key will be password protected.
 */
    if ((keyOut = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    keyOut->size = totalLen + ASN_INTEGER_OH + ASN_SEQUENCE_OH + DES3_IVLEN;
    keyOut->start = keyOut->end = keyOut->buf = psMalloc(pool, keyOut->size);
    if (keyOut->start == NULL)
    {
        psFree(keyOut, pool);
        return PS_MEM_FAIL;
    }
/*
    Write sequence tag, length, and value:
        Int version, Big N,     Big e, Big d, Big p, Big q,     Big dP, Big dQ, Big qP
 */
    keyOut->end = keyOut->start += ASN_SEQUENCE_OH;
    asnWriteInteger(keyOut, 0); /* version 0 */
    asnWriteBig(pool, keyOut, &key->N);
    asnWriteBig(pool, keyOut, &key->e);
    asnWriteBig(pool, keyOut, &key->d);
    asnWriteBig(pool, keyOut, &key->p);
    asnWriteBig(pool, keyOut, &key->q);
    asnWriteBig(pool, keyOut, &key->dP);
    asnWriteBig(pool, keyOut, &key->dQ);
    asnWriteBig(pool, keyOut, &key->qP);
/*
    Skipped some room above to write the ASN_SEQUENCE out.  Use
    the special function to prepend it now
 */
    asnPrependSequence(keyOut);

    /* Assign to output params and free buf */
    *keyMemLen = (uint16_t) (keyOut->end - keyOut->start);
    if ((*keyMem = psMalloc(pool, *keyMemLen)) == NULL)
    {
        psFree(keyOut->buf, pool);
        psFree(keyOut, pool);
        return PS_MEM_FAIL;
    }
    Memcpy(*keyMem, keyOut->start, *keyMemLen);

    psFree(keyOut->buf, pool);
    psFree(keyOut, pool);
    return 0;
}

# endif /* USE_CERT_GEN */

#endif /* USE_RSA */

/******************************************************************************/

