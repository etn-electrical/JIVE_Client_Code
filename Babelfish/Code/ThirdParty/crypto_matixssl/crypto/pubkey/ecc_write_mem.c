/**
 *      @file    ecc_write_mem.c
 *
 *
 *      Functions for writing ECC private keys to memory.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */

#include "../cryptoImpl.h"

# ifdef USE_ECC
#  ifdef USE_CERT_GEN

static int32 P192OID[8] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x01 };
static int32 P224OID[5] = { 0x2B, 0x81, 0x04, 0x00, 0x21 };
static int32 P256OID[8] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07 };
static int32 P384OID[5] = { 0x2B, 0x81, 0x04, 0x00, 0x22 };
static int32 P521OID[5] = { 0x2B, 0x81, 0x04, 0x00, 0x23 };

/******************************************************************************/
/*
    Memory version of private key creation.  Returns the ASN.1 encoding
    of the private key.  Not password protecting memory buffers.

    The caller must free the 'keyMem' parameter
 */
int32_t psEccWritePrivKeyMem(psPool_t *pool, const psEccKey_t *key,
    unsigned char **keyMem, psSize_t *keyMemLen)
{
    psBuf_t *keyOut;
    unsigned char *privbin;
    unsigned char *pubbin;
    int32 privbinlen, OIDLen, bitStrLen;
    psSize_t pubkeyLen;
    int32 *curveAlg;

    *keyMem = NULL;
    *keyMemLen = 0;

    switch (key->curve->OIDsum)
    {
    case 211:
        curveAlg = &P521OID[0];
        OIDLen = sizeof(P521OID) / sizeof(int32);
        break;
    case 210:
        curveAlg = &P384OID[0];
        OIDLen = sizeof(P384OID) / sizeof(int32);
        break;
    case 526:
        curveAlg = &P256OID[0];
        OIDLen = sizeof(P256OID) / sizeof(int32);
        break;
    case 209:
        curveAlg = &P224OID[0];
        OIDLen = sizeof(P224OID) / sizeof(int32);
        break;
    case 520:
        curveAlg = &P192OID[0];
        OIDLen = sizeof(P192OID) / sizeof(int32);
        break;
    default:
        return PS_UNSUPPORTED_FAIL;
    }

    /* Determine raw length of keys to estimate asn.1 length */
    pubkeyLen = (1 + (2 * key->curve->size));
    if ((pubbin = psMalloc(pool, pubkeyLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    if (psEccX963ExportKey(pool, key, pubbin, &pubkeyLen) < 0)
    {
        psFree(pubbin, pool);
        return PS_FAILURE;
    }

    privbinlen = pstm_unsigned_bin_size(&key->k);
    if ((privbin = psMalloc(pool, privbinlen)) == NULL)
    {
        psFree(pubbin, pool);
        return PS_MEM_FAIL;
    }

/*
    Get a maximum of how much mem is needed to hold the binary
    key along with the asn overhead.
 */
    if ((keyOut = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        psFree(privbin, pool);
        psFree(pubbin, pool);
        return PS_MEM_FAIL;
    }

    keyOut->size = privbinlen + ASN_SEQUENCE_OH + ASN_INTEGER_OH + 1 +
                   ASN_OID_OH + OIDLen + ASN_OCTET_STRING_OH + 1 + ASN_BIT_STRING_OH +
                   pubkeyLen;
    keyOut->start = keyOut->end = keyOut->buf = psMalloc(pool, keyOut->size);
    if (keyOut->start == NULL)
    {
        psFree(privbin, pool);
        psFree(pubbin, pool);
        psFree(keyOut, pool);
        return PS_MEM_FAIL;
    }
/*
    ECPrivateKey ::= SEQUENCE {
        version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
        privateKey     OCTET STRING,
        parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
        publicKey  [1] BIT STRING OPTIONAL
    }
 */
    keyOut->end = keyOut->start += ASN_SEQUENCE_OH;

    asnWriteInteger(keyOut, 1); /* version 1 */
    pstm_to_unsigned_bin(pool, &key->k, privbin);
    keyOut->end += asn1WriteOctetString(keyOut->end, privbin, privbinlen);
    psFree(privbin, pool);

    /* Curve in OID parameters */
    *keyOut->end = (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED); keyOut->end++;
    keyOut->end += asnHelpWriteLength(keyOut->end, OIDLen + 1 +
        asnBytesToHold(OIDLen));
    asnWriteOid(keyOut, curveAlg, OIDLen);

    /* Public key */
    bitStrLen = pubkeyLen + 1;
    *keyOut->end = (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1); keyOut->end++;
    /* 1 BIT STRING, 1 IGNORE BIT */
    keyOut->end += asnHelpWriteLength(keyOut->end, bitStrLen + 1 +
        asnBytesToHold(bitStrLen));
    *keyOut->end = ASN_BIT_STRING; keyOut->end++;
    keyOut->end += asnHelpWriteLength(keyOut->end, bitStrLen);
    *keyOut->end = 0x0; keyOut->end++; /* ignore bits */
    Memcpy(keyOut->end, pubbin, pubkeyLen);
    keyOut->end += pubkeyLen;
    psFree(pubbin, pool);

/*
    Skipped some room above to write the ASN_SEQUENCE out.  Use
    the special function to prepend it now
 */
    asnPrependSequence(keyOut);

/*
    Assign to output params and free buf
 */
    *keyMemLen = (uint16_t) (keyOut->end - keyOut->start);
    if ((*keyMem = psMalloc(pool, *keyMemLen)) == NULL)
    {
        psFree(keyOut->buf, pool);
        psFree(keyOut, pool);
        return PS_MEM_FAIL;
    }
    Memcpy(*keyMem, keyOut->start, *keyMemLen);

    psFree(keyOut->buf, pool);
    psFree(keyOut, pool);

    return PS_SUCCESS;
}

#  endif /* USE_CERT_GEN */
# endif /* USE_ECC */

/* end of file ecc_keywrite.c */
