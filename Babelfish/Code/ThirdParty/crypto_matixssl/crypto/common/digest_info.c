/**
 *      @file    digest_info.c
 *
 *
 *      Static DigestInfo prefixes and querying functions for PKCS #1.5.
 */
/*
 *      Copyright (c) 2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */

#include "../cryptoImpl.h"

# ifdef USE_RSA

/*
  ASN.1 DER encoded DigestInfos.
  In RSA signature verification, the prefix of the RSA-decrypted message
  should be compared against one of these. The correct one can be fetched
  with psGetDigestInfoPrefix, which takes in as arguments the sig alg ID
  and the length of the decrypted message. Each DigestInfo has two variants:
  one with optional NULL parameters in the AlgorithmIdentifier, the other
  without.
*/

#  ifdef USE_MD2
static const unsigned char PKCS1Dig_MD2[] =
{
    0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86,
    0xf7, 0x0d, 0x02, 0x02, 0x05, 0x00, 0x04, 0x10
};
static const unsigned char PKCS1Dig_MD2_ALT[] =
{
    0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86,
    0xf7, 0x0d, 0x02, 0x02, 0x04, 0x10
};
#  endif /* USE_MD2 */

#  ifdef USE_MD5
static const unsigned char PKCS1Dig_MD5[] =
{
    0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86,
    0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10
};
static const unsigned char PKCS1Dig_MD5_ALT[] =
{
    0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86,
    0xf7, 0x0d, 0x02, 0x05, 0x04, 0x10
};
#  endif /* USE_MD5 */

#  ifdef USE_SHA1
static const unsigned char PKCS1Dig_SHA1[] =
{
    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03,
    0x02, 0x1a, 0x05, 0x00, 0x04, 0x14
};
static const unsigned char PKCS1Dig_SHA1_ALT[] =
{
    0x30, 0x1f, 0x30, 0x07, 0x06, 0x05, 0x2b, 0x0e, 0x03,
    0x02, 0x1a, 0x04, 0x14
};
#  endif /* USE_SHA1 */

#ifdef USE_SHA224
static const unsigned char PKCS1Dig_SHA224[] =
{
    0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48,
    0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c
};
static const unsigned char PKCS1Dig_SHA224_ALT[] =
{
    0x30, 0x2b, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48,
    0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x04, 0x1c
};
#  endif /* USE_SHA224 */

#  ifdef USE_SHA256
static const unsigned char PKCS1Dig_SHA256[] =
{
    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48,
    0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
};
static const unsigned char PKCS1Dig_SHA256_ALT[] =
{
    0x30, 0x2f, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48,
    0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x04, 0x20
};
#  endif /* USE_SHA256 */

#  ifdef USE_SHA384
static const unsigned char PKCS1Dig_SHA384[] =
{
    0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48,
    0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30
};
static const unsigned char PKCS1Dig_SHA384_ALT[] =
{
    0x30, 0x3f, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48,
    0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x04, 0x30
};
#  endif /* USE_SHA384 */

#  ifdef USE_SHA512
static const unsigned char PKCS1Dig_SHA512[] =
{
    0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48,
    0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40
};
static const unsigned char PKCS1Dig_SHA512_ALT[] =
{
    0x30, 0x4f, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48,
    0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x04, 0x40
};
#  endif /* USE_SHA512 */

const
unsigned char *psGetDigestInfoPrefix(int32_t len,
    int32_t sigAlg)
{
    switch (sigAlg)
    {
#  ifdef USE_MD2
    case OID_MD2_RSA_SIG:
        if (len == sizeof(PKCS1Dig_MD2) + MD2_HASH_SIZE)
        {
            return PKCS1Dig_MD2;
        }
        else if (len == sizeof(PKCS1Dig_MD2_ALT) + MD2_HASH_SIZE)
        {
            return PKCS1Dig_MD2_ALT;
        }
        break;
#  endif /* USE_MD2 */
#  ifdef USE_MD5
    case OID_MD5_RSA_SIG:
        if (len == sizeof(PKCS1Dig_MD5) + MD5_HASH_SIZE)
        {
            return PKCS1Dig_MD5;
        }
        else if (len == sizeof(PKCS1Dig_MD5_ALT) + MD5_HASH_SIZE)
        {
            return PKCS1Dig_MD5_ALT;
        }
        break;
#  endif /* USE_MD5 */
#  ifdef USE_SHA1
    case OID_SHA1_RSA_SIG:
        if (len == sizeof(PKCS1Dig_SHA1) + SHA1_HASH_SIZE)
        {
            return PKCS1Dig_SHA1;
        }
        else if (len == sizeof(PKCS1Dig_SHA1_ALT) + SHA1_HASH_SIZE)
        {
            return PKCS1Dig_SHA1_ALT;
        }
        break;
#  endif /* USE_SHA1 */
#  ifdef USE_SHA224
    case OID_SHA224_RSA_SIG:
        if (len == sizeof(PKCS1Dig_SHA224) + SHA224_HASH_SIZE)
        {
            return PKCS1Dig_SHA224;
        }
        else if (len == sizeof(PKCS1Dig_SHA224_ALT) + SHA224_HASH_SIZE)
        {
            return PKCS1Dig_SHA224_ALT;
        }
        break;
#  endif /* USE_SHA224 */
#  ifdef USE_SHA256
    case OID_SHA256_RSA_SIG:
        if (len == sizeof(PKCS1Dig_SHA256) + SHA256_HASH_SIZE)
        {
            return PKCS1Dig_SHA256;
        }
        else if (len == sizeof(PKCS1Dig_SHA256_ALT) + SHA256_HASH_SIZE)
        {
            return PKCS1Dig_SHA256_ALT;
        }
        break;
#  endif /* USE_SHA256 */
#  ifdef USE_SHA384
    case OID_SHA384_RSA_SIG:
        if (len == sizeof(PKCS1Dig_SHA384) + SHA384_HASH_SIZE)
        {
            return PKCS1Dig_SHA384;
        }
        else if (len == sizeof(PKCS1Dig_SHA384_ALT) + SHA384_HASH_SIZE)
        {
            return PKCS1Dig_SHA384_ALT;
        }
        break;
#  endif /* USE_SHA384 */
#  ifdef USE_SHA512
    case OID_SHA512_RSA_SIG:
        if (len == sizeof(PKCS1Dig_SHA512) + SHA512_HASH_SIZE)
        {
            return PKCS1Dig_SHA512;
        }
        else if (len == sizeof(PKCS1Dig_SHA512_ALT) + SHA512_HASH_SIZE)
        {
            return PKCS1Dig_SHA512_ALT;
        }
        break;
#  endif /* USE_SHA512 */
    default:
        psTraceCrypto("Unsupported RSA signature algorithm\n");
        return NULL;
    }

    return NULL;
}

# endif /* USE_RSA */
