/**
 *      @file    base64.c
 *
 *
 *      Base64 operations.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "osdep_stdio.h"
#include "../cryptoImpl.h"

#ifdef USE_BASE64_DECODE

static const unsigned char map[] = {
    255, 255, 255, 255,  255,  255,  255, 255,  255,   255,   255,   255,
    255, 255, 255, 255,  255,  255,  255, 255,  255,   255,   255,   255,
    255, 255, 255, 255,  255,  255,  255, 255,  255,   255,   255,   255,
    255, 255, 255, 255,  255,  255,  255, 62,   255,   255,   255,   63,
    52,  53,  54,  55,   56,   57,   58,  59,   60,    61,    255,   255,
    255, 254, 255, 255,  255,  0,    1,   2,    3,     4,     5,     6,
    7,   8,   9,   10,   11,   12,   13,  14,   15,    16,    17,    18,
    19,  20,  21,  22,   23,   24,   25,  255,  255,   255,   255,   255,
    255, 26,  27,  28,   29,   30,   31,  32,   33,    34,    35,    36,
    37,  38,  39,  40,   41,   42,   43,  44,   45,    46,    47,    48,
    49,  50,  51
/*           , 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255
 */
};

int32_t psBase64decode(const unsigned char *in, psSize_t len,
    unsigned char *out, psSize_t *outlen)
{
    unsigned int t;
    unsigned char c;
    uint16_t x, y, z;
    int16_t g;

    if (in == NULL || out == NULL || outlen == NULL)
    {
        psTraceCrypto("Arg failure to psBase64decode\n");
        return PS_ARG_FAIL;
    }
    g = 3;
    for (x = y = z = t = 0; x < len; x++)
    {
        /* Save a little space by skipping values that would be 255 in the full map */
        if (in[x] > 122)
        {
            continue;
        }
        c = map[in[x]];
        if (c == 255)
        {
            continue;
        }
        /* the final '=' symbols are read and used to trim the remaining bytes */
        if (c == 254)
        {
            c = 0;
            /* prevent g < 0 which would potentially allow an overflow later */
            if (--g < 0)
            {
                psTraceCrypto("Negative g failure in psBase64decode\n");
                return PS_LIMIT_FAIL;
            }
        }
        else if (g != 3)
        {
            /* we only allow = to be at the end */
            psTraceCrypto("g failure in psBase64decode\n");
            return PS_PARSE_FAIL;
        }

        t = (t << 6) | c;

        if (++y == 4)
        {
            if (z + g > *outlen)
            {
                psTraceCrypto("outlen too small for psBase64decode\n");
                return PS_LIMIT_FAIL;
            }
            out[z++] = (unsigned char) ((t >> 16) & 0xFF);
            if (g > 1)
            {
                out[z++] = (unsigned char) ((t >> 8) & 0xFF);
            }
            if (g > 2)
            {
                out[z++] = (unsigned char) (t & 0xFF);
            }
            y = t = 0;
        }
    }
    if (y != 0)
    {
        psTraceCrypto("y failure in psBase64decode\n");
        return PS_PARSE_FAIL;
    }
    *outlen = z;
    return PS_SUCCESS;
}

#endif /* USE_BASE64_DECODE */

/******************************************************************************/

#ifdef USE_CERT_GEN

static char bprivfile[] = "-----BEGIN RSA PRIVATE KEY-----\n";
static char eprivfile[] = "-----END RSA PRIVATE KEY-----\n";
static char becprivfile[] = "-----BEGIN EC PRIVATE KEY-----\n";
static char eecprivfile[] = "-----END EC PRIVATE KEY-----\n";
static char bcertfile[] = "-----BEGIN CERTIFICATE-----\n";
static char ecertfile[] = "-----END CERTIFICATE-----\n";
static char breqfile[] = "-----BEGIN CERTIFICATE REQUEST-----\n";
static char ereqfile[] = "-----END CERTIFICATE REQUEST-----\n";

# ifdef USE_3DES
static char encryptFileHdr[] =
    "Proc-Type: 4,ENCRYPTED\nDEK-Info: DES-EDE3-CBC,";
# endif

/******************************************************************************/
/*
    File helper - base64 Encode a buffer (NUL terminated)
    @param in      The input buffer to encode
    @param inlen   The length of the input buffer
    @param out     [out] The destination of the base64 encoded data
    @param outlen  [in/out] The max size and resulting size
    @return PS_SUCCESS if successful
 */
static const char *codes =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static int32 base64_encode(const unsigned char *in, uint32_t inlen,
    unsigned char *out, uint32_t *outlen)
{
    uint32_t i, len2, leven;
    unsigned char *p;

    /* valid output size ? */
    len2 = 4 * ((inlen + 2) / 3);
    if (*outlen < len2 + 1)
    {
        return -1;
    }
    p = out;
    leven = 3 * (inlen / 3);
    for (i = 0; i < leven; i += 3)
    {
        *p++ = codes[(in[0] >> 2) & 0x3F];
        *p++ = codes[(((in[0] & 3) << 4) + (in[1] >> 4)) & 0x3F];
        *p++ = codes[(((in[1] & 0xf) << 2) + (in[2] >> 6)) & 0x3F];
        *p++ = codes[in[2] & 0x3F];
        in += 3;
    }
    /* Pad it if necessary...  */
    if (i < inlen)
    {
        uint32_t a = in[0];
        uint32_t b = (i + 1 < inlen) ? in[1] : 0;

        *p++ = codes[(a >> 2) & 0x3F];
        *p++ = codes[(((a & 3) << 4) + (b >> 4)) & 0x3F];
        *p++ = (i + 1 < inlen) ? codes[(((b & 0xf) << 2)) & 0x3F] : '=';
        *p++ = '=';
    }

    /* append a NULL byte */
    *p = '\0';

    /* return ok */
    *outlen = (uint32_t) (p - out);
    return 0;
}

# ifdef MATRIX_USE_FILE_SYSTEM
/******************************************************************************/
/*
    Helper for the file writing versions to base64 encode the binary stream
    and write it to file.  Not static.  The keygen utilities use this.
 */
int32_t psBase64EncodeAndWrite(psPool_t *pool, const char *fileName,
    unsigned char *bin, uint32_t binLen,
    int32 fileType, char *hexCipherIV, psSize_t hexCipherIVLen)
{
    FILE *outFile;
    uint32_t encLen, bufLen, fileHdrLen, fileFtrLen;
    unsigned char *encCert, *tmpPtr;
    char *fileHdr, *fileFtr;

    if (fileType == REQ_FILE_TYPE)
    {
        fileHdr = breqfile;
        fileFtr = ereqfile;
        fileHdrLen = sizeof(breqfile);
        fileFtrLen = sizeof(ereqfile);
    }
    else if (fileType == CERT_FILE_TYPE)
    {
        fileHdr = bcertfile;
        fileFtr = ecertfile;
        fileHdrLen = sizeof(bcertfile);
        fileFtrLen = sizeof(ecertfile);
    }
    else if (fileType == RSAKEY_FILE_TYPE)
    {
        fileHdr = bprivfile;
        fileFtr = eprivfile;
        fileHdrLen = sizeof(bprivfile);
        fileFtrLen = sizeof(eprivfile);
    }
    else if (fileType == ECKEY_FILE_TYPE)
    {
        fileHdr = becprivfile;
        fileFtr = eecprivfile;
        fileHdrLen = sizeof(becprivfile);
        fileFtrLen = sizeof(eecprivfile);
    }
    else
    {
        return -1;
    }
    /* Base64 encode it all */
    encLen = (4 * ((binLen + 2) / 3)) + 1;
    if ((encCert = psMalloc(pool, encLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    base64_encode(bin, (unsigned long) (binLen), encCert,
        &encLen);
    /* Write it all out.  Base 64 material written in rows of 64 chars */
    if ((outFile = Fopen(fileName, "wb")) == NULL)
    {
        psTraceCrypto("Unable to open cert file for writing.\n");
        psFree(encCert, pool);
        return -1;
    }
    Fwrite(fileHdr, sizeof(char), fileHdrLen - 1, outFile);

# ifdef USE_3DES
    /* Password header if required */
    if (hexCipherIV && ((fileType == RSAKEY_FILE_TYPE) ||
                        (fileType == ECKEY_FILE_TYPE)))
    {
        Fwrite(encryptFileHdr, sizeof(char), sizeof(encryptFileHdr) - 1, outFile);
        Fwrite(hexCipherIV, sizeof(char), hexCipherIVLen, outFile);
        Fwrite("\n\n", sizeof(char), 2, outFile);
    }
# endif /* USE_3DES */

    tmpPtr = encCert;
    bufLen = 64;
    while (encLen > 0)
    {
        if (encLen < 64)
        {
            bufLen = encLen;
        }
        if (Fwrite(tmpPtr, sizeof(char), bufLen, outFile) != (uint32) bufLen)
        {
            psTraceCrypto("Error writing to file.\n");
            Fclose(outFile);
            psFree(encCert, pool);
            return -1;
        }
        Fwrite("\n", sizeof(char), 1, outFile);
        tmpPtr += bufLen; encLen -= bufLen;
    }
    Fwrite(fileFtr, sizeof(char), fileFtrLen - 1, outFile);
    Fclose(outFile);
    psFree(encCert, pool);
    return 0;
}
#endif /* MATRIX_USE_FILE_SYSTEM */
#endif /* USE_CERT_GEN */

/******************************************************************************/
