/**
 *      @file    x509enc.c
 *
 *
 *      Functions to encode X.509 certificates.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "osdep_stdio.h"
#include <arpa/inet.h>
#include "../cryptoImpl.h"

#ifdef USE_CERT_GEN


/******************************************************************************/
/* Not static because these are also used by x509req.c */
int32 md5RSAOID[9] = { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04 };
int32 sha1RSAOID[9] = { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05 };
int32 sha256RSAOID[9] = { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0B };
int32 sha384RSAOID[9] = { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0C };
int32 sha512RSAOID[9] = { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0D };
int32 sha224RSAOID[9] = { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0E };

int32 sha1ECCOID[7] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x01 };
int32 sha224ECCOID[8] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x01 };
int32 sha256ECCOID[8] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02 };
int32 sha384ECCOID[8] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x03 };
int32 sha512ECCOID[8] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x04 };

# define DN_TYPE_ASN 1
# define DN_TYPE_KEYPAIRS 2

# define MAX_UTCTIME_LEN 13 /* YYMMDDHHMMSSZ */
# define EXPLICIT_EXTENSION 3


static int32 psX509WriteCert(psPool_t *pool, psCertConfig_t *certConfig,
                             psPubKey_t *signingPrivKey, psPubKey_t *defPublicKey,
                             char *issuerDistinguishedName, int32 iDNLen, int32 iDNType,
                             char *subjectDistinguishedName, int32 sDNLen, int32 sDNType,
                             unsigned char *serialNumBuf, int32 serialNumLen,
                             unsigned char **certMemOut, int32 *certMemLen);

static int32 psWriteCertValidity(psPool_t *pool, psBuf_t *buf,
                                 int32 days, int32 *validDateLen);
static int32 psWriteCertValidityRange(psPool_t *pool, psBuf_t *buf,
        psBrokenDownTime_t *notBefore,
        int32 notBeforeEncoding,
        psBrokenDownTime_t *notAfter,
        int32 notAfterEncoding,
        int32 *validDateLen);
static void psWriteCertSerialNumber(psPool_t *pool,
                                    unsigned char **serialNumBuf, unsigned char *serialNum,
                                    int32 *serialNumLen);
static void psWriteCertVersion(psPool_t *pool, unsigned char **versionBuf,
                               int32 *versionLen, int32 version);
static int32 psWriteCertExt(psPool_t *pool, psBuf_t *buf,
                            x509v3extensions_t *ext, int32 *extLen,
                            psCertConfig_t *certConfig);
static int32 psWriteCertExtHeader(psPool_t *pool, psBuf_t *out,
                                  int32 allExtLen, int32 *extHdrLen);
static int32 psWriteCertSANExt(psPool_t *pool, psBuf_t *buf,
                               x509v3extensions_t *ext, int32 *extLen,
                               int issuerAltName);
static int32 psWriteAuthorityInfoAccessExt(psPool_t *pool, psBuf_t *buf,
                                           x509authorityInfoAccess_t *ext, int32 *extLen);
static int32 psWritePolicyQualifierInfo(psPool_t *pool, psBuf_t **qualInfoBuf,
                                        x509PolicyQualifierInfo_t *qualInfo,
                                        int32 *qualInfoLen);
static int32 psWritePolicyInformation(psPool_t *pool, psBuf_t **polInfoBuf,
                                      x509PolicyInformation_t *polInfo,
                                      int32 *polInfoLen);
static int32 psWriteCertPoliciesExt(psPool_t *pool, psBuf_t *buf,
                                    x509certificatePolicies_t *ext, int32 *extLen,
                                    psCertConfig_t *certConfig);
static int32 psWriteCertPolicyConstraintsExt(psPool_t *pool, psBuf_t *buf,
                                             x509policyConstraints_t *ext, int32 *extLen);
static int32 psWriteCertPolicyMappingsExt(psPool_t *pool, psBuf_t *buf,
                                          x509policyMappings_t *ext, int32 *extLen);
static int32 psWriteNetscapeCommentExt(psPool_t *pool, psBuf_t *buf,
                                       x509netscapeComment_t *nsCmt, int32 *extLen);
static int32 psWriteCertExtensions(psPool_t *pool, psBuf_t *out,
                                   psCertParts_t *certParts, psCertConfig_t *certConfig,
                                   int32 *outLen);
static int32 psWritePubkeyAlgWithOidParam(psPool_t *pool, psBuf_t *out,
                                          int32 oid[], int32 oidLen,
                                          int32 paramOid[], int32 paramOidLen, int32 *algIdLen);

static void freeCertParts(psCertParts_t *parts, psPool_t *pool);

/******************************************************************************/
/*
    Certificate creator.  Pass in the configuration file and private key for
    the self-signed cert being written.
 */
int32_t psX509WriteSelfSignedCertMem(psPool_t *pool, psCertConfig_t *certConfig,
    psPubKey_t *selfSigningPrivKey, unsigned char **certMemOut,
    int32_t *certMemLen)
{
    x509v3extensions_t *ext;
    unsigned char *authKeyId = NULL;
    int32_t authKeyIdLen, rc = PS_FAIL;
    psDigestContext_t hash;

/*
    This is a self-signed cert.  Make sure the config file has the DN attributes
 */
    if (certConfig->DNPairs == NULL)
    {
        psTraceCrypto("Error: config file must contain DN for self-signed cert\n");
        return PS_ARG_FAIL;
    }

    /* Set up our AuthKeyId and SubjectAuthKey, which are both the fingerprint
        of our own public key, us being a self-signed CA and all */
    ext = certConfig->ext;

    if (ext == NULL)
    {
        goto skip_extensions;
    }

    if ((ext->ak.keyId = psMalloc(pool, 20)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    ext->ak.keyLen = 20;
    if ((ext->sk.id = psMalloc(pool, 20)) == NULL)
    {
        psFree(ext->ak.keyId, pool);
        ext->ak.keyId = NULL;
        return PS_MEM_FAIL;
    }
    ext->sk.len = 20;

    switch (selfSigningPrivKey->type)
    {
# ifdef USE_RSA
    case PS_RSA:
        authKeyIdLen = pstm_unsigned_bin_size(&selfSigningPrivKey->key.rsa.N);
        if ((authKeyId = psMalloc(pool, authKeyIdLen)) == NULL)
        {
            rc = PS_MEM_FAIL;
            goto L_ERR;
        }
        if (pstm_to_unsigned_bin(pool, &selfSigningPrivKey->key.rsa.N,
                authKeyId) < 0)
        {
            goto L_ERR;
        }
        break;
#endif
# ifdef USE_ECC
    case PS_ECC:
        /* Magic 1 byte prefix is 0x4 uncompressed key type */
        authKeyIdLen =
            pstm_unsigned_bin_size(&selfSigningPrivKey->key.ecc.pubkey.x) +
            pstm_unsigned_bin_size(&selfSigningPrivKey->key.ecc.pubkey.y) + 1;
        if ((authKeyId = psMalloc(pool, authKeyIdLen)) == NULL)
        {
            rc = PS_MEM_FAIL;
            goto L_ERR;
        }
        *authKeyId = 0x4; /* uncompressed format */
        if (pstm_to_unsigned_bin(pool, &selfSigningPrivKey->key.ecc.pubkey.x,
                authKeyId + 1) < 0)
        {
            goto L_ERR;
        }
        if (pstm_to_unsigned_bin(pool,
                &selfSigningPrivKey->key.ecc.pubkey.y, authKeyId + 1 +
                pstm_unsigned_bin_size(&selfSigningPrivKey->key.ecc.pubkey.x)) < 0)
        {
            goto L_ERR;
        }
        break;
# endif /* USE_ECC */
    default:
        psTraceIntCrypto("Unsupported signing key type: %d\n",
                selfSigningPrivKey->type);
        return PS_UNSUPPORTED_FAIL;
    }

    psSha1PreInit(&hash.u.sha1);
    if (psSha1Init(&hash.u.sha1) < 0)
    {
        goto L_ERR;
    }
    psSha1Update(&hash.u.sha1, authKeyId, authKeyIdLen);
    psSha1Final(&hash.u.sha1, ext->ak.keyId);
    Memcpy(ext->sk.id, ext->ak.keyId, 20);
    psFree(authKeyId, pool);
    authKeyId = NULL;

skip_extensions:

    if (psX509WriteCert(pool, certConfig,
            selfSigningPrivKey, selfSigningPrivKey,
            certConfig->DNPairs, certConfig->DNPairsLen, DN_TYPE_KEYPAIRS,
            certConfig->DNPairs, certConfig->DNPairsLen, DN_TYPE_KEYPAIRS,
            certConfig->serialNumBuf, certConfig->serialNumLen,
            certMemOut, certMemLen) < 0)
    {
        psTraceCrypto("Error writing certificate to memory.\n");
        goto L_ERR;
    }

    return PS_SUCCESS;
L_ERR:
    psFree(ext->ak.keyId, pool);
    psFree(ext->sk.id, pool);
    /* Set these extension-specific pointers to NULL so that it is possible
       to call psX509FreeExtensions later without a double free. */
    ext->ak.keyId = NULL;
    ext->sk.id = NULL;
    if (authKeyId)
    {
        psFree(authKeyId, pool);
    }
    return rc;
}

int32_t psX509WriteSelfSignedCert(psPool_t *pool, psCertConfig_t *certConfig,
    psPubKey_t *selfSigningPrivKey, char *certFileOut)
{
    unsigned char *certMemOut;
    int32_t certMemLen, rc;

    if ((rc = psX509WriteSelfSignedCertMem(pool, certConfig, selfSigningPrivKey,
             &certMemOut, &certMemLen)) < 0)
    {
        return rc;
    }
    /* PEM format it and write */
    if (psBase64EncodeAndWrite(pool, certFileOut, certMemOut, certMemLen,
            CERT_FILE_TYPE, NULL, 0) < 0)
    {
        psTraceCrypto("Unable to base encode and write cert file\n");
        psFree(certMemOut, pool);
        return PS_FAILURE;
    }
    psFree(certMemOut, pool);
    return PS_SUCCESS;
}

# ifdef MATRIX_USE_FILE_SYSTEM
/******************************************************************************/
/*
    Certificate creator.  Pass in the configuration file and private key for
    the self-signed cert being written. Output is binary DER format.
 */
int32_t psX509WriteSelfSignedCertDer(psPool_t *pool, psCertConfig_t *certConfig,
    psPubKey_t *selfSigningPrivKey, char *certFileOut)
{
    unsigned char *certMemOut;
    int32_t certMemLen, rc;
    FILE *fp = 0;

    if ((rc = psX509WriteSelfSignedCertMem(pool, certConfig, selfSigningPrivKey,
             &certMemOut, &certMemLen)) < 0)
    {
        return rc;
    }

    /* Write DER */
    fp = Fopen(certFileOut, "w");
    if (!fp)
    {
        psTraceCrypto("Unable to write cert file\n");
        psFree(certMemOut, pool);
        return PS_FAILURE;
    }
    if (Fwrite(certMemOut, sizeof(char), certMemLen, fp) != certMemLen)
    {
        psTraceCrypto("Unable to write cert file\n");
        Fclose(fp);
        psFree(certMemOut, pool);
        return PS_FAILURE;
    }
    Fclose(fp);
    psFree(certMemOut, pool);
    return PS_SUCCESS;
}
# endif /* MATRIX_USE_FILE_SYSTEM */

int32 psX509SetCAIssuedCertExtensions(psPool_t *pool,
    psCertConfig_t *certConfig,
    x509v3extensions_t *reqExt,
    psX509Cert_t *caX509)
{
    int32 rc;

    /* Get certConfig ready for the certificate creation.  These
       extensions can be pulled from three      possible locations:  The CA
       cert subjectKeyId extension, the requested extensions in the
       request PEM, or the extensions in the configuration file that the
       CA wants to add.  In most cases, the extension in the request will
       override what is in the configuration file. */
    if (reqExt)                        /* extensions in the request itself */
    {
        if (certConfig->ext != NULL)   /* extensions from config file */
        {
            /* SubjectKeyId must come from whatever we, as a CA, decide
               it should be.  Override any in the cert request */
            certConfig->ext->sk.len = reqExt->sk.len;
            certConfig->ext->sk.id = reqExt->sk.id;
            reqExt->sk.id = NULL;

            if (reqExt->bc.cA != CA_UNDEFINED)
            {
                if (certConfig->ext->bc.cA != CA_UNDEFINED &&
                        (reqExt->bc.cA != certConfig->ext->bc.cA))
                {
                    psTraceCrypto("WARNING: Ignoring CA basicConstraint in config file. ");
                    psTraceCrypto("It was provided by the cert request itself\n");
                }
                certConfig->ext->bc.cA = reqExt->bc.cA;

                if ((certConfig->ext->bc.cA == CA_TRUE) &&
                    (certConfig->ext->bc.pathLenConstraint) != -1 &&
                    (reqExt->bc.pathLenConstraint !=
                     certConfig->ext->bc.pathLenConstraint))
                {
                    psTraceCrypto("WARNING: Ignoring pathLen basicConstraint in config file. ");
                    psTraceCrypto("It was provided by the cert request itself\n");
                }
                certConfig->ext->bc.pathLenConstraint =
                    reqExt->bc.pathLenConstraint;

            }

            /* subjectAltName */
            if (reqExt->san != NULL)
            {
                if (certConfig->ext->san != NULL)
                {
                    psTraceCrypto("WARNING: Ignoring SubjectAltName in config file. ");
                    psTraceCrypto("It was provided by the cert request itself\n");
                    psX509FreeSAN(certConfig->ext->san);
                }
                /* Assign the request as the one we use */
                certConfig->ext->san = reqExt->san;
                reqExt->san = NULL; /* Will be freed by certConfig now */
            }

            if (reqExt->keyUsageFlags != 0)
            {
                if (certConfig->ext->keyUsageFlags != 0)
                {
                    psTraceCrypto("WARNING: Ignoring keyUsage in config file. ");
                    psTraceCrypto("It was provided by the cert request itself\n");
                }
                certConfig->ext->keyUsageFlags = reqExt->keyUsageFlags;
            }
            if (reqExt->ekuFlags != 0)
            {
                if (certConfig->ext->ekuFlags != 0)
                {
                    psTraceCrypto("WARNING: Ignoring extendedKeyUsage in config file. ");
                    psTraceCrypto("It was provided by the cert request itself\n");
                }
                certConfig->ext->ekuFlags = reqExt->ekuFlags;
            }
        }
        else
        {
            /* No extensions in the CA config file.
               All extensions coming from the request. */
            certConfig->ext = reqExt;
            certConfig->ext->refCount++;

            /* The creator of the CSR is not allowed to decide
               which authKeyId to use. */
            if (certConfig->ext->ak.keyLen > 0 &&
                    certConfig->ext->ak.keyId)
            {
                psFree(certConfig->ext->ak.keyId, NULL);
            }
        }
    }
    else
    {
        /* No extensions in request. */
        if (certConfig->ext == NULL)
        {
            rc = x509NewExtensions(&certConfig->ext, pool);
            if (rc < 0)
            {
                return rc;
            }
        }
    }

    psAssert(certConfig->ext != NULL);

    /* Add the authorityKeyIdentifier extension whenever the CA cert
       has the subjectKeyIdentifier extension. This latter becomes
       our authKeyId. */
    certConfig->ext->ak.keyLen = caX509->extensions.sk.len;
    if (certConfig->ext->ak.keyLen > 0)
    {
        if ((certConfig->ext->ak.keyId = psMalloc(pool,
                                certConfig->ext->ak.keyLen)) == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memcpy(certConfig->ext->ak.keyId, caX509->extensions.sk.id,
                certConfig->ext->ak.keyLen);
    }
    else
    {
        certConfig->ext->ak.keyId = NULL;
    }

    return PS_SUCCESS;
}

int32_t psX509WriteCAIssuedCertMem(psPool_t *pool, psCertConfig_t *certConfig,
    psPubKey_t *reqPubKey, char *subjectDN, int32_t subjectDNLen,
    psX509Cert_t *caCert, psPubKey_t *caPrivKey,
    unsigned char **certMemOut, int32_t *certMemLenOut)
{
    unsigned char *certMem;
    char *issuerDN;
    int32 issuerDNLen, certMemLen, caPathLen;

    /* Test that the private key really is for the cert.  Not a 100%
            accurate method, but good enough to catch user mistakes */
    switch(caPrivKey->type)
    {
# ifdef USE_RSA         
    case PS_RSA:
        if (pstm_cmp(&caPrivKey->key.rsa.N, &caCert->publicKey.key.rsa.N) != 0)
        {
            psTraceCrypto("Private key does not match CA cert\n");
            return PS_FAILURE;
        }
        break;
#endif        
# ifdef USE_ECC
    case PS_ECC:
        if (pstm_cmp(&caPrivKey->key.ecc.pubkey.x,
                &caCert->publicKey.key.ecc.pubkey.x) != 0)
        {
            psTraceCrypto("Private key does not match CA cert\n");
            return PS_FAILURE;
        }
        break;
# endif /* USE_ECC */
    default:
        psTraceIntCrypto("Unsupported CA priv key type: %d\n",
                caPrivKey->type);
        return PS_UNSUPPORTED_FAIL;
    }

/*
    Also make sure that if a CA cert file was passed in that it is allowed
    to sign other certs.  For version 3 certs, we should check the
    basicConstraint extension
 */
    if (caCert->extensions.bc.cA != CA_TRUE)
    {
        psTraceCrypto("Supplied CA cert not allowed to sign certs\n");
        return PS_FAILURE;
    }
/*
    Also assert that the pathLen for the new cert is shorter than the issuer
 */
    caPathLen = caCert->extensions.bc.pathLenConstraint;
    if (caPathLen > 0 && caPathLen <= certConfig->ext->bc.pathLenConstraint)
    {
        psTraceCrypto("ERROR: Requested chain len must be less than CA.\n");
        return PS_FAILURE;
    }
/*
    Pull the issuer DN out of the parsed subject DN of the CA cert
 */
    issuerDNLen = caCert->subject.dnencLen;
    issuerDN = caCert->subject.dnenc;

/*
    Write it
 */
    if (psX509WriteCert(pool, certConfig, caPrivKey, reqPubKey,
            issuerDN, issuerDNLen, DN_TYPE_ASN, subjectDN, subjectDNLen,
            DN_TYPE_ASN, certConfig->serialNumBuf, certConfig->serialNumLen,
            &certMem, &certMemLen) < PS_SUCCESS)
    {
        psTraceCrypto("Error writing certificate to memory.\n");
        return PS_FAILURE;
    }

    *certMemOut = certMem;
    *certMemLenOut = certMemLen;
    return PS_SUCCESS;
}

int32_t psX509WriteCAIssuedCert(psPool_t *pool, psCertConfig_t *certConfig,
    psPubKey_t *reqPubKey, char *subjectDN, int32_t subjectDNLen,
    psX509Cert_t *caCert, psPubKey_t *caPrivKey,
    char *certFileOut)
{
    unsigned char *certMemOut;
    int32 certMemLen;
    int32_t rc;

    rc = psX509WriteCAIssuedCertMem(pool, certConfig, reqPubKey, subjectDN, subjectDNLen,
        caCert, caPrivKey, &certMemOut, &certMemLen);

    if (rc < 0) {
        return rc;
    }

/*
    PEM format it and write
 */
    if (psBase64EncodeAndWrite(pool, certFileOut, certMemOut, certMemLen,
            CERT_FILE_TYPE, NULL, 0) < 0)
    {
        psTraceCrypto("Unable to base encode and write cert file\n");
        psFree(certMemOut, pool);
        return PS_FAILURE;
    }
    psFree(certMemOut, pool);
    return PS_SUCCESS;
}



/******************************************************************************/
/*
    Write it
 */
static int32 psX509WriteCert(psPool_t *pool, psCertConfig_t *certConfig,
    psPubKey_t *signingPrivKey, psPubKey_t *defPublicKey,
    char *issuerDistinguishedName, int32 iDNLen, int32 iDNType,
    char *subjectDistinguishedName, int32 sDNLen, int32 sDNType,
    unsigned char *serialNum, int32 serialNumLen,
    unsigned char **certMemOut, int32 *certMemLen)
{
    psCertParts_t *certParts;
    psBuf_t *certBuf;
    int32 *certAlg;
    int32 certBufLen, oidLen, subjectDNLen, issuerDNLen;
    int32 pubKeyLen, certAlgIdLen, extBufLen;
    int32 validDateLen, versionLen;

/*
    Need to init all ASN parts to NULL for easy cleanup if any errors happen
    mid-routine
 */
    if ((certParts = psMalloc(pool, sizeof(psCertParts_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(certParts, 0x0, sizeof(psCertParts_t));
/*
    Version 3 indicated by the integer '2'
 */
    psWriteCertVersion(pool, &certParts->versionBuf, &versionLen,
            certConfig->version);
/*
    Serial number from input parameter
 */
    psWriteCertSerialNumber(pool, &certParts->serialNumBuf, serialNum,
        &serialNumLen);

/*
    Cert algorithm.
 */
    if (certConfig->certAlg == ALG_MD5)
    {
        if (signingPrivKey->type == PS_RSA)
        {
            certAlg = &md5RSAOID[0];
            oidLen = sizeof(md5RSAOID) / sizeof(int32);
        }
        else
        {
            psTraceCrypto("MD5 ECC signature not supported\n");
            freeCertParts(certParts, pool);
            return -1;
        }
    }
    else if (certConfig->certAlg == ALG_SHA1)
    {
        if (signingPrivKey->type == PS_RSA)
        {
            certAlg = &sha1RSAOID[0];
            oidLen = sizeof(sha1RSAOID) / sizeof(int32);
        }
        else
        {
            certAlg = &sha1ECCOID[0];
            oidLen = sizeof(sha1ECCOID) / sizeof(int32);
        }
    }
#ifdef USE_SHA224
    else if (certConfig->certAlg == ALG_SHA224)
    {
        if (signingPrivKey->type == PS_RSA)
        {
            certAlg = &sha224RSAOID[0];
            oidLen = sizeof(sha224RSAOID) / sizeof(int32);
        }
        else
        {
            certAlg = &sha224ECCOID[0];
            oidLen = sizeof(sha224ECCOID) / sizeof(int32);
        }
    }
#endif /* USE_SHA224 */
    else if (certConfig->certAlg == ALG_SHA256)
    {
        if (signingPrivKey->type == PS_RSA)
        {
            certAlg = &sha256RSAOID[0];
            oidLen = sizeof(sha256RSAOID) / sizeof(int32);
        }
        else
        {
            certAlg = &sha256ECCOID[0];
            oidLen = sizeof(sha256ECCOID) / sizeof(int32);
        }
    }
    else if (certConfig->certAlg == ALG_SHA384)
    {
        if (signingPrivKey->type == PS_RSA)
        {
            certAlg = &sha384RSAOID[0];
            oidLen = sizeof(sha384RSAOID) / sizeof(int32);
        }
        else
        {
            certAlg = &sha384ECCOID[0];
            oidLen = sizeof(sha384ECCOID) / sizeof(int32);
        }
    }
    else if (certConfig->certAlg == ALG_SHA512)
    {
        if (signingPrivKey->type == PS_RSA)
        {
            certAlg = &sha512RSAOID[0];
            oidLen = sizeof(sha512RSAOID) / sizeof(int32);
        }
        else
        {
            certAlg = &sha512ECCOID[0];
            oidLen = sizeof(sha512ECCOID) / sizeof(int32);
        }
    }
    else
    {
        freeCertParts(certParts, pool);
        return PS_UNSUPPORTED_FAIL;
    }

    if (psWriteCertAlgorithmId(pool, &certParts->certAlgIdBuf, certAlg,
            oidLen, &certAlgIdLen) < 0)
    {
        psTraceCrypto("Error writing cert algorithm\n");
        freeCertParts(certParts, pool);
        return -1;
    }
/*
    Validity
 */
    validDateLen = 0;
    if (certConfig->notBefore && certConfig->notAfter)
    {
        /* notBefore and notAfter dates given. */
        if (psWriteCertValidityRange(pool,
                        &certParts->validDateBuf,
                        certConfig->notBefore,
                        certConfig->notBeforeEncoding,
                        certConfig->notAfter,
                        certConfig->notAfterEncoding,
                        &validDateLen) < 0)
        {
            psTraceCrypto("Error writing cert validity dates\n");
            freeCertParts(certParts, pool);
            return -1;
        }
    }
    else
    {
        /* Only number of valid days given. */
        if (psWriteCertValidity(pool,
                        &certParts->validDateBuf,
                        certConfig->validDays,
                        &validDateLen) < 0)
        {
            psTraceCrypto("Error writing cert validity dates\n");
            freeCertParts(certParts, pool);
            return -1;
        }
    }

/*
    Subject DN attributes
 */
    if (sDNType == DN_TYPE_ASN)
    {
        certParts->subjectDNBuf.buf = certParts->subjectDNBuf.start =
                                          certParts->subjectDNBuf.end = psMalloc(pool, sDNLen);
        if (certParts->subjectDNBuf.buf == NULL)
        {
            freeCertParts(certParts, pool);
            return PS_MEM_FAIL;
        }
        subjectDNLen = sDNLen;
        Memcpy(certParts->subjectDNBuf.buf, subjectDistinguishedName, sDNLen);
        certParts->subjectDNBuf.end += sDNLen;
    }
    else
    {
        if (psWriteCertDNAttributes(pool, &certParts->subjectDNBuf,
                        subjectDistinguishedName, sDNLen, &subjectDNLen,
                        certConfig->DNPairsEncoding) < 0)
        {
            psTraceCrypto("Error writing subject DN attributes\n");
            freeCertParts(certParts, pool);
            return -1;
        }
    }

/*
    Issuer DN attributes
 */
    if (iDNType == DN_TYPE_ASN)
    {
        certParts->issuerDNBuf.buf = certParts->issuerDNBuf.start =
                                         certParts->issuerDNBuf.end = psMalloc(pool, iDNLen);
        if (certParts->issuerDNBuf.buf == NULL)
        {
            freeCertParts(certParts, pool);
            return PS_MEM_FAIL;
        }
        issuerDNLen = iDNLen;
        Memcpy(certParts->issuerDNBuf.buf, issuerDistinguishedName, iDNLen);
        certParts->issuerDNBuf.end += iDNLen;
    }
    else
    {
        if (psWriteCertDNAttributes(pool, &certParts->issuerDNBuf,
                        issuerDistinguishedName, iDNLen, &issuerDNLen,
                        certConfig->DNPairsEncoding) < 0)
        {
            psTraceCrypto("Error writing issuer DN attributes\n");
            freeCertParts(certParts, pool);
            return -1;
        }
    }

/*
    Public key
 */
    if (psWriteCertPublicKey(pool, &certParts->pubKeyBuf,
            certConfig->publicKey ? certConfig->publicKey :
            defPublicKey,
            &pubKeyLen) < 0)
    {
        psTraceCrypto("Error writing certificate public key\n");
        freeCertParts(certParts, pool);
        return -1;
    }

/*
    Version 3 extensions
 */
    extBufLen = 0;
    if (certConfig->version == x509_cert_v3 ||
        certConfig->version == x509_cert_v_default)
    {
        if (psWriteCertExtensions(pool, &certParts->extensionBuf, certParts,
                        certConfig, &extBufLen) < 0)
        {
            psTraceCrypto("Error writing certificate extensions\n");
            freeCertParts(certParts, pool);
            return -1;
        }
    }

/*
    Have all the parts.  Assemble it all in order.  The length calculation
    is all the parts plus the final signature write which includes a value
    the length of the key size, an ignore byte, and a BIT_STRING qualifier
 */
    certBufLen = (ASN_SEQUENCE_OH * 2) + versionLen + serialNumLen +
                 (certAlgIdLen * 2) + issuerDNLen + validDateLen + subjectDNLen +
                 pubKeyLen + extBufLen + ASN_BIT_STRING_OH + 1 + signingPrivKey->keysize;

    if (signingPrivKey->type == PS_ECC)
    {
        /* NEGATIVE ECDSA - Adding room for two 0x0 bytes in the
            ECDSA signature.

            However, if this is a 521 curve there is no chance
            for negative because there can only be a single
            low bit for that sig size. */
        if (signingPrivKey->keysize != 132)
        {
            certBufLen += 2;
        }
        /* Signature portion */
        certBufLen += 6; /* 6 = 2 ASN_SEQ, 4 ASN_BIG */
        /* BIG EC KEY.  The sig is 2 bytes len, 1 byte SEQ,
            1 byte length (+1 OPTIONAL byte if length is >=128),
            1 byte INT, 1 byte rLen, r, 1 byte INT, 1 byte sLen, s.
            So the +4 here are the 2 INT and 2 rLen/sLen bytes on
            top of the keysize */
        if (signingPrivKey->keysize + 4 >= 128)
        {
            certBufLen += 1; /* Extra byte for 'long' asn.1 encode */
        }
    }

    if ((certBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        freeCertParts(certParts, pool);
        return PS_MEM_FAIL;
    }
    certBuf->size = certBufLen;
    certBuf->start = certBuf->end = certBuf->buf = psMalloc(pool, certBufLen);
    if (certBuf->start == NULL)
    {
        psFree(certBuf, pool);
        freeCertParts(certParts, pool);
        return PS_MEM_FAIL;
    }

    certBuf->start = certBuf->end += (ASN_SEQUENCE_OH * 2);

    Memcpy(certBuf->end, certParts->versionBuf, versionLen);
    certBuf->end += versionLen;
    psFree(certParts->versionBuf, pool);

    Memcpy(certBuf->end, certParts->serialNumBuf, serialNumLen);
    certBuf->end += serialNumLen;
    psFree(certParts->serialNumBuf, pool);

    Memcpy(certBuf->end, certParts->certAlgIdBuf.start, certAlgIdLen);
    certBuf->end += certAlgIdLen; /* don't free. need again */

    Memcpy(certBuf->end, certParts->issuerDNBuf.start, issuerDNLen);
    certBuf->end += issuerDNLen;
    psFree(certParts->issuerDNBuf.buf, pool);

    Memcpy(certBuf->end, certParts->validDateBuf.start, validDateLen);
    certBuf->end += validDateLen;
    psFree(certParts->validDateBuf.buf, pool);

    Memcpy(certBuf->end, certParts->subjectDNBuf.start, subjectDNLen);
    certBuf->end += subjectDNLen;
    psFree(certParts->subjectDNBuf.buf, pool);

    Memcpy(certBuf->end, certParts->pubKeyBuf.start, pubKeyLen);
    certBuf->end += pubKeyLen;
    psFree(certParts->pubKeyBuf.buf, pool);

    if (certConfig->version == x509_cert_v3 ||
        certConfig->version == x509_cert_v_default)
    {
        Memcpy(certBuf->end, certParts->extensionBuf.start, extBufLen);
        certBuf->end += extBufLen;
        psFree(certParts->extensionBuf.buf, pool);
    }

    asnPrependSequence(certBuf);

    if (psWriteSignature(pool, certBuf, certParts->certAlgIdBuf.start,
            certAlgIdLen, signingPrivKey, certConfig->certAlg) < 0)
    {
        psFree(certParts->certAlgIdBuf.buf, pool);
        psFree(certParts, pool);
        psFree(certBuf->buf, pool);
        psFree(certBuf, pool);
        return -1;
    }
/*
    Clean up
 */
    psFree(certParts->certAlgIdBuf.buf, pool);
    psFree(certParts, pool);

/*
    Set the output buffer and length and free the certBuf.  The possible
    offset between "buf" and "start" make this copy necessary.
 */
    *certMemLen = (int32) (certBuf->end - certBuf->start);
    if ((*certMemOut = psMalloc(pool, *certMemLen)) == NULL)
    {
        psFree(certBuf->buf, pool);
        psFree(certBuf, pool);
        return PS_MEM_FAIL;
    }
    Memcpy(*certMemOut, certBuf->start, *certMemLen);

    psFree(certBuf->buf, pool);
    psFree(certBuf, pool);
    return 0;
}


/******************************************************************************/
/*
    Helper to free certPart members on error
 */
static void freeCertParts(psCertParts_t *parts, psPool_t *pool)
{
    if (parts->versionBuf != NULL)
    {
        psFree(parts->versionBuf, pool);
    }
    if (parts->serialNumBuf != NULL)
    {
        psFree(parts->serialNumBuf, pool);
    }
    if (parts->certAlgIdBuf.buf != NULL)
    {
        psFree(parts->certAlgIdBuf.buf, pool);
    }
    if (parts->issuerDNBuf.buf != NULL)
    {
        psFree(parts->issuerDNBuf.buf, pool);
    }
    if (parts->validDateBuf.buf != NULL)
    {
        psFree(parts->validDateBuf.buf, pool);
    }
    if (parts->subjectDNBuf.buf != NULL)
    {
        psFree(parts->subjectDNBuf.buf, pool);
    }
    if (parts->pubKeyBuf.buf != NULL)
    {
        psFree(parts->pubKeyBuf.buf, pool);
    }
    if (parts->extensionBuf.buf != NULL)
    {
        psFree(parts->extensionBuf.buf, pool);
    }
/*
    extParts are taken care of locally by the extension writer
 */
    psFree(parts, pool);
}

static void utchelper_fmt_2digit(int32 num, char **buf)
{
    /* Format a part of UTC time.
       Each field contains exactly two digits. */
    unsigned int unum = ((unsigned int) num) % 100;

    (*buf)[0] = (unum / 10) + '0';
    (*buf)[1] = (unum % 10) + '0';
    *buf += 2;
}

/* The time will be formatted according to ASN.1 UTCTime field. */
static int32 osGetUTCTime(psPool_t *pool, int32 days, char **utcTime,
    int32 *timeLen)
{
    psBrokenDownTime_t tmstruct;
    char *tmp;
    int32 pair;
    int32 res;

/*
    Multiply to get the number of seconds to add
 */
    res = psGetBrokenDownGMTime(&tmstruct, days * 24 * 60 * 60);
    if (res != PS_SUCCESS)
    {
        return res;
    }

    *timeLen = 13;
    tmp = *utcTime = psMalloc(pool, *timeLen);
    if (tmp == NULL)
    {
        return PS_MEM_FAIL;
    }

    pair = tmstruct.tm_year;
    utchelper_fmt_2digit(pair, &tmp);
    pair = tmstruct.tm_mon + 1;
    utchelper_fmt_2digit(pair, &tmp);
    utchelper_fmt_2digit(tmstruct.tm_mday, &tmp);
    utchelper_fmt_2digit(tmstruct.tm_hour, &tmp);
    utchelper_fmt_2digit(tmstruct.tm_min, &tmp);
    utchelper_fmt_2digit(tmstruct.tm_sec, &tmp);
    *tmp = 'Z';

    return 0;
}

static int32 psWriteCertValidityRange(psPool_t *pool, psBuf_t *buf,
        psBrokenDownTime_t *notBefore,
        int notBeforeEncoding,
        psBrokenDownTime_t *notAfter,
        int notAfterEncoding,
        int32 *validDateLen)
{
    char notBeforeStr[PS_BROKENDOWN_TIME_STR_LEN];
    char notAfterStr[PS_BROKENDOWN_TIME_STR_LEN];
    int32 rc, len;
    psDynBuf_t db;
    psDynBuf_t validityBuf;

    if (notBeforeEncoding != ASN_UTCTIME
            && notBeforeEncoding != ASN_GENERALIZEDTIME)
    {
        return PS_ARG_FAIL;
    }
    if (notAfterEncoding != ASN_UTCTIME
            && notAfterEncoding != ASN_GENERALIZEDTIME)
    {
        return PS_ARG_FAIL;
    }

    if (notBeforeEncoding == ASN_UTCTIME)
    {
        rc = psBrokenDownTimeStrTwoDigitYear(notBefore,
                &notBeforeStr);
    }
    else /* ASN_GENERALIZEDTIME */
    {
        rc = psBrokenDownTimeStr(notBefore,
                &notBeforeStr);
    }
    if (rc < 0)
    {
        return rc;
    }

    if (notAfterEncoding == ASN_UTCTIME)
    {
        rc = psBrokenDownTimeStrTwoDigitYear(notAfter,
                &notAfterStr);
    }
    else /* ASN_GENERALIZEDTIME */
    {
        rc = psBrokenDownTimeStr(notAfter,
                &notAfterStr);
    }
    if (rc < 0)
    {
        return rc;
    }

    /*
      Validity ::= SEQUENCE {
      notBefore      Time,
      notAfter       Time  }

      Time ::= CHOICE {
      utcTime        UTCTime,
      generalTime    GeneralizedTime }
    */
    psDynBufInit(pool, &db, 16);

    psDynBufBeginSequence(&db, &validityBuf);

    psDynBufAppendAsn1TagGen(&validityBuf,
            notBeforeEncoding,
            (const unsigned char*)notBeforeStr,
            strlen(notBeforeStr));

    psDynBufAppendAsn1TagGen(&validityBuf,
            notAfterEncoding,
            (const unsigned char*)notAfterStr,
            strlen(notAfterStr));

    psDynBufEndSequence(&validityBuf);

    psDynBufDetachBuf(&db, buf);

    len = (int32) (buf->end - buf->start);
    *validDateLen = len;

    return PS_SUCCESS;
}

/******************************************************************************/
/**
    We don't allow a notBefore time to be set in the future.  The
    days param just tells us how far in the future to set the
    notAfter member
 */
static int32 psWriteCertValidity(psPool_t *pool, psBuf_t *buf,
    int32 days, int32 *validDateLen)
{
    char *notBefore, *notAfter;
    int32 len;

    notBefore = notAfter = NULL;
    len = ASN_SEQUENCE_OH + ((ASN_UTCTIME_OH + MAX_UTCTIME_LEN) * 2);

    buf->buf = buf->start = buf->end = psMalloc(pool, len);
    if (buf->buf == NULL)
    {
        return PS_MEM_FAIL;
    }
    buf->size = len;

    buf->start = buf->end += ASN_SEQUENCE_OH;

    if (osGetUTCTime(pool, 0, &notBefore, &len) < 0)
    {
        if (notBefore)
        {
            psFree(notBefore, pool);
        }
        return -1;
    }
    *buf->end = ASN_UTCTIME; buf->end++;
    buf->end += asnHelpWriteLength(buf->end, len);
    Memcpy(buf->end, notBefore, len);
    buf->end += len;
    psFree(notBefore, pool);

    if (osGetUTCTime(pool, days, &notAfter, &len) < 0)
    {
        if (notAfter)
        {
            psFree(notAfter, pool);
        }
        return -1;
    }
    *buf->end = ASN_UTCTIME; buf->end++;
    buf->end += asnHelpWriteLength(buf->end, len);
    Memcpy(buf->end, notAfter, len);
    buf->end += len;
    psFree(notAfter, pool);

    asnPrependSequence(buf);

    *validDateLen = (int32) (buf->end - buf->start);
    return 0;
}

/******************************************************************************/
/*
    Not abusing the serial number stuff.  Just expecting an integer type.
    Allocates the serial number member of certParts.  Caller must free.
 */
static void psWriteCertSerialNumber(psPool_t *pool,
    unsigned char **serialNumBuf, unsigned char *serialNum,
    int32 *serialNumLen)
{
    unsigned char *tmp, *buf;
    int32 bytes, len;

/*
    Simple enough to do without overhead calculations and sslBuf_t mess
 */
    len = *serialNumLen;
    bytes = asnBytesToHold(len) + 1 + len;
    tmp = buf = psMalloc(pool, bytes);
    if (tmp == NULL)
    {
        return;
    }
    *buf = ASN_INTEGER; buf++;
    buf += asnHelpWriteLength(buf, len);

    Memcpy(buf, serialNum, *serialNumLen);

    *serialNumLen = (int32) bytes;
    *serialNumBuf = tmp;
}

/******************************************************************************/
/*
    Allocates the version member of certParts.  Caller must free
 */
static void psWriteCertVersion(psPool_t *pool, unsigned char **versionBuf,
    int32 *versionLen, int32 version)
{
    unsigned char *tmp, *buf;
    int32 versionEncoding = 2; /* Default to v3. */

    if (version == x509_cert_v2)
    {
        versionEncoding = 1;
    }
    else if (version == x509_cert_v1)
    {
        versionEncoding = 0;
    }

/*
    Always know the explicit length of this so no need to bother with
    overhead calculations and sslBuf_t type
 */
    *versionLen = 5;
    tmp = buf = psMalloc(pool, *versionLen);
    if (tmp == NULL)
    {
        return;
    }
    *buf = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED;
    buf++;
    buf += asnHelpWriteLength(buf, 3);
    *buf = ASN_INTEGER; buf++;
    buf += asnHelpWriteLength(buf, 1);
    *buf = versionEncoding;

    *versionBuf = tmp;
}

/******************************************************************************/
/*
    Deals with all extension writing.  Only one for now, but this is where the
    others will be
 */
static int32 psWriteCertExtensions(psPool_t *pool, psBuf_t *out,
    psCertParts_t *certParts, psCertConfig_t *certConfig,
    int32 *outLen)
{
    int32 extLen, hdrLen, extraExtLen, rc;

    extLen = extraExtLen = hdrLen = 0;

    if (certConfig->ext)
    {
        /* special writer or req work? */
        rc = psWriteCertExt(pool, &certParts->extParts.extraBuf, certConfig->ext,
                &extraExtLen, certConfig);
        if (rc < 0)
        {
            psTraceIntCrypto("psWriteCertExt failed: %d\n", rc);
            return rc;
        }
    }
    extLen += extraExtLen;

/*
    Write extension header that wraps them all
 */
    if (extLen > 0)
    {
        psWriteCertExtHeader(pool, &certParts->extParts.hdrBuf, extLen,
            &hdrLen);
    }
    extLen += hdrLen;

/*
    Concat all the parts into the final extension buffer and free
    the parts.
 */
    out->buf = out->start = out->end = psMalloc(pool, extLen);
    if (out->buf == NULL)
    {
        if (certConfig->ext)
        {
            psFree(certParts->extParts.extraBuf.buf, pool);
            certParts->extParts.extraBuf.buf = NULL;
        }
        psFree(certParts->extParts.hdrBuf.buf, pool);
        certParts->extParts.hdrBuf.buf = NULL;
        return PS_MEM_FAIL;
    }
    out->size = extLen;

    Memcpy(out->end, certParts->extParts.hdrBuf.start, hdrLen);
    out->end += hdrLen;
    Memcpy(out->end, certParts->extParts.extraBuf.start, extraExtLen);
    out->end += extraExtLen;

    if (certConfig->ext)
    {
        psFree(certParts->extParts.extraBuf.buf, pool);
        certParts->extParts.extraBuf.buf = NULL;
    }
    psFree(certParts->extParts.hdrBuf.buf, pool);
    certParts->extParts.hdrBuf.buf = NULL;

    *outLen = (int32) (out->end - out->start);
    return 0;
}

/******************************************************************************/
/*
    The ASN that surrounds all v3 extensions
 */
static int32 psWriteCertExtHeader(psPool_t *pool, psBuf_t *out,
    int32 allExtLen, int32 *extHdrLen)
{
    int32 len;

    len = ASN_SEQUENCE_OH + (ASN_LENGTH_OH + 1);

    out->end = out->start = out->buf = psMalloc(pool, len);
    if (out->end == NULL)
    {
        return PS_MEM_FAIL;
    }
    out->size = len;

    *out->end = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | EXPLICIT_EXTENSION;
    out->end++;
    out->end += asnHelpWriteLength(out->end, allExtLen + 1 +
        asnBytesToHold(allExtLen));

    *out->end = ASN_CONSTRUCTED | ASN_SEQUENCE; out->end++;
    out->end += asnHelpWriteLength(out->end, allExtLen);

    *extHdrLen = (int32) (out->end - out->start);
    return 0;
}

/******************************************************************************/

# define DN_COMMONNAME_OID { 0x55, 0x4, 0x3 }
# define DN_SERIALNUMBER_OID { 0x55, 0x04, 0x05 }
# define DN_COUNTRY_OID { 0x55, 0x4, 0x6 }
# define DN_STATE_OID { 0x55, 0x4, 0x8 }
# define DN_ORG_OID { 0x55, 0x4, 0xa }
# define DN_ORGUNIT_OID { 0x55, 0x4, 0xb }
# define DN_QUALIFIER_OID { 0x55, 0x4, 0x2e }
# define DN_DOMAIN_COMPONENT_OID { 0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19 }

# ifdef USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD
#  define DN_SURNAME_OID { 0x55, 0x4, 0x4 }
#  define DN_LOCALITY_OID { 0x55, 0x4, 0x7 }
#  define DN_TITLE_OID { 0x55, 0x4, 0xc }
#  define DN_STREET_OID { 0x55, 0x4, 0x9 }
#  define DN_GIVEN_NAME_OID { 0x55, 0x4, 0x2a }
#  define DN_INITIALS_OID { 0x55, 0x4, 0x2b }
#  define DN_GENERATION_QUALIFIER_OID { 0x55, 0x4, 0x2c }
#  define DN_PSEUDONYM_OID { 0x55, 0x04, 0x41 }
# endif /* USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD */

# ifdef USE_EXTRA_DN_ATTRIBUTES
#  define DN_EMAIL_OID { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x01 }
#  define DN_POSTAL_ADDRESS_OID { 0x55, 0x4, 0x10 }
#  define DN_TELEPHONE_NUMBER { 0x55, 0x04, 0x14 }
#  define DN_NAME_OID { 0x55, 0x04, 0x29 }
#  define DN_UID_OID { 0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x01 }
# endif /* USE_EXTRA_DN_ATTRIBUTES */

# define MAX_DN_ATTRIBUTE_INSTANCES  5
# define MAX_DN_ATTRIBUTE_OID_LEN 10 /* == domainComponent oid len. When adding
                                        new attribs, increase if necessary. */
typedef struct
{
    char *name;
    int32 oid[MAX_DN_ATTRIBUTE_OID_LEN];
    int32 oid_len;
    int32 index[MAX_DN_ATTRIBUTE_INSTANCES];
    int32 len[MAX_DN_ATTRIBUTE_INSTANCES];
    int32 encoding;
} DNAttribTypes_t;

static DNAttribTypes_t supportedDNTypes[] = {
    /* Geographical attribute types. */
    { "country",             DN_COUNTRY_OID,              3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
    { "stateOrProvince",     DN_STATE_OID,                3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# ifdef USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD
    { "locality",            DN_LOCALITY_OID,             3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
    { "streetAddress",       DN_STREET_OID,               3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# endif /* USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD */

    /* Organizational attribute types. */
    { "organization",        DN_ORG_OID,                  3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
    { "organizationalUnit",  DN_ORGUNIT_OID,              3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# ifdef USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD
    { "title",               DN_TITLE_OID,                3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# endif /* USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD */
    { "domainComponent",     DN_DOMAIN_COMPONENT_OID,     10,  { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },

    /* Labelling attribute types. */
# ifdef USE_EXTRA_DN_ATTRIBUTES
    { "name",                DN_NAME_OID,                 3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# endif /* USE_EXTRA_DN_ATTRIBUTES */
    { "commonName",          DN_COMMONNAME_OID,           3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# ifdef USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD
    { "surname",             DN_SURNAME_OID,              3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
    { "givenName",           DN_GIVEN_NAME_OID,           3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
    { "initials",            DN_INITIALS_OID,             3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
    { "generationQualifier", DN_GENERATION_QUALIFIER_OID, 3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# endif /* USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD */
    { "dnQualifier",         DN_QUALIFIER_OID,            3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
    { "serialNumber",        DN_SERIALNUMBER_OID,         3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# ifdef USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD
    { "pseudonym",           DN_PSEUDONYM_OID,            3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# endif /* USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD */

    /* Postal addressing attribute types. */
# ifdef USE_EXTRA_DN_ATTRIBUTES
    { "postalAddress",       DN_POSTAL_ADDRESS_OID,       3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },

    /* Telecommunications addressing attribute types. */
    { "telephoneNumber",     DN_TELEPHONE_NUMBER,         3,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },

    /* LDAP defined attribute types. */
    { "uid",                 DN_UID_OID,                  10,  { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },

    /* Other attribute types. */
    { "email",               DN_EMAIL_OID,                9,   { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 },
# endif /* USE_EXTRA_DN_ATTRIBUTES */
    { NULL,                  { 0x0,                       0x0,                       0x0 }, 3, { -1, -1, -1, -1, -1 }, { 0, 0, 0, 0, 0 }, 0 }
};

# ifdef USE_RSA 
static int32 rsaPubKeyOID[9] = { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01 };
# endif /* USE_RSA */
static int32 sha1OID[5] = { 0x2b, 0x0e, 0x03, 0x02, 0x1a };
static int32 sha256OID[9] = { 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01 };
# ifdef USE_SHA224
static int32 sha224OID[9] = { 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04 };
# endif /* USE_SHA224 */
# ifdef USE_MD5
static int32 md5OID[8] = { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05 };
# endif /* USE_MD5 */
# ifdef USE_SHA384
static int32 sha384OID[9] = { 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02 };
# endif
# ifdef USE_SHA512
static int32 sha512OID[9] = { 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03 };
# endif

# ifdef USE_ECC
static int32 ecPubKeyOID[7] = { 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01 };
static int32 ecP192OID[8] = { 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x01 };
static int32 ecP224OID[5] = { 0x2B, 0x81, 0x04, 0x00, 0x21 };
static int32 ecP256OID[8] = { 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07 };
static int32 ecP384OID[5] = { 0x2B, 0x81, 0x04, 0x00, 0x22 };
static int32 ecP521OID[5] = { 0x2B, 0x81, 0x04, 0x00, 0x23 };
# endif


/* extensionRequest oid */
static int32 extReqOID[9] = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x0E };

/* extensions */
static int32 basicConstraintOID[3] = { 0x55, 0x1d, 0x13 };
static int32 sanExtOID[3] = { 0x55, 0x1D, 0x11 };               /* subject alt name */
static int32 issuerAltNameExtOID[3] = { 0x55, 0x1D, 0x12 };     /* issuer alt name */
static int32 kuExtOID[3] = { 0x55, 0x1D, 0x0F };                /* keyUsage */
static int32 skExtOID[3] = { 0x55, 0x1D, 0x0E };                /* SubjectKeyId */
static int32 certificatePoliciesExtOID[3] = { 0x55, 0x1d, 0x20 };
static int32 policyMappingsExtOID[3] = { 0x55, 0x1d, 0x21 };    /* policyMappings */
static int32 akExtOID[3] = { 0x55, 0x1D, 0x23 };                /* AuthorityKeyId */
static int32 policyConstraintsExtOID[3] = { 0x55, 0x1d, 0x24 }; /* policyConstraints */
static int32 authorityInfoAccessExtOID[8] = { 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01 };
static int32 ekuExtOID[3] = { 0x55, 0x1D, 0x25 };               /* ExtendedKeyUsage */
static int32 netscapeCommentExtOID[9] = { 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42, 0x01, 0x0D };

static int32 tlsServerAuth[8] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01 };
static int32 tlsClientAuth[8] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02 };
static int32 codeSigning[8] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03 };

static int32 id_ad_ocspOID[8] = { 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01 };
static int32 id_ad_caIssuersOID[8] = { 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02 };
static int32 id_qt_cpsOID[8] = { 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01 };
static int32 id_qt_unoticeOID[8] = { 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02 };

static int32 psWriteCertExtWrapper(psPool_t *pool, psBuf_t *buf,
                                   int32 *finalExtLen, unsigned char *extBuf, int32 extBufLen,
                                   int32 oid[], int32 oidLen, int32 critical);
static int32 psWriteCertBasicConstraints(psPool_t *pool, psBuf_t *bcBuf,
                                         int32 caBool, int32 pathLen, int32 *bcExtLen);
static int32 psWriteCertKeyUsage(psPool_t *pool, psBuf_t *kuBuf,
                                 x509v3extensions_t *ext, int32 *kuExtLen);
static int32 psWriteCertExtKeyUsage(psPool_t *pool, psBuf_t *kuBuf,
                                    x509v3extensions_t *ext, int32 *kuExtLen);

/******************************************************************************/
/*
    Helper routine for the individual key=value pairs of the DN ASN
 */
static int writeAsnDNValue(psPool_t *pool, char *data, int32 oid[],
        int32 oidLen, int32 index, int32 len, int32 encoding, psBuf_t *buf,
        int32 *outLen)
{
    int32 asnLen;

    asnLen = ASN_SET_OH + ASN_SEQUENCE_OH + ASN_OID_OH + oidLen +
             ASN_STRING_OH + len;

    buf->buf = buf->start = buf->end = psMalloc(pool, asnLen);
    if (buf->buf == NULL)
    {
        *outLen = 0;
        return PS_MEM_FAIL;
    }
    buf->size = asnLen;
/*
    Have two to prepend this time:  SEQUENCE and SET
 */
    buf->end = buf->start += ASN_SEQUENCE_OH + ASN_SET_OH;

    asnWriteOid(buf, oid, oidLen);
/*
    The UTF8String encoding is the preferred encoding, and all certificates
    issued after December 31, 2003 MUST use the UTF8String encoding
 */
    if (encoding == 0)
    {
        encoding = ASN_UTF8STRING; /* Default. */
    }

    switch(encoding)
    {
    case ASN_UTF8STRING:
        *buf->end = ASN_UTF8STRING;
        break;
    case ASN_IA5STRING:
        *buf->end = ASN_IA5STRING;
        break;
    case ASN_PRINTABLESTRING:
        *buf->end = ASN_PRINTABLESTRING;
        break;
    default:
        psTraceIntCrypto("Unsupported ASN.1 string type " \
                "in writeAsnDNValue: %d\n",
                encoding);
        return PS_UNSUPPORTED_FAIL;
    }
    buf->end++;
    buf->end += asnHelpWriteLength(buf->end, len);
    Memcpy(buf->end, data + index, len);
    buf->end += len;
    asnPrependSequence(buf);
    asnPrependSet(buf);

    *outLen = (int32) (buf->end - buf->start);
    return 0;
}

/******************************************************************************/
/*
    Allocates the DN member of certParts.  Caller must free buf->buf
 */
int32 psWriteCertDNAttributes(psPool_t *pool,
        psBuf_t *buf,
        char *keyValPairsIn,
        int32 keyValPairsInLen,
        int32 *DNLen,
        int32 *encoding)
{
    psBuf_t out;
    char idName[24];
    char *tmp;
    int32_t len, i, k, n, s;
    int32_t idNameIndex;
    int32_t valCount, totalValuesLen, outLen;
    int32_t thisValStartIndex, thisValLen;
    short attcount;
    int32_t numParsed = 0;
    char *keyValPairs = NULL;
    int32_t keyValPairsLen;
    int32_t rc = PS_FAILURE;

    /* Take a copy of the input key-value pair string. We may possibly
       need to unescape it. */
    keyValPairsLen = keyValPairsInLen;
    keyValPairs = psMalloc(pool, keyValPairsLen);
    if (keyValPairs == NULL)
    {
        rc = PS_MEM_FAIL;
        goto out_fail_no_buf;
    }
    Memcpy(keyValPairs, keyValPairsIn, keyValPairsLen);

    tmp = keyValPairs;
    valCount = totalValuesLen = i = 0;

    /* Key-value pairs must be of the form key="value";key2="value2"; */
    while (i < keyValPairsLen)
    {
        /* Parse the key. */
        idNameIndex = 0;
        while (tmp[i] != '=' && i < keyValPairsLen - 2)
        {
            idName[idNameIndex++] = tmp[i];
            i++;
        }
        i++;

        /* Parse the value. */

        /* Value must be in double quotes. */
        if (tmp[i++] != '\"')
        {
            rc = PS_ARG_FAIL;
            goto out_fail_no_buf;
        }

        /* Compute value length and remove escape characters. */
        thisValStartIndex = i;
        thisValLen = 0;
        for (s = thisValStartIndex; s < keyValPairsLen; s++)
        {
            /* An unescaped double quote terminates the value. */
            if (tmp[s] == '\"')
            {
                s++;
                break;
            }
            /* Escaped double quotes are part of the value. */
            else if (tmp[s] == '\\'
                    && s < keyValPairsLen - 1
                    && tmp[s+1] == '\"')
            {
                /* Remove the escape character. */
                for (k = s; k < keyValPairsLen - 1; k++)
                {
                    tmp[k] = tmp[k+1];
                }
                keyValPairsLen--;
                thisValLen++;
            }
            else
            {
                thisValLen++;
            }
        }
        i = s;

        if (i >= keyValPairsLen)
        {
            psTraceCrypto("Unexpected end of buffer.\n");
            rc = PS_ARG_FAIL;
            goto out_fail_no_buf;
        }

        /* Value must be followed by an unescaped semicolon. */
        if (tmp[i] != ';')
        {
            psTraceCrypto("Invalid DN attribute format: missing terminating " \
                    "semicolon for value.\n");
            rc = PS_ARG_FAIL;
            goto out_fail_no_buf;
        }
        i++;

        /* Which DN attribute is it? */
        n = 0;
        while (supportedDNTypes[n].name != NULL)
        {
            if (Strncmp(idName, supportedDNTypes[n].name, idNameIndex) == 0)
            {
                attcount = 0;
                while (supportedDNTypes[n].index[attcount] >= 0)
                {
                    attcount++;
                    if (attcount == MAX_DN_ATTRIBUTE_INSTANCES)
                    {
                        psTraceCrypto("Too many DN attribute instances\n");
                        rc = PS_ARG_FAIL;
                        goto out_fail_no_buf;
                    }
                }

                /* Store the value start index and length. */
                supportedDNTypes[n].index[attcount] = thisValStartIndex;
                supportedDNTypes[n].len[attcount] = thisValLen;
                if (encoding != NULL)
                {
                    supportedDNTypes[n].encoding = encoding[numParsed];
                }
                valCount++;
                totalValuesLen += thisValLen;
                numParsed++;
                break;
            }
            n++;
        }
    }

    /* Get maximum size of complete ASN */
    len = ASN_SEQUENCE_OH + totalValuesLen +
          (valCount *
                  (ASN_SET_OH + ASN_SEQUENCE_OH + ASN_OID_OH + ASN_STRING_OH));

    buf->buf = buf->start = buf->end = psMalloc(pool, len);
    if (buf->buf == NULL)
    {
        rc = PS_MEM_FAIL;
        goto out_fail_no_buf;
    }
    buf->size = len;
    buf->end = buf->start += ASN_SEQUENCE_OH;

    /*
      Each value is sent through the helper routine that does the ASN for each
      before the final SEQUENCE is prepended
    */
    n = 0;
    while (supportedDNTypes[n].name != NULL)
    {
        attcount = 0;
        while (supportedDNTypes[n].index[attcount] >= 0)
        {
            if (writeAsnDNValue(pool, tmp,
                    supportedDNTypes[n].oid,
                    supportedDNTypes[n].oid_len,
                    supportedDNTypes[n].index[attcount],
                    supportedDNTypes[n].len[attcount],
                    supportedDNTypes[n].encoding,
                    &out, &outLen) < 0)
            {
                rc = PS_ARG_FAIL;
                goto out_fail;
            }
            Memcpy(buf->end, out.start, outLen);
            buf->end += outLen;
            psFree(out.buf, pool);
            /* Clear after write. Certs come through 2x for subject & issuer */
            supportedDNTypes[n].index[attcount] = -1;
            supportedDNTypes[n].len[attcount] = 0;
            attcount++; /* array bound checking done above */
            if (attcount == MAX_DN_ATTRIBUTE_INSTANCES)
            {
                break;  /* if all instances are used */
            }
        }
        n++;
    }

    asnPrependSequence(buf);

    *DNLen = (int32) (buf->end - buf->start);

    rc = PS_SUCCESS;

out_fail:
    if (rc != PS_SUCCESS)
    {
        psFree(buf->buf, pool);
    }
out_fail_no_buf:
    psFree(keyValPairs, pool);

    return 0;
}

/******************************************************************************/
/*
    Writes OID algorithms.  Allocates memory the caller must free
 */
static int32 psWriteCertAlgorithmIdParams(psPool_t *pool, psBuf_t *out, int32 oid[],
    int32 oidLen, int32 *algIdLen, const unsigned char *params, int32 paramsLen)
{
    int32 len;

    len = ASN_SEQUENCE_OH + ASN_OID_OH + MAX_OID_LEN + paramsLen;

    out->buf = out->start = out->end = psMalloc(pool, len);
    if (out->buf == NULL)
    {
        return PS_MEM_FAIL;
    }
    out->size = len;

    out->end = out->start += ASN_SEQUENCE_OH;
    if (asnWriteOid(out, oid, oidLen) < 0)
    {
        psFree(out->buf, pool);
        return -1;
    }
    if (paramsLen)
    {
        Memcpy(out->end, params, (psSizeL_t)paramsLen);
        out->end += paramsLen;
    }
    asnPrependSequence(out);

    *algIdLen = (int32) (out->end - out->start);
    return 0;
}

/* Helper function for OID comparison.
   oid is in x509enc.c input format and oidbuf is OID encoding.

   The function will always require that oid length is the same than
   lenght of oid in oidbuf, but len can be used to ignore the values of
   last digit(s) of the oid. */
static int xOidCmp(const int32 *oid, int32 oidLen, const char *oidbuf, int len)
{
    int i;

    if (oidLen != oidbuf[1])
    {
       return (int) (oidbuf[1] - oidLen);
    }

    for(i = 0; i < len; i++)
    {
        char byte = (char) oid[i];
        if (byte != oidbuf[2 + i])
        {
            return (int) (oidbuf[2 + i] - byte);
        }
    }
    return 0;
}

int32 psWriteCertAlgorithmId(psPool_t *pool, psBuf_t *out, int32 oid[],
    int32 oidLen, int32 *algIdLen)
{
    const char oid_tab_rsa[] = OID_SHA1_RSA_SIG_HEX;
    const char oid_tab_ecdsa[] = OID_SHA256_ECDSA_SIG_HEX;
    const char oid_tab_ecdsa_sha1[] = OID_SHA1_ECDSA_SIG_HEX;
    const char oid_tab_dsa_sha1[] = OID_SHA1_DSA_SIG_HEX;
    const char oid_tab_sha1[] = OID_SHA1_ALG_HEX;
    const char oid_tab_digest[] = OID_SHA256_ALG_HEX;
    const unsigned char paramsRsa[2] = { ASN_NULL, 0 };
    int32 paramsLen = -1; /* Will be replaced by 0 or 2. */

    /* Different AlgorithmIds have different conventions for
       use of parameters. To determine what parameters to use,
       the function will begin by decoding the OID and determining
       parameters according to it. */

    if (oidLen < 1)
    {
       return PS_FAILURE; /* Too short Oid. */
    }

    switch(oid[0])
    {
       case 0x2a: /* 1.2.* */
       if (oidLen == 9 && xOidCmp(oid, oidLen, oid_tab_rsa, 8) == 0)
       {
           /* Variant of RSA encryption */
           if (oid[8] != 6 && oid[8] != 7 && oid[8] != 10)
           {
               /* Algorithm is not OAEP or PSA: Parameters are NULL. */
               paramsLen = 2;
           }
       }
       else if (xOidCmp(oid, oidLen, oid_tab_ecdsa, 7) == 0)
       {
           /* ecdsa-with-SHA256 or any other SHA-2 family hash.
              These do not use parameters. */
           paramsLen = 0;
       }
       else if (xOidCmp(oid, oidLen, oid_tab_ecdsa_sha1, 7) == 0)
       {
           /* ecdsa-with-SHA1: Does not use parameters. */
           paramsLen = 0;
       }
       else if (xOidCmp(oid, oidLen, oid_tab_dsa_sha1, 7) == 0)
       {
           /* dsa-with-SHA1: Does not use parameters. */
           paramsLen = 0;
       }
       break;
       case 0x2b: /* 1.3.* */
       if (xOidCmp(oid, oidLen, oid_tab_sha1, 5) == 0)
       {
           /* sha1: Encode as in PKCS #1 (RFC #3447, section 9.2); i.e.
              using single NULL parameter. */
           paramsLen = 2;
       }
       break;
       default: /* 2.14.* (case 0x60) and others. */
       if (xOidCmp(oid, oidLen, oid_tab_digest, 8) == 0)
       {
           /* Other hash algorithm, such as SHA-256:
              Encode as in PKCS #1 (RFC #3447, section 9.2);
              i.e. using single NULL parameter. */
           paramsLen = 2;
       }
       break;
    }

    if (paramsLen < 0)
    {
       /* No support for specified OID algorithm. */       
       return PS_FAILURE;
    }

    /* Write AlgorithmId with parameters chosen according to oid. */
    return psWriteCertAlgorithmIdParams(pool, out, oid, oidLen, algIdLen,
                                        paramsRsa, paramsLen);
}

/* For writing EC public keys where the parameters value is another OID
    of the curve */
int32 psWritePubkeyAlgWithOidParam(psPool_t *pool, psBuf_t *out, int32 oid[],
    int32 oidLen, int32 paramOid[], int32 paramOidLen, int32 *algIdLen)
{
    int32 len;

    len = ASN_SEQUENCE_OH + ((ASN_OID_OH + MAX_OID_LEN) * 2);

    out->buf = out->start = out->end = psMalloc(pool, len);
    if (out->buf == NULL)
    {
        return PS_MEM_FAIL;
    }
    out->size = len;

    out->end = out->start += ASN_SEQUENCE_OH;
    if (asnWriteOid(out, oid, oidLen) < 0)
    {
        psFree(out->buf, pool);
        return -1;
    }
    if (asnWriteOid(out, paramOid, paramOidLen) < 0)
    {
        psFree(out->buf, pool);
        return -1;
    }
    asnPrependSequence(out);

    *algIdLen = (int32) (out->end - out->start);
    return 0;
}


/******************************************************************************/
/*
    Handles the algorithm identifier and other ASN header info around
    the RSA public key
 */
int32 psWriteCertPublicKey(psPool_t *pool, psBuf_t *buf,
    psPubKey_t *key, int32 *pubKeyLen)
{
    psBuf_t pubKeyAlgIdBuf;
    psSize_t keyBinSize, curveOIDLen;
    int32_t pubKeyAlgIdLen, len, oidLen; 
# ifdef USE_RSA       
    psRsaKey_t *rsaKey = NULL;
    psSize_t nBinSize, eBinSize;
#endif    
# ifdef USE_ECC
    int32 *curveOID;
    psEccKey_t *eccKey = NULL;
# endif

    switch(key->type)
    {
# ifdef USE_RSA      
    case PS_RSA:
        rsaKey = &key->key.rsa;
        der_length_integer(&rsaKey->N, &nBinSize);
        der_length_integer(&rsaKey->e, &eBinSize);
        keyBinSize = nBinSize + eBinSize;

        /* Begin max size computation.  keyBinSize already contains the INTEGER
            overhead.  Add in the two SEQUENCE ids and the BIT_STRING id that
            surrounds the public key.  The 1 is the ignore bits byte
         */
        len = ASN_BIT_STRING_OH + (ASN_SEQUENCE_OH * 2) + 1 + keyBinSize;

        /* public key algorithm id */
        oidLen = sizeof(rsaPubKeyOID) / sizeof(int32);
        if (psWriteCertAlgorithmId(pool, &pubKeyAlgIdBuf, rsaPubKeyOID, oidLen,
                &pubKeyAlgIdLen) < 0)
        {
            return -1;
        }
        break;
#endif        
# ifdef USE_ECC
    case PS_ECC:
        eccKey = &key->key.ecc;

        keyBinSize = psEccSize(eccKey);

        len = ASN_BIT_STRING_OH + (ASN_SEQUENCE_OH * 2) + 1 + keyBinSize;

        /* curve OID  */
        switch (eccKey->curve->curveId)
        {
        case IANA_SECP192R1:
            curveOID = ecP192OID;
            curveOIDLen = sizeof(ecP192OID) / sizeof(int32);
            break;
        case IANA_SECP224R1:
            curveOID = ecP224OID;
            curveOIDLen = sizeof(ecP224OID) / sizeof(int32);
            break;
        case IANA_SECP256R1:
            curveOID = ecP256OID;
            curveOIDLen = sizeof(ecP256OID) / sizeof(int32);
            break;
        case IANA_SECP384R1:
            curveOID = ecP384OID;
            curveOIDLen = sizeof(ecP384OID) / sizeof(int32);
            break;
        case IANA_SECP521R1:
            curveOID = ecP521OID;
            curveOIDLen = sizeof(ecP521OID) / sizeof(int32);
            break;
        default:
            return PS_UNSUPPORTED_FAIL;
        }
        len += curveOIDLen;
        /* public key algorithm id */
        oidLen = sizeof(ecPubKeyOID) / sizeof(int32);

        if (psWritePubkeyAlgWithOidParam(pool, &pubKeyAlgIdBuf, ecPubKeyOID,
                oidLen, curveOID, curveOIDLen,  &pubKeyAlgIdLen) < 0)
        {
            return PS_FAIL;
        }
        break;
# endif /* USE_ECC */
    default:
        psTraceIntCrypto("Unsupported public key type: %d\n", key->type);
        return PS_UNSUPPORTED_FAIL;
    }

/*
    Add to max size computation with the algorithmID size calculated above
 */
    len += pubKeyAlgIdLen;

    buf->buf = buf->start = buf->end = psMalloc(pool, len);
    if (buf->buf == NULL)
    {
        psFree(pubKeyAlgIdBuf.buf, pool);
        return PS_MEM_FAIL;
    }
    buf->size = len;

    buf->start = buf->end += ASN_SEQUENCE_OH;

    Memcpy(buf->end, pubKeyAlgIdBuf.start, pubKeyAlgIdLen);
    buf->end += pubKeyAlgIdLen;
    psFree(pubKeyAlgIdBuf.buf, pool);

    switch(key->type)
    {
    case PS_RSA:
# ifdef USE_RSA      
        *buf->end = ASN_BIT_STRING; buf->end++;
        /* The bit string size will be the key lengths (which include the INT
            tag and length bytes) + ignore byte (1) + SEQUENCE byte (1)
            and asnBytesToHold the above sum. */
        len = keyBinSize + 1 + 1 + asnBytesToHold(keyBinSize);
        buf->end += asnHelpWriteLength(buf->end, len);
        *buf->end = 0; buf->end++; /* ignore_bits */
        /* Length for ASN_SEQUENCE is same as above minus the ignore byte,
           the ASN_SEQUENCE tag (2) and the number of bytes it took to store the
           previous length */
        asnWriteSequence(buf, len - 2 - asnBytesToHold(len));

        /* Write the key out */
        asnWriteBig(pool, buf, &rsaKey->N);
        asnWriteBig(pool, buf, &rsaKey->e);
        break;
#endif        
# ifdef USE_ECC
    case PS_ECC:
        *buf->end = ASN_BIT_STRING; buf->end++;
        /* The bit string size will be the key lengths plus ignore byte (1)
            plus '0x4' uncompressed formate byte */
        len = keyBinSize + 1 + 1;
        buf->end += asnHelpWriteLength(buf->end, len);
        *buf->end = 0; buf->end++;   /* ignore_bits */

        *buf->end = 0x4; buf->end++; /* uncompressed pub key */

        /* Write the key out */
        uint16_t pstmLenX = pstm_unsigned_bin_size(&eccKey->pubkey.x);
        uint16_t pstmLenY = pstm_unsigned_bin_size(&eccKey->pubkey.y);
        uint16_t szOut;

        /*
          pstm_to_unsigned_bin strips the leading zero bytes from
          the EC point coordinates. However, according to SEC1,
          the (uncompressed) EC point coordinates must be encoded
          with a constant number of octets:
          ceil((log2(q)/8)) octets each, where q is the size of the
          field, e.g. q = 2^256 for P-256.
          Re-add the leading zero bytes here.
        */
        szOut = pstmLenX;
        while (szOut < eccKey->curve->size)
        {
            *buf->end = 0;
            buf->end++;
            szOut++;
        }
        if (pstm_to_unsigned_bin(pool, &eccKey->pubkey.x, buf->end) < 0)
        {
            return PS_FAIL;
        }
        buf->end += pstmLenX;

        szOut = pstmLenY;
        while (szOut < eccKey->curve->size)
        {
            *buf->end = 0;
            buf->end++;
            szOut++;
        }
        if (pstm_to_unsigned_bin(pool, &eccKey->pubkey.y, buf->end) < 0)
        {
            return PS_FAIL;
        }
        buf->end += pstmLenY;
        break;
# endif /* USE_ECC */
    default:
        psTraceIntCrypto("Unsupported public key type: %d\n", key->type);
        return PS_UNSUPPORTED_FAIL;
    }

    asnPrependSequence(buf);
    *pubKeyLen = (int32) (buf->end - buf->start);

    return PS_SUCCESS;
}

static int32 psWriteAuthorityKeyId(psPool_t *pool, psBuf_t *kuBuf,
    x509v3extensions_t *ext, int32 *kuExtLen)
{
    psBuf_t *tmpBuf;
    int32 kuLen, oidLen;


    kuLen = (ASN_SEQUENCE_OH * 2) + ext->ak.keyLen + 1;

    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }

    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, kuLen);
    if (tmpBuf->start == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = kuLen;

    tmpBuf->start = tmpBuf->end += ASN_SEQUENCE_OH;

    *tmpBuf->end = ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE; tmpBuf->end++;
    tmpBuf->end += asnHelpWriteLength(tmpBuf->end, ext->ak.keyLen);
    Memcpy(tmpBuf->end, ext->ak.keyId, ext->ak.keyLen);
    tmpBuf->end += ext->ak.keyLen;

    asnPrependSequence(tmpBuf);

    kuLen = (int32) (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(akExtOID) / sizeof(int32);

    psWriteCertExtWrapper(pool, kuBuf, kuExtLen, tmpBuf->start, kuLen,
        akExtOID, oidLen, 0);

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *kuExtLen;
}


static int32 psWriteSubjectKeyId(psPool_t *pool, psBuf_t *kuBuf,
    x509v3extensions_t *ext, int32 *kuExtLen)
{
    psBuf_t *tmpBuf;
    int32 kuLen, oidLen;

    kuLen = ASN_OCTET_STRING_OH + ext->sk.len;

    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, kuLen);
    if (tmpBuf->start == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = kuLen;

    *tmpBuf->end = ASN_OCTET_STRING; tmpBuf->end++;
    tmpBuf->end += asnHelpWriteLength(tmpBuf->end, ext->sk.len);
    Memcpy(tmpBuf->end, ext->sk.id, ext->sk.len);
    tmpBuf->end += ext->sk.len;

    kuLen = (int32) (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(skExtOID) / sizeof(int32);

    psWriteCertExtWrapper(pool, kuBuf, kuExtLen, tmpBuf->start, kuLen,
        skExtOID, oidLen, 0);

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *kuExtLen;
}

/*
   id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }

   AuthorityInfoAccessSyntax  ::=
   SEQUENCE SIZE (1..MAX) OF AccessDescription

   AccessDescription  ::=  SEQUENCE {
   accessMethod          OBJECT IDENTIFIER,
   accessLocation        GeneralName  }

   id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }

   id-ad-caIssuers OBJECT IDENTIFIER ::= { id-ad 2 }

   id-ad-ocsp OBJECT IDENTIFIER ::= { id-ad 1 }
   return PS_SUCCESS;
 */
int32 psWriteAuthorityInfoAccessExt(psPool_t *pool, psBuf_t *buf,
    x509authorityInfoAccess_t *authInfo,
    int32 *extLen)
{
    psBuf_t *tmpBuf;
    int32 authInfoLen, adLen, accLocationLen, written, rc;
    int32 oidLen;
    x509authorityInfoAccess_t *pAuthInfo, *pAuthInfoHead;
    int num_ads = 0;
    int is_ocsp = 0;

    /* Estimate upper bound of length. */
    pAuthInfo = pAuthInfoHead = authInfo;
    authInfoLen = ASN_SEQUENCE_OH * 5;

    while (pAuthInfo)
    {
        ++num_ads;
        authInfoLen += ASN_SEQUENCE_OH;
        authInfoLen += ASN_OID_OH;
        authInfoLen += ASN_STRING_OH;
        authInfoLen += MAX_OID_LEN; /* AccessMethod OID length. */
        if (pAuthInfo->ocspLen != 0)
        {
            authInfoLen += pAuthInfo->ocspLen;
        }
        else if (pAuthInfo->caIssuersLen != 0)
        {
            authInfoLen += pAuthInfo->caIssuersLen;
        }
        else
        {
            psTraceCrypto("Invalid authInfoAcc config\n");
            return PS_PARSE_FAIL;
        }
        pAuthInfo = pAuthInfo->next;
    }

    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, authInfoLen);
    if (tmpBuf->start == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = authInfoLen;

    /* Make room for SEQ + len. */
    tmpBuf->start += ASN_SEQUENCE_OH;
    tmpBuf->end += ASN_SEQUENCE_OH;

    /* Start encoding. */
    pAuthInfo = pAuthInfoHead;
    while (pAuthInfo)
    {
        if (pAuthInfo->ocspLen != 0)
        {
            accLocationLen = pAuthInfo->ocspLen;
            is_ocsp = 1;
        }
        else if (pAuthInfo->caIssuersLen != 0)
        {
            accLocationLen = pAuthInfo->caIssuersLen;
            is_ocsp = 0;
        }
        else
        {
            psTraceCrypto("Invalid authInfoAcc config\n");
            rc = PS_PARSE_FAIL;
            goto exit;
        }
        /* AccessDescription. */
        adLen = 8   /* accessMethod OID */
                + 1 /* accessMethod OID tag */
                + 1 /* accessMethod OID len */
                + 1 /* accessLocation tag */
                + 1 /* accessLocation len */
                + accLocationLen;
        /* SEQ. */
        if (asnWriteSequence(tmpBuf, adLen) < 0)
        {
            psTraceCrypto("asnWriteSequence failed\n");
            rc = PS_FAILURE;
            goto exit;
        }
        /* accessMethod (OID). */
        if (is_ocsp)
        {
            rc = asnWriteOid(tmpBuf, id_ad_ocspOID,
                sizeof(id_ad_ocspOID) / sizeof(int32));
        }
        else
        {
            rc = asnWriteOid(tmpBuf, id_ad_caIssuersOID,
                sizeof(id_ad_caIssuersOID) / sizeof(int32));
        }
        if (rc < 0)
        {
            psTraceCrypto("asnWriteOid failed\n");
            rc = PS_PARSE_FAIL;
            goto exit;
        }
        /* accessLocation (GeneralName). */
        /* Only uniformResourceIdentifiers ([6]) are supported. */
        *(tmpBuf->end) = (ASN_CONTEXT_SPECIFIC + 6);
        tmpBuf->end++;
        written = asnHelpWriteLength(tmpBuf->end,
            accLocationLen);
        if (written < 1)
        {
            psTraceCrypto("asnHelpWriteLength failed\n");
            rc = PS_PARSE_FAIL;
            goto exit;
        }
        tmpBuf->end += written;
        if (is_ocsp)
        {
            Memcpy(tmpBuf->end, pAuthInfo->ocsp, accLocationLen);
        }
        else
        {
            Memcpy(tmpBuf->end, pAuthInfo->caIssuers, accLocationLen);
        }

        tmpBuf->end += accLocationLen;

        /* Next AccessDescription, if any. */
        pAuthInfo = pAuthInfo->next;
    }

    /* Prepend SEQ tag and length. */
    if (asnPrependSequence(tmpBuf) < 0)
    {
        psTraceCrypto("asnPrependSequence failed\n");
        rc = PS_PARSE_FAIL;
        goto exit;
    }

    authInfoLen = (int32) (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(authorityInfoAccessExtOID) / sizeof(int32);

    psWriteCertExtWrapper(pool, buf, extLen, tmpBuf->start, authInfoLen,
        authorityInfoAccessExtOID, oidLen, 0);

    rc = PS_SUCCESS;
exit:
    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return rc;
}

/*
   NoticeReference ::= SEQUENCE {
   organization     DisplayText,
   noticeNumbers    SEQUENCE OF INTEGER }
 */
static
int32 psWriteNoticeReference(psPool_t *pool, psBuf_t **noticeReferenceBuf,
    x509PolicyQualifierInfo_t *qualInfo,
    int32 *noticeReferenceLen)
{
    int32 polsLen, rc, written, unoticeNumbersLen;
    int i;

    if ((*noticeReferenceBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    polsLen = 2048;
    (*noticeReferenceBuf)->start = (*noticeReferenceBuf)->end =
                                       (*noticeReferenceBuf)->buf = psMalloc(pool, polsLen);
    if ((*noticeReferenceBuf)->start == NULL)
    {
        rc = PS_MEM_FAIL;
        goto fail;
    }
    (*noticeReferenceBuf)->size = polsLen;

    /* Make room for SEQ + len. */
    (*noticeReferenceBuf)->start += ASN_SEQUENCE_OH;
    (*noticeReferenceBuf)->end += ASN_SEQUENCE_OH;

    /* Write NoticeReference. */

    /* Write unoticeOrganization (DisplayText). */
    *((*noticeReferenceBuf)->end) = ASN_UTF8STRING;
    (*noticeReferenceBuf)->end++;
    written = asnHelpWriteLength((*noticeReferenceBuf)->end,
        qualInfo->unoticeOrganizationLen);
    if (written < 1)
    {
        psTraceCrypto("asnHelpWriteLength failed\n");
        rc = PS_FAILURE;
        goto fail;
    }
    (*noticeReferenceBuf)->end += written;
    Memcpy((*noticeReferenceBuf)->end, qualInfo->unoticeOrganization,
        qualInfo->unoticeOrganizationLen);
    (*noticeReferenceBuf)->end += qualInfo->unoticeOrganizationLen;

    /* Write unoticeNumbers (SEQUENCE OF INTEGER). */

    /* Restriction: only single-octet integers supported.
       For this reason, we know the length in advance.
       INT (1) + length (1) + value (1) = 3 per number. */
    unoticeNumbersLen = 3 * qualInfo->unoticeNumbersLen;

    rc = asnWriteSequence(*noticeReferenceBuf,
        unoticeNumbersLen);
    if (rc < 0)
    {
        psTraceCrypto("asnWriteSequence failed\n");
        rc = PS_FAILURE;
        goto fail;
    }
    for (i = 0; i < qualInfo->unoticeNumbersLen; i++)
    {
        rc = asnWriteInteger(*noticeReferenceBuf,
            qualInfo->unoticeNumbers[i]);
        if (rc < 0)
        {
            psTraceCrypto("asnWriteInteger failed\n");
            rc = PS_FAILURE;
            goto fail;
        }
    }

    /* Prepend SEQ tag and length to NoticeReference. */
    if (asnPrependSequence(*noticeReferenceBuf) < 0)
    {
        psTraceCrypto("asnPrependSequence failed\n");
        rc = PS_PARSE_FAIL;
        goto fail;
    }

    *noticeReferenceLen =
        (int32) ((*noticeReferenceBuf)->end - (*noticeReferenceBuf)->start);

    return PS_SUCCESS;

fail:
    if (*noticeReferenceBuf != NULL)
    {
        if ((*noticeReferenceBuf)->buf != NULL)
            psFree((*noticeReferenceBuf)->buf, pool);
        psFree(*noticeReferenceBuf, pool);
        *noticeReferenceBuf = NULL;
    }

    return rc;
}

/*
   UserNotice ::= SEQUENCE {
     noticeRef        NoticeReference OPTIONAL,
     explicitText     DisplayText OPTIONAL }
 */
static
int32 psWriteUserNotice(psPool_t *pool, psBuf_t **userNoticeBuf,
    x509PolicyQualifierInfo_t *qualInfo,
    int32 *userNoticeLen)
{
    int32 polsLen, rc, written, rv;
    psBuf_t *noticeReferenceBuf;
    int32 noticeReferenceLen;

    if ((*userNoticeBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    polsLen = 2048;
    (*userNoticeBuf)->start = (*userNoticeBuf)->end =
                                  (*userNoticeBuf)->buf = psMalloc(pool, polsLen);
    if ((*userNoticeBuf)->start == NULL)
    {
        rv = PS_MEM_FAIL;
        goto fail;
    }
    (*userNoticeBuf)->size = polsLen;

    /* Make room for SEQ + len. */
    (*userNoticeBuf)->start += ASN_SEQUENCE_OH;
    (*userNoticeBuf)->end += ASN_SEQUENCE_OH;

    if (qualInfo->unoticeOrganizationLen > 0)
    {
        /* Write NoticeReference (SEQ). */
        rc = psWriteNoticeReference(pool,
            &noticeReferenceBuf,
            qualInfo,
            &noticeReferenceLen);
        if (rc < 0)
        {
            psTraceCrypto("psWriteNoticeReference failed\n");
            rv = PS_FAILURE;
            goto fail;
        }
        Memcpy((*userNoticeBuf)->end, noticeReferenceBuf->start,
            noticeReferenceLen);
        (*userNoticeBuf)->end += noticeReferenceLen;
        psFree(noticeReferenceBuf->buf, pool);
        psFree(noticeReferenceBuf, pool);
    }

    if (qualInfo->unoticeExplicitTextLen > 0)
    {
        /* Write explicitText (DisplayText). */
        /* RFC 5280: "Conforming CAs SHOULD use the UTF8String encoding
           for explicitText" */
        *((*userNoticeBuf)->end) = ASN_UTF8STRING;
        (*userNoticeBuf)->end++;
        written = asnHelpWriteLength((*userNoticeBuf)->end,
            qualInfo->unoticeExplicitTextLen);
        if (written < 1)
        {
            psTraceCrypto("asnHelpWriteLength failed\n");
            rv = PS_FAILURE;
            goto fail;
        }
        (*userNoticeBuf)->end += written;
        Memcpy((*userNoticeBuf)->end, qualInfo->unoticeExplicitText,
            qualInfo->unoticeExplicitTextLen);
        (*userNoticeBuf)->end += qualInfo->unoticeExplicitTextLen;
    }

    /* Prepend SEQ tag and length to UserNotice. */
    if (asnPrependSequence(*userNoticeBuf) < 0)
    {
        psTraceCrypto("asnPrependSequence failed\n");
        rv = PS_PARSE_FAIL;
    }

    *userNoticeLen = (int32) ((*userNoticeBuf)->end - (*userNoticeBuf)->start);

    return PS_SUCCESS;

fail:
    if (*userNoticeBuf != NULL)
    {
        if ((*userNoticeBuf)->buf != NULL)
            psFree((*userNoticeBuf)->buf, pool);
        psFree(*userNoticeBuf, pool);
        *userNoticeBuf = NULL;
    }

    return rv;
}

/*
   PolicyQualifierInfo ::= SEQUENCE {
     policyQualifierId  PolicyQualifierId,
     qualifier          ANY DEFINED BY policyQualifierId }
 */
static
int32 psWritePolicyQualifierInfo(psPool_t *pool, psBuf_t **qualInfoBuf,
    x509PolicyQualifierInfo_t *qualInfo,
    int32 *qualInfoLen)
{
    int32 polsLen, rc, written;
    psBuf_t *userNoticeBuf;
    int32 userNoticeLen;

    if ((*qualInfoBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    polsLen = 2048;
    (*qualInfoBuf)->start = (*qualInfoBuf)->end =
                                (*qualInfoBuf)->buf = psMalloc(pool, polsLen);
    if ((*qualInfoBuf)->start == NULL)
    {
        psFree(*qualInfoBuf, pool);
        return PS_MEM_FAIL;
    }
    (*qualInfoBuf)->size = polsLen;

    /* Make room for SEQ + len. */
    (*qualInfoBuf)->start += ASN_SEQUENCE_OH;
    (*qualInfoBuf)->end += ASN_SEQUENCE_OH;

    /* Write policyQualifierId (OID). Either CPS or unotice. */
    if (qualInfo->cpsLen > 0)
    {
        rc = asnWriteOid(*qualInfoBuf, id_qt_cpsOID,
            sizeof(id_qt_cpsOID) / sizeof(int32));
    }
    else
    {
        rc = asnWriteOid(*qualInfoBuf, id_qt_unoticeOID,
            sizeof(id_qt_unoticeOID) / sizeof(int32));
    }
    if (rc < 0)
    {
        psTraceCrypto("asnWriteOid failed\n");
        psFree((*qualInfoBuf)->buf, pool);
        psFree(*qualInfoBuf, pool);
        return PS_FAILURE;
    }

    if (qualInfo->cpsLen > 0)
    {
        /* Write CPS. */
        *((*qualInfoBuf)->end) = ASN_IA5STRING;
        (*qualInfoBuf)->end++;
        written = asnHelpWriteLength((*qualInfoBuf)->end,
            qualInfo->cpsLen);
        if (written < 1)
        {
            psTraceCrypto("asnHelpWriteLength failed\n");
            return PS_PARSE_FAIL;
        }
        (*qualInfoBuf)->end += written;
        Memcpy((*qualInfoBuf)->end, qualInfo->cps, qualInfo->cpsLen);
        (*qualInfoBuf)->end += qualInfo->cpsLen;
    }
    else
    {
        /* Write UserNotice. */
        rc = psWriteUserNotice(pool, &userNoticeBuf,
            qualInfo, &userNoticeLen);
        if (rc < 0)
        {
            psTraceCrypto("psWriteUserNotice failed\n");
            return PS_FAILURE;
        }
        /* UserNotice. */
        Memcpy((*qualInfoBuf)->end, userNoticeBuf->start, userNoticeLen);
        (*qualInfoBuf)->end += userNoticeLen;
        psFree(userNoticeBuf->buf, pool);
        psFree(userNoticeBuf, pool);
    }

    /* Prepend SEQ tag and length. */
    if (asnPrependSequence(*qualInfoBuf) < 0)
    {
        psTraceCrypto("asnPrependSequence failed\n");
        return PS_PARSE_FAIL;
    }

    *qualInfoLen = (int32) ((*qualInfoBuf)->end - (*qualInfoBuf)->start);

    return PS_SUCCESS;
}

/*
   PolicyInformation ::= SEQUENCE {
     policyIdentifier   CertPolicyId,
     policyQualifiers   SEQUENCE SIZE (1..MAX) OF
             PolicyQualifierInfo OPTIONAL }
 */
static
int32 psWritePolicyInformation(psPool_t *pool, psBuf_t **polInfoBuf,
    x509PolicyInformation_t *polInfo,
    int32 *polInfoLen)
{
    psBuf_t *qualInfoBuf = NULL, *qualInfos = NULL;
    int32 rc;
    int32 rv;
    int32 qualInfoLen, qualInfosLen, polsLen;
    x509PolicyQualifierInfo_t *qualInfo;

    if (((*polInfoBuf) = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    polsLen = 2048;
    (*polInfoBuf)->start = (*polInfoBuf)->end
                               = (*polInfoBuf)->buf = psMalloc(pool, polsLen);
    if ((*polInfoBuf)->start == NULL)
    {
        rv = PS_MEM_FAIL;
        goto fail;
    }
    (*polInfoBuf)->size = polsLen;

    /* Make room for SEQ + len. */
    (*polInfoBuf)->start += ASN_SEQUENCE_OH;
    (*polInfoBuf)->end += ASN_SEQUENCE_OH;

    /* Write CertPolicyId (OID).
       DER-encoded in psCreateCertPolicyStructs. */
    (*polInfoBuf)->end += psAsnWriteOid(*polInfo->policyAsnOid,
                                        (*polInfoBuf)->end,
                                        polsLen - ASN_SEQUENCE_OH * 2);

    /*
       policyQualifiers   SEQUENCE SIZE (1..MAX) OF
       PolicyQualifierInfo OPTIONAL
     */
    if (polInfo->qualifiers)
    {
        if ((qualInfos = psMalloc(pool, sizeof(psBuf_t))) == NULL)
        {
            rv = PS_MEM_FAIL;
            goto fail;
        }
        polsLen = 2048;
        qualInfos->start = qualInfos->end =
                               qualInfos->buf = psMalloc(pool, polsLen);
        if (qualInfos->start == NULL)
        {
            rv = PS_MEM_FAIL;
            goto fail;
        }
        qualInfos->size = polsLen;

        /* Write all PolicyQualifierInfos to qualInfos. */
        qualInfo = polInfo->qualifiers;
        while (qualInfo)
        {
            rc = psWritePolicyQualifierInfo(pool, &qualInfoBuf,
                qualInfo, &qualInfoLen);
            if (rc < 0)
            {
                psTraceCrypto("psWritePolicyQualifierInfo failed\n");
                rv = PS_FAILURE;
                goto fail;
            }
            /* PolicyQualifierInfo. */
            Memcpy(qualInfos->end, qualInfoBuf->start, qualInfoLen);
            qualInfos->end += qualInfoLen;
            psFree(qualInfoBuf->buf, pool);
            psFree(qualInfoBuf, pool);
            qualInfo = qualInfo->next;
        }
        /* Now have all the qualifiers in qualInfos. */

        qualInfosLen = (int32) (qualInfos->end - qualInfos->start);

        /* Prepend SEQ tag and length to to policyQualifiers. */
        if (asnWriteSequence(*polInfoBuf, qualInfosLen) < 0)
        {
            psTraceCrypto("asnWriteSequence failed\n");
            rv = PS_FAILURE;
            goto fail;
        }
        Memcpy((*polInfoBuf)->end, qualInfos->start, qualInfosLen);
        (*polInfoBuf)->end += qualInfosLen;
        psFree(qualInfos->buf, pool);
        psFree(qualInfos, pool);
    } /* End of policyQualifiers encoding. */

    /* Prepend SEQ tag and length to CertificatePolicies. */
    if (asnPrependSequence(*polInfoBuf) < 0)
    {
        psTraceCrypto("asnPrependSequence failed\n");
        rv = PS_PARSE_FAIL;
        goto fail;
    }

    *polInfoLen = (int32) ((*polInfoBuf)->end - (*polInfoBuf)->start);

    return PS_SUCCESS;

fail:

    if (*polInfoBuf != NULL)
    {
        if ((*polInfoBuf)->buf != NULL)
            psFree((*polInfoBuf)->buf, pool);
        psFree(*polInfoBuf, pool);
        *polInfoBuf = NULL;
    }

    if (qualInfos != NULL)
    {
        if (qualInfos->buf != NULL)
            psFree(qualInfos->buf, pool);
        psFree(qualInfos, pool);
    }

    return rv;
}

/* Create certificatePolicies extension structures from data in the
   global policies array. */
static
int32 psCreateCertPolicyStructs(psPool_t *pool, x509certificatePolicies_t *ext,
    psCertConfig_t *certConfig)
{
    int i, j, k;
    int num_qualifier_infos, qual_i;
    x509PolicyInformation_t *polInfo;
    x509PolicyQualifierInfo_t *qualInfo;
    size_t cps_len, org_len, expt_len, noticenum_len;
    unsigned char oid[MAX_OID_LEN] = { 0 };
    size_t oid_len;
    int32 written;
    policy_parse_helper_t *h;

    if (ext == NULL || certConfig == NULL || certConfig->polh == 0 ||
        certConfig->polh->num_policies < 1)
    {
        psTraceCrypto("psCreateCertPolicyStructs failed: invalid arguments\n");
        return PS_FAILURE;
    }

    h = certConfig->polh;

    /* Malloc policyinformation list head. */
    if (ext->policy == NULL)
    {
        ext->policy = psMalloc(pool, sizeof(x509PolicyInformation_t));
        Memset(ext->policy, 0, sizeof(x509PolicyInformation_t));
    }
    polInfo = ext->policy;

    /* Malloc and fill x509PolicyInformation_t linked list. */
    for (i = 1; i <= h->num_policies; i++)
    {
        if (i != 1)
        {
            while (polInfo->next)
            {
                polInfo = polInfo->next;
            }
            /* Found list tail. Now add a new entry. */
            psAssert(polInfo->next == NULL);
            polInfo->next = psMalloc(pool, sizeof(*polInfo->next));
            if (polInfo->next == NULL)
            {
                return PS_MEM_FAIL;
            }
            Memset(polInfo->next, 0, sizeof(*polInfo->next));
            polInfo = polInfo->next;
        }
        /* Handle policy OID. */
        Memset(oid, 0, MAX_OID_LEN);
        oid_len = h->policies[i].oid_len / 2; /* Two hex digits per byte. */
        if (psHexToBinary((unsigned char *) h->policies[i].oid,
                oid, oid_len) < 0)
        {
            psTraceCrypto("psHexToBinary failed\n");
            return PS_FAILURE;
        }
        polInfo->policyAsnOid = psMalloc(pool, sizeof(psAsnOid_t));
        if (polInfo->policyAsnOid == NULL)
        {
            return PS_MEM_FAIL;
        }
        written = asnWriteOidChars((unsigned char *) polInfo->policyAsnOid,
            oid, oid_len);
        if (written <= 0)
        {
            psTraceCrypto("asnWriteOidChars failed\n");
            return PS_FAILURE;
        }

        /* Handle qualifiers. */
        num_qualifier_infos = h->policies[i].num_cps + h->policies[i].num_userNotice;
        if (num_qualifier_infos == 0)
        {
            continue;
        }
        qual_i = 0;

        /* Malloc qualifier list head. */
        polInfo->qualifiers = psMalloc(pool, sizeof(x509PolicyQualifierInfo_t));
        if (polInfo->qualifiers == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memset(polInfo->qualifiers, 0, sizeof(x509PolicyQualifierInfo_t));
        qualInfo = polInfo->qualifiers;

        /* Add CPSs. */
        for (j = 0; j < h->policies[i].num_cps; j++)
        {
            if (j != 0)
            {
                while (qualInfo->next)
                {
                    qualInfo = qualInfo->next;
                }
                /* Found list tail. Now add a new entry. */
                psAssert(qualInfo->next == NULL);
                qualInfo->next = psMalloc(pool, sizeof(x509PolicyQualifierInfo_t));
                if (qualInfo->next == NULL)
                {
                    return PS_MEM_FAIL;
                }
                Memset(qualInfo->next, 0, sizeof(x509PolicyQualifierInfo_t));
                qualInfo = qualInfo->next;
                ++qual_i;
            }

            cps_len = Strlen(h->policies[i].cps[j]);
            if (cps_len > 0)
            {
                qualInfo->cps = psMalloc(pool, cps_len + 1);
                qualInfo->cpsLen = cps_len;
                Memcpy(qualInfo->cps, h->policies[i].cps[j], cps_len);
            }
        }

        qualInfo = polInfo->qualifiers;

        /* Add userNotices. */
        for (j = 0; j < h->policies[i].num_userNotice; j++)
        {
            while (qualInfo->next)
            {
                qualInfo = qualInfo->next;
            }
            /* Found list tail. Now add a new entry. */
            psAssert(qualInfo->next == NULL);
            qualInfo->next = psMalloc(pool, sizeof(x509PolicyQualifierInfo_t));
            if (qualInfo->next == NULL)
            {
                return PS_MEM_FAIL;
            }
            Memset(qualInfo->next, 0, sizeof(x509PolicyQualifierInfo_t));
            qualInfo = qualInfo->next;

            org_len = Strlen(h->policies[i].organization[j]);
            if (org_len > 0)
            {
                qualInfo->unoticeOrganization = psMalloc(pool, org_len + 1);
                if (qualInfo->unoticeOrganization == NULL)
                {
                    return PS_MEM_FAIL;
                }
                Memset(qualInfo->unoticeOrganization, 0, org_len);
                qualInfo->unoticeOrganizationLen = org_len;
                Memcpy(qualInfo->unoticeOrganization, h->policies[i].organization[j], org_len);
            }
            expt_len = Strlen(h->policies[i].explicitText[j]);
            if (expt_len > 0)
            {
                qualInfo->unoticeExplicitText = psMalloc(pool, expt_len + 1);
                if (qualInfo->unoticeExplicitText == NULL)
                {
                    return PS_MEM_FAIL;
                }
                Memset(qualInfo->unoticeExplicitText, 0, expt_len);
                qualInfo->unoticeExplicitTextLen = expt_len;
                Memcpy(qualInfo->unoticeExplicitText, h->policies[i].explicitText[j], expt_len);
            }
            noticenum_len = h->policies[i].num_noticeNumbers[j];
            if (noticenum_len > 0)
            {
                for (k = 0; k <= noticenum_len; k++)
                {
                    qualInfo->unoticeNumbers[k] = h->policies[i].noticeNumbers[j][k];
                }
                qualInfo->unoticeNumbersLen = noticenum_len;
            }
            qual_i++;
        }
    }

    return PS_SUCCESS;
}

/*
   CertificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation
 */
static
int32 psWriteCertPoliciesExt(psPool_t *pool, psBuf_t *buf,
    x509certificatePolicies_t *ext, int32 *extLen,
    psCertConfig_t *config)
{
    psBuf_t *tmpBuf, *polInfoBuf = NULL;
    int32 polsLen, oidLen, rc, rv = PS_SUCCESS;
    int32 polInfoLen;
    x509PolicyInformation_t *polInfo;

    psCreateCertPolicyStructs(pool, ext, config);

    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    polsLen = 2048;
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, polsLen);
    if (tmpBuf->start == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = polsLen;

    /* Make room for SEQ + len. */
    tmpBuf->start += ASN_SEQUENCE_OH;
    tmpBuf->end += ASN_SEQUENCE_OH;

    /* Loop over the list of PolicyInformations. */
    polInfo = ext->policy;
    while (polInfo)
    {
        /* psWritePolicyInformation will malloc polInfoBuf. */
        rc = psWritePolicyInformation(pool, &polInfoBuf,
            polInfo, &polInfoLen);
        if (rc < 0)
        {
            psTraceCrypto("psWritePolicyInformation failed\n");
            rv = PS_FAILURE;
            goto fail;
        }
        /* Add policyInformation. */
        Memcpy(tmpBuf->end, polInfoBuf->start, polInfoLen);
        tmpBuf->end += polInfoLen;
        psFree(polInfoBuf->buf, pool);
        psFree(polInfoBuf, pool);
        polInfoBuf = NULL;

        /* Next PolicyInformation, if any. */
        polInfo = polInfo->next;
    }

    /* Prepend SEQ tag and length to CertificatePolicies. */
    if (asnPrependSequence(tmpBuf) < 0)
    {
        psTraceCrypto("asnPrependSequence failed\n");
        rv = PS_PARSE_FAIL;
        goto fail;
    }

    polsLen = (int32) (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(certificatePoliciesExtOID) / sizeof(int32);

    psWriteCertExtWrapper(pool, buf, extLen, tmpBuf->start, polsLen,
        certificatePoliciesExtOID, oidLen, 0);

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);
    return PS_SUCCESS;

fail:
    if (tmpBuf != NULL)
    {
        if (tmpBuf->buf != NULL)
            psFree(tmpBuf->buf, pool);
        psFree(tmpBuf, pool);
    }

    if (polInfoBuf != NULL)
    {
        if (polInfoBuf != NULL)
            psFree(polInfoBuf->buf, pool);
        psFree(polInfoBuf, pool);
    }

    return rv;
}

int32 psWriteCertPolicyConstraintsExt(psPool_t *pool, psBuf_t *buf,
    x509policyConstraints_t *polCon, int32 *extLen)
{
    psBuf_t *tmpBuf;
    int32 polConLen, oidLen;
    int32 num_constraints = 0;

    if (polCon->requireExplicitPolicy > 0)
    {
        num_constraints++;
    }
    if (polCon->inhibitPolicyMappings > 0)
    {
        num_constraints++;
    }

    polConLen = ASN_SEQUENCE_OH + 2 * num_constraints + num_constraints * ASN_LENGTH_OH;

    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, polConLen);
    if (tmpBuf->start == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = polConLen;

    /*
       id-ce-policyConstraints OBJECT IDENTIFIER ::=  { id-ce 36 }

       PolicyConstraints ::= SEQUENCE {
       requireExplicitPolicy           [0] SkipCerts OPTIONAL,
       inhibitPolicyMapping            [1] SkipCerts OPTIONAL }

       SkipCerts ::= INTEGER (0..MAX)
     */

    /* Leave room for SEQ tag and length. */
    tmpBuf->start += ASN_SEQUENCE_OH;
    tmpBuf->end += ASN_SEQUENCE_OH;

    /* Only support encoding of single-octet values for now.*/
    if (polCon->requireExplicitPolicy > 0)
    {
        *tmpBuf->end = (ASN_CONTEXT_SPECIFIC + 0);
        tmpBuf->end++;
        tmpBuf->end += asnHelpWriteLength(tmpBuf->end, 1);
        *tmpBuf->end = (unsigned char) polCon->requireExplicitPolicy;
        tmpBuf->end++;
    }
    if (polCon->inhibitPolicyMappings > 0)
    {
        *tmpBuf->end = (ASN_CONTEXT_SPECIFIC + 1);
        tmpBuf->end++;
        tmpBuf->end += asnHelpWriteLength(tmpBuf->end, 1);
        *tmpBuf->end = (unsigned char) polCon->inhibitPolicyMappings;
        tmpBuf->end++;
    }

    /* Prepend SEQ tag and length. */
    asnPrependSequence(tmpBuf);

    polConLen = (int32) (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(policyConstraintsExtOID) / sizeof(int32);

    /*
       RFC 5280: "Conforming CAs MUST mark this extension as critical",
       so set 'critical' (last argument) to 1.
     */
    psWriteCertExtWrapper(pool, buf, extLen, tmpBuf->start, polConLen,
        policyConstraintsExtOID, oidLen, 1);

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *extLen;
}

int32 psWriteCertPolicyMappingsExt(psPool_t *pool, psBuf_t *buf,
    x509policyMappings_t *polMap, int32 *extLen)
{
    psBuf_t *tmpBuf;
    int32 polMapLen = 0;
    int32 oneMapLen, oidLen;
    int32 num_mappings = 0;
    x509policyMappings_t *pol_map = polMap;

    /*
       id-ce-policyMappings OBJECT IDENTIFIER ::=  { id-ce 33 }

       PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {
       issuerDomainPolicy      CertPolicyId,
       subjectDomainPolicy     CertPolicyId }
     */

    /* Compute maximum total size of the PolicyMappings extensions.
       The real size will be computed while encoding. */
    polMapLen += ASN_SEQUENCE_OH;

    while (pol_map)
    {
        polMapLen += ASN_SEQUENCE_OH;
        polMapLen += 2 * (ASN_OID_OH + MAX_OID_LEN);
        pol_map = pol_map->next;
        ++num_mappings;
    }

    /* Alloc and setup psBuf. */
    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, polMapLen);
    if (tmpBuf->start == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = polMapLen;

    /* Leave room for SEQ tag and length. */
    tmpBuf->start += ASN_SEQUENCE_OH;
    tmpBuf->end += ASN_SEQUENCE_OH;

    /* Now start encoding. */
    pol_map = polMap;
    while (pol_map)
    {
        if (!pol_map->issuerDomainPolicy ||
            !pol_map->subjectDomainPolicy)
        {
            psTraceCrypto("Invalid policy mapping detected during encode.\n");
            psFree(tmpBuf->buf, pool);
            psFree(tmpBuf, pool);
            return PS_FAILURE;
        }

        /* Write SEQ. We know the length, since we already encoded the OIDs
           into DER during config file parsing. */
        oneMapLen = asnOidLenBytes(*pol_map->issuerDomainPolicy) + asnOidLenBytes(*pol_map->subjectDomainPolicy);
        if (asnWriteSequence(tmpBuf, oneMapLen) < 0)
        {
            psTraceCrypto("asnWriteSequence failed\n");
            psFree(tmpBuf->buf, pool);
            psFree(tmpBuf, pool);
            return PS_FAILURE;
        }

        tmpBuf->end += psAsnWriteOid(
                *pol_map->issuerDomainPolicy,
                tmpBuf->end,
                polMapLen - (tmpBuf->end - tmpBuf->start));
                                     
        tmpBuf->end += psAsnWriteOid(
                *pol_map->subjectDomainPolicy,
                tmpBuf->end,
                polMapLen - (tmpBuf->end - tmpBuf->start));

        /* Next mapping. */
        pol_map = pol_map->next;
    }

    tmpBuf->size = polMapLen + ASN_SEQUENCE_OH;

    /* Prepend SEQ tag and length. */
    if (asnPrependSequence(tmpBuf) < 0)
    {
        psTraceCrypto("asnPrependSequence failed\n");
        psFree(tmpBuf->buf, pool);
        psFree(tmpBuf, pool);
        return PS_FAILURE;
    }

    /* Now get final encoded length. */
    polMapLen = (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(policyMappingsExtOID) / sizeof(int32);

    psWriteCertExtWrapper(pool, buf, extLen, tmpBuf->start, polMapLen,
        policyMappingsExtOID, oidLen, 0);

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *extLen;
}

/*  Write subjectAltNames and issuerAltNames */
int32 psWriteCertSANExt(psPool_t *pool, psBuf_t *sanBuf,
    x509v3extensions_t *ext, int32 *extLen,
    int issuerAltName)
{
    psBuf_t *tmpBuf;
    int32 sanLen, sanDataLen, gnLen, ul;
    x509GeneralName_t *san;
    int32 extOID[3];

    if (issuerAltName)
    {
        Memcpy(extOID, issuerAltNameExtOID, sizeof(extOID));
    }
    else
    {
        Memcpy(extOID, sanExtOID, sizeof(extOID));
    }

    sanLen = gnLen = 0;
    /* Sequence */
    /* OID for 2A 86 48 86 F7 0D 01 09 0E */
    /* SET */
    /* extensions */
    /*  */


    /* SAN */
    /* Seq */
    /*   Seq */
    /*          OID */
    /*                  Octet String */
    /*                          Seq */
    /*                                  ID */
    /*                                  Value */
    if (issuerAltName)
    {
        san = ext->issuerAltName;
    }
    else
    {
        san = ext->san;
    }

    if (san == NULL)
    {
        return PS_UNSUPPORTED_FAIL;
    }

    while (san)
    {
        if (san->oidLen > 0)
        {
            /* otherName entry
                SEQUENCE
                    OID
                    value (0xA0, <len>, UTF8, <dataLen>, <data>)
             */
            sanDataLen = san->dataLen;
            sanDataLen += asn1TLOverhead(sanDataLen); /* UTF8 */
            sanDataLen += asn1TLOverhead(sanDataLen); /* 0xA0 */

            if (san->oidHasTagLenPrefix)
            {
                /* In this case, san->oid also contains the tag-length
                   part of the OID. */
                sanDataLen += san->oidLen;
            }
            else
            {
                sanDataLen += asn1TLOverhead(san->oidLen) + san->oidLen;
            }
        }
        else
        {
            sanDataLen = san->dataLen;
        }
        gnLen += asnBytesToHold(sanDataLen) + sanDataLen + 1; /* 1=id */
        san = san->next;
    }

    sanLen += gnLen + ASN_SEQUENCE_OH + 2;

    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, sanLen);
    tmpBuf->size = sanLen;

    if (tmpBuf->buf == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }

    asnWriteSequence(tmpBuf, gnLen);

    if (issuerAltName)
    {
        san = ext->issuerAltName;
    }
    else
    {
        san = ext->san;
    }

    while (san)
    {
        /* Write outer context-specific tag. */
        switch (san->id)
        {
        case GN_OTHER:
        case GN_EDI:
            *tmpBuf->end = (unsigned char) san->id | ASN_CONSTRUCTED |
                           ASN_CONTEXT_SPECIFIC;
            break;

        default:
            *tmpBuf->end = (unsigned char) san->id | ASN_CONTEXT_SPECIFIC;
            break;

        }
        tmpBuf->end++;
        if (san->oidLen)
        {
            /* Write length of the outer context-specific type. */
            sanDataLen = asn1TLOverhead(san->dataLen) + san->dataLen;
            ul = sanDataLen;
            sanDataLen += asn1TLOverhead(sanDataLen); /* 0xA0 */
            if (san->oidHasTagLenPrefix)
            {
                sanDataLen += san->oidLen;
            }
            else
            {
                sanDataLen += asn1TLOverhead(san->oidLen) + san->oidLen;
            }
            tmpBuf->end += asnHelpWriteLength(tmpBuf->end, sanDataLen);

            /* Write OID. */
            if (!san->oidHasTagLenPrefix)
            {
                *tmpBuf->end = ASN_OID; tmpBuf->end++;
                tmpBuf->end += asnHelpWriteLength(tmpBuf->end, san->oidLen);
            }
            Memcpy(tmpBuf->end, san->oid, san->oidLen);
            tmpBuf->end += san->oidLen;

            /* Write inner context-specific tag and length. */
            *tmpBuf->end = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED; /* 0xA0 */
            tmpBuf->end++;
            tmpBuf->end += asnHelpWriteLength(tmpBuf->end, ul);

            /* Only write the UTF8String tag when we have successfully
               parsed the otherName data into an OID and a string.
               This is so that we retain the possibility that the user
               can add any octets he wants. TODO: still a good idea? */
            *tmpBuf->end = ASN_UTF8STRING; tmpBuf->end++;
        }

        /* Write otherName value and length. */
        tmpBuf->end += asnHelpWriteLength(tmpBuf->end, san->dataLen);
        Memcpy(tmpBuf->end, san->data, san->dataLen);
        tmpBuf->end += san->dataLen;
        san = san->next;
    }

    sanLen = (int32) (tmpBuf->end - tmpBuf->start);

    if (psWriteCertExtWrapper(pool, sanBuf, extLen, tmpBuf->start, sanLen,
            extOID, 3, 0) < 0)
    {
        psFree(tmpBuf->buf, pool);
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *extLen;
}

/*  Write netscape-comment extension */
int32 psWriteNetscapeCommentExt(psPool_t *pool, psBuf_t *buf,
    x509netscapeComment_t *nsCmt,
    int32 *extLen)
{
    psBuf_t *tmpBuf;
    int32 nsCmtLen = 0;
    int32 written = 0;
    int32 oidLen = 0;

    /* The comment is simply an IA5String. */

    nsCmtLen = nsCmt->commentLen;
    nsCmtLen += 1; /* ASN_IA5STRING tag */
    nsCmtLen += 2; /* Up to 2 length octets. */

    /* Alloc and setup psBuf. */
    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, nsCmtLen);
    if (tmpBuf->start == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = nsCmtLen;

    *(tmpBuf->end) = ASN_IA5STRING;
    tmpBuf->end++;
    written = asnHelpWriteLength(tmpBuf->end,
        nsCmt->commentLen);
    if (written < 1)
    {
        psTraceCrypto("asnHelpWriteLength failed\n");
        return PS_PARSE_FAIL;
    }
    tmpBuf->end += written;
    Memcpy(tmpBuf->end, nsCmt->comment, nsCmt->commentLen);
    tmpBuf->end += nsCmt->commentLen;

    /* Now get final encoded length. */
    nsCmtLen = (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(netscapeCommentExtOID) / sizeof(int32);

    psWriteCertExtWrapper(pool, buf, extLen, tmpBuf->start, nsCmtLen,
        netscapeCommentExtOID, oidLen, 0);

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *extLen;
}

/* Write extensions to a certificate */
int32 psWriteCertExt(psPool_t *pool, psBuf_t *buf, x509v3extensions_t *ext,
    int32 *extLen, psCertConfig_t *certConfig)
{

    int32 bcLen, sanLen, issuerAltNameLen, polLen, polConLen, polMapLen,
          authInfoLen, nsCmtLen, kuLen, skLen, akLen, ekuLen, totLen;
    psBuf_t bcBuf, sanBuf, issuerAltNameBuf, polBuf, polConBuf, polMapBuf,
            authInfoBuf, nsCmtBuf, kuBuf, skBuf, akBuf, ekuBuf;

    sanLen = issuerAltNameLen = polLen = polConLen = polMapLen = 0;
    authInfoLen = kuLen = bcLen = nsCmtLen = skLen = akLen = ekuLen = 0;

    if (ext->bc.cA != CA_UNDEFINED)
    {
        if (psWriteCertBasicConstraints(pool, &bcBuf, ext->bc.cA,
                        ext->bc.pathLenConstraint, &bcLen) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    /* If encoding of any extension fails, return with an error code. */
    if (ext->sk.len > 0)
    {
        if (psWriteSubjectKeyId(pool, &skBuf, ext, &skLen) < 0)
        {
            goto fail;
        }
    }
    if (ext->ak.keyLen > 0)
    {
        if (psWriteAuthorityKeyId(pool, &akBuf, ext, &akLen) < 0)
        {
            goto fail;
        }
    }
    if (ext->san != NULL)
    {
        if (psWriteCertSANExt(pool, &sanBuf, ext, &sanLen, 0) < 0)
        {
            goto fail;
        }
    }
    if (ext->issuerAltName != NULL)
    {
        if (psWriteCertSANExt(pool, &issuerAltNameBuf,
                ext, &issuerAltNameLen, 1) < 0)
        {
            goto fail;
        }
    }
    if (ext->authorityInfoAccess != NULL)
    {
        if (psWriteAuthorityInfoAccessExt(pool, &authInfoBuf,
                ext->authorityInfoAccess,
                &authInfoLen) < 0)
        {
            goto fail;
        }
    }
    if (ext->certificatePolicy.policy != NULL)
    {
        if (psWriteCertPoliciesExt(pool, &polBuf,
                &ext->certificatePolicy, &polLen,
                certConfig) < 0)
        {
            goto fail;
        }
    }
    if (ext->policyConstraints.requireExplicitPolicy > 0 ||
        ext->policyConstraints.inhibitPolicyMappings > 0)
    {
        if (psWriteCertPolicyConstraintsExt(pool, &polConBuf,
                &ext->policyConstraints,
                &polConLen) < 0)
        {
            goto fail;
        }
    }
    if (ext->policyMappings != NULL)
    {
        if (psWriteCertPolicyMappingsExt(pool, &polMapBuf,
                ext->policyMappings,
                &polMapLen) < 0)
        {
            goto fail;
        }
    }
    if (ext->netscapeComment != NULL)
    {
        if (psWriteNetscapeCommentExt(pool, &nsCmtBuf,
                ext->netscapeComment,
                &nsCmtLen) < 0)
        {
            goto fail;
        }
    }
    if (ext->keyUsageFlags != 0)
    {
        if (psWriteCertKeyUsage(pool, &kuBuf, ext, &kuLen) < 0)
        {
            goto fail;
        }
    }

    if (ext->ekuFlags != 0)
    {
        if (psWriteCertExtKeyUsage(pool, &ekuBuf, ext, &ekuLen) < 0)
        {
            goto fail;
        }
    }

    totLen = sanLen + issuerAltNameLen + polConLen + polMapLen;
    totLen += authInfoLen + polLen + nsCmtLen;
    totLen += kuLen + skLen + bcLen + akLen + ekuLen + ASN_SEQUENCE_OH;

    buf->buf = buf->start = buf->end = psMalloc(pool, totLen);
    buf->size = totLen;
    if (buf->buf == NULL)
    {
        goto fail;
    }

    /* basicConstraints */
    if (bcLen > 0)
    {
        Memcpy(buf->end, bcBuf.start, bcLen);
        buf->end += bcLen;
        psFree(bcBuf.buf, pool);
    }

    /* SubjectKeyId */
    if (skLen > 0)
    {
        Memcpy(buf->end, skBuf.start, skLen);
        buf->end += skLen;
        psFree(skBuf.buf, pool);
    }

    /* AuthorityKeyId */
    if (akLen > 0)
    {
        Memcpy(buf->end, akBuf.start, akLen);
        buf->end += akLen;
        psFree(akBuf.buf, pool);
    }

    /* SAN */
    if (sanLen > 0)
    {
        Memcpy(buf->end, sanBuf.start, sanLen);
        buf->end += sanLen;
        psFree(sanBuf.buf, pool);
    }

    /* issuerAltName */
    if (issuerAltNameLen > 0)
    {
        Memcpy(buf->end, issuerAltNameBuf.start, issuerAltNameLen);
        buf->end += issuerAltNameLen;
        psFree(issuerAltNameBuf.buf, pool);
    }

    /* authorityInfoAccess */
    if (authInfoLen > 0)
    {
        Memcpy(buf->end, authInfoBuf.start, authInfoLen);
        buf->end += authInfoLen;
        psFree(authInfoBuf.buf, pool);
    }

    /* certificatePolicies */
    if (polLen > 0)
    {
        Memcpy(buf->end, polBuf.start, polLen);
        buf->end += polLen;
        psFree(polBuf.buf, pool);
    }

    /* policyConstraints */
    if (polConLen > 0)
    {
        Memcpy(buf->end, polConBuf.start, polConLen);
        buf->end += polConLen;
        psFree(polConBuf.buf, pool);
    }

    /* policyMappings */
    if (polMapLen > 0)
    {
        Memcpy(buf->end, polMapBuf.start, polMapLen);
        buf->end += polMapLen;
        psFree(polMapBuf.buf, pool);
    }

    /* netscape-comment */
    if (nsCmtLen > 0)
    {
        Memcpy(buf->end, nsCmtBuf.start, nsCmtLen);
        buf->end += nsCmtLen;
        psFree(nsCmtBuf.buf, pool);
    }

    /* KeyUsage */
    if (kuLen > 0)
    {
        Memcpy(buf->end, kuBuf.start, kuLen);
        buf->end += kuLen;
        psFree(kuBuf.buf, pool);
    }

    /* extKeyUsage */
    if (ekuLen > 0)
    {
        Memcpy(buf->end, ekuBuf.start, ekuLen);
        buf->end += ekuLen;
        psFree(ekuBuf.buf, pool);
    }

/*
    copy it over and free buf
 */
    *extLen = (int32) (buf->end - buf->start);
    return 0;

fail:
    if (sanLen)
    {
        psFree(sanBuf.buf, pool);
    }
    if (issuerAltNameLen)
    {
        psFree(issuerAltNameBuf.buf, pool);
    }
    if (bcLen)
    {
        psFree(bcBuf.buf, pool);
    }
    if (kuLen)
    {
        psFree(kuBuf.buf, pool);
    }
    if (skLen)
    {
        psFree(skBuf.buf, pool);
    }
    if (akLen)
    {
        psFree(akBuf.buf, pool);
    }
    if (ekuLen)
    {
        psFree(ekuBuf.buf, pool);
    }
    if (authInfoLen)
    {
        psFree(authInfoBuf.buf, pool);
    }
    if (polLen)
    {
        psFree(polBuf.buf, pool);
    }
    if (polConLen)
    {
        psFree(polConBuf.buf, pool);
    }
    if (polMapLen)
    {
        psFree(polMapBuf.buf, pool);
    }
    if (nsCmtLen)
    {
        psFree(nsCmtBuf.buf, pool);
    }

    return -1;
}

/******************************************************************************/
/*
    The ASN that immedately surrounds each individual extension.
    Allocates a buffer to be freed by caller
 */
static int32 psWriteCertExtWrapper(psPool_t *pool, psBuf_t *buf,
    int32 *finalExtLen, unsigned char *extBuf, int32 extBufLen,
    int32 oid[], int32 oidLen, int32 critical)
{
    int32 len;

    len = ASN_SEQUENCE_OH + ASN_OID_OH + MAX_OID_LEN + ASN_BOOL_OH +
          ASN_OCTET_STRING_OH + extBufLen;

    buf->start = buf->end = buf->buf = psMalloc(pool, len);
    if (buf->start == NULL)
    {
        return PS_MEM_FAIL;
    }
    buf->size = len;
/*
    Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
    Extension  ::=  SEQUENCE {
        extnID          OBJECT IDENTIFIER,
        extnValue       OCTET STRING    }
 */
    buf->start = buf->end += ASN_SEQUENCE_OH;
    asnWriteOid(buf, oid, oidLen);

    if (critical)
    {
        *buf->end = ASN_BOOLEAN; buf->end++;
        *buf->end = 1; buf->end++;
        *buf->end = 255; buf->end++;
    }
    *buf->end = ASN_OCTET_STRING; buf->end++;
    buf->end += asnHelpWriteLength(buf->end, extBufLen);
    Memcpy(buf->end, extBuf, extBufLen);
    buf->end += extBufLen;
    asnPrependSequence(buf);

    *finalExtLen = (int32) (buf->end - buf->start);

    return 0;
}

/******************************************************************************/
/*
    The basicConstraint writer.  ASN format:

        id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }

        BasicConstraints ::= SEQUENCE {
            cA                      BOOLEAN DEFAULT FALSE,
            pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
 */
static int32 psWriteCertBasicConstraints(psPool_t *pool, psBuf_t *bcBuf,
    int32 caBool, int32 pathLen, int32 *bcExtLen)
{
    psBuf_t *tmpBuf;
    int32 bcLen, oidLen;

/*
    Inside out.  Start with BC content
 */
    bcLen = ASN_SEQUENCE_OH + ASN_BOOL_OH + 1;
    if (caBool && caBool != CA_UNDEFINED)
    {
        bcLen += ASN_INTEGER_OH + 8; /* Plenty of room for pathLen */
        caBool = 255;                /* Convert to DER notion of TRUE */
    }

    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, bcLen);
    if (tmpBuf->buf == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = bcLen;

    tmpBuf->end = tmpBuf->start += ASN_SEQUENCE_OH;
    *tmpBuf->end = ASN_BOOLEAN; tmpBuf->end++;
    *tmpBuf->end = 1; tmpBuf->end++;
    *tmpBuf->end = caBool; tmpBuf->end++;
/*
    Directly from RFC 2459 section 4.2.1.10
    The pathLenConstraint field is meaningful only if cA is set to TRUE.
    In this case, it gives the maximum number of CA certificates that may
    follow this certificate in a certification path. A value of zero
    indicates that only an end-entity certificate may follow in the path.
    Where it appears, the pathLenConstraint field MUST be greater than or
    equal to zero. Where pathLenConstraint does not appear, there is no
    limit to the allowed length of the certification path.

 */
    if (caBool && (pathLen >= 0))
    {
        asnWriteInteger(tmpBuf, pathLen);
    }
    asnPrependSequence(tmpBuf);
    bcLen = (int32) (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(basicConstraintOID) / sizeof(int32);

    if (psWriteCertExtWrapper(pool, bcBuf, bcExtLen, tmpBuf->start, bcLen,
            basicConstraintOID, oidLen, 1) < 0)
    {
        psFree(tmpBuf->buf, pool);
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *bcExtLen;
}

/*
    Found on the Internets with the comment:
    I believe a very good general purpose algorithm is the following, known as
    'parallel' or 'variable-precision SWAR algorithm':

    Credit to whoever figured this out
 */
static int32 NumberOfSetBits(uint32 i)
{
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
    return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
}

static int32 psWriteCertExtKeyUsage(psPool_t *pool, psBuf_t *kuBuf,
    x509v3extensions_t *ext, int32 *kuExtLen)
{
    psBuf_t *tmpBuf;
    int32 kuLen, oidLen, oidCnt;

    oidCnt = NumberOfSetBits(ext->ekuFlags);

    kuLen = ASN_SEQUENCE_OH + (ASN_OID_OH * oidCnt) + 1 + 16;

    if ((tmpBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    tmpBuf->start = tmpBuf->end = tmpBuf->buf = psMalloc(pool, kuLen);
    if (tmpBuf->start == NULL)
    {
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }
    tmpBuf->size = kuLen;

    tmpBuf->end = tmpBuf->start += ASN_SEQUENCE_OH;

    if (ext->ekuFlags & EXT_KEY_USAGE_TLS_SERVER_AUTH)
    {
        asnWriteOid(tmpBuf, tlsServerAuth, 8);
    }
    if (ext->ekuFlags & EXT_KEY_USAGE_TLS_CLIENT_AUTH)
    {
        asnWriteOid(tmpBuf, tlsClientAuth, 8);
    }
    if (ext->ekuFlags & EXT_KEY_USAGE_CODE_SIGNING)
    {
        asnWriteOid(tmpBuf, codeSigning, 8);
    }
    asnPrependSequence(tmpBuf);

    kuLen = (int32) (tmpBuf->end - tmpBuf->start);

/*
    Now the wrapper
 */
    oidLen = sizeof(ekuExtOID) / sizeof(int32);

    if (psWriteCertExtWrapper(pool, kuBuf, kuExtLen, tmpBuf->start, kuLen,
            ekuExtOID, oidLen, 1) < 0)
    {
        psFree(tmpBuf->buf, pool);
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *kuExtLen;
}


static int32 psWriteCertKeyUsage(psPool_t *pool, psBuf_t *kuBuf,
    x509v3extensions_t *ext, int32 *kuExtLen)
{
    psBuf_t *tmpBuf;
    int32 kuLen, oidLen;
    int32 numOctets = 1;
    int32 rc;
    unsigned char bits[2] = {0};

    bits[0] = (unsigned char)(ext->keyUsageFlags & 0xff);
    if ((ext->keyUsageFlags >> 8) != 0)
    {
        /*
          Need two value octets. Currently only needed when the
          decipherOnly bit (bit #8) is set. (According to DER, we
          we can skip trailing octets that have no bits set to 1).
        */
        numOctets++;
        bits[1] = (unsigned char)(ext->keyUsageFlags >> 8);
    }

    rc = psAsnWriteBitStringDER(pool,
            &tmpBuf,
            bits,
            numOctets,
            0,
            0);
    if (rc < 0)
    {
        return rc;
    }
    kuLen = rc;

/*
    Now the wrapper
 */
    oidLen = sizeof(kuExtOID) / sizeof(int32);

    if (psWriteCertExtWrapper(pool, kuBuf, kuExtLen, tmpBuf->start, kuLen,
            kuExtOID, oidLen, 1) < 0)
    {
        psFree(tmpBuf->buf, pool);
        psFree(tmpBuf, pool);
        return PS_MEM_FAIL;
    }

    psFree(tmpBuf->buf, pool);
    psFree(tmpBuf, pool);

    return *kuExtLen;
}

/* Write extensions to a certificate request */
int32 psWriteCertReqExt(psPool_t *pool, psBuf_t *buf, x509v3extensions_t *ext,
    int32 *extLen, psCertConfig_t *certConfig)
{
    int32 bcLen, sanLen, issuerAltNameLen, polLen, polConLen, polMapLen,
        authInfoLen, kuLen, skLen, ekuLen, totLen, oidLen, nsCmtLen,
        otherLen;
    psBuf_t bcBuf, sanBuf, issuerAltNameBuf, polBuf, polConBuf, polMapBuf,
        authInfoBuf, kuBuf, skBuf, ekuBuf, nsCmtBuf;
    psBool_t addExtensionRequest = PS_FALSE;

    sanLen = issuerAltNameLen = polLen = polConLen = polMapLen = 0;
    authInfoLen = kuLen = bcLen = skLen = ekuLen = nsCmtLen = 0;
    otherLen = ext->otherAttributes ?
        psBufGetDataSize(&ext->otherAttributes->buf) : 0;

    if (ext->bc.cA != CA_UNDEFINED)
    {
        if (psWriteCertBasicConstraints(pool, &bcBuf, ext->bc.cA,
                ext->bc.pathLenConstraint, &bcLen) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    if (ext->san != NULL)
    {
        if (psWriteCertSANExt(pool, &sanBuf, ext, &sanLen, 0) < 0)
        {
            if (bcLen)
            {
                psFree(bcBuf.buf, pool);
            }
            return PS_MEM_FAIL;
        }
    }
    if (ext->issuerAltName != NULL)
    {
        if (psWriteCertSANExt(pool, &issuerAltNameBuf, ext, &issuerAltNameLen, 1) < 0)
        {
            if (bcLen)
            {
                psFree(bcBuf.buf, pool);
            }
            if (sanLen)
            {
                psFree(sanBuf.buf, pool);
            }
            return PS_MEM_FAIL;
        }
    }
    if (ext->authorityInfoAccess != NULL)
    {
        psWriteAuthorityInfoAccessExt(pool, &authInfoBuf, ext->authorityInfoAccess,
            &authInfoLen);
    }
    if (ext->certificatePolicy.policy != NULL)
    {
        psWriteCertPoliciesExt(pool, &polBuf, &ext->certificatePolicy,
            &polLen, certConfig);
    }
    if (ext->policyConstraints.requireExplicitPolicy > 0 ||
        ext->policyConstraints.inhibitPolicyMappings > 0)
    {
        psWriteCertPolicyConstraintsExt(pool, &polConBuf, &ext->policyConstraints,
            &polConLen);
    }
    if (ext->policyMappings != NULL)
    {
        psWriteCertPolicyMappingsExt(pool, &polMapBuf, ext->policyMappings,
            &polMapLen);
    }
    if (ext->netscapeComment != NULL)
    {
        psWriteNetscapeCommentExt(pool, &nsCmtBuf, ext->netscapeComment,
            &nsCmtLen);
    }
    if (ext->keyUsageFlags != 0)
    {
        if (psWriteCertKeyUsage(pool, &kuBuf, ext, &kuLen) < 0)
        {
            if (bcLen)
            {
                psFree(bcBuf.buf, pool);
            }
            if (sanLen)
            {
                psFree(sanBuf.buf, pool);
            }
            if (issuerAltNameLen)
            {
                psFree(issuerAltNameBuf.buf, pool);
            }
            return PS_MEM_FAIL;
        }
    }

    if (ext->ekuFlags != 0)
    {
        if (psWriteCertExtKeyUsage(pool, &ekuBuf, ext, &ekuLen) < 0)
        {
            if (bcLen)
            {
                psFree(bcBuf.buf, pool);
            }
            if (sanLen)
            {
                psFree(sanBuf.buf, pool);
            }
            if (issuerAltNameLen)
            {
                psFree(issuerAltNameBuf.buf, pool);
            }
            if (kuLen)
            {
                psFree(kuBuf.buf, pool);
            }
            return PS_MEM_FAIL;
        }
    }
    if (ext->sk.len != 0 && ext->sk.id != NULL)
    {
        if (psWriteSubjectKeyId(pool, &skBuf, ext, &skLen) < 0)
        {
            if (bcLen)
            {
                psFree(bcBuf.buf, pool);
            }
            if (sanLen)
            {
                psFree(sanBuf.buf, pool);
            }
            if (issuerAltNameLen)
            {
                psFree(issuerAltNameBuf.buf, pool);
            }
            if (kuLen)
            {
                psFree(kuBuf.buf, pool);
            }
            return PS_MEM_FAIL;
        }
    }

    /* The following go into the extensionRequest attribute. */
    totLen = sanLen + issuerAltNameLen + kuLen + skLen + bcLen + ekuLen;
    totLen += polLen + polConLen + polMapLen + authInfoLen + nsCmtLen;
    if (totLen > 0)
    {
        addExtensionRequest = PS_TRUE;
    }

    /* Other attributes. */
    totLen += otherLen;

    if (totLen == 0)
    {
        /*
           Nothing to encode.
         */
        return PS_SUCCESS;
    }

    totLen += (ASN_OID_OH + 9) + (ASN_SEQUENCE_OH * 2) + 1;

    buf->buf = buf->start = buf->end = psMalloc(pool, totLen);
    if (buf->buf == NULL)
    {
        if (sanLen)
        {
            psFree(sanBuf.buf, pool);
        }
        if (issuerAltNameLen)
        {
            psFree(issuerAltNameBuf.buf, pool);
        }
        if (bcLen)
        {
            psFree(bcBuf.buf, pool);
        }
        if (kuLen)
        {
            psFree(kuBuf.buf, pool);
        }
        if (ekuLen)
        {
            psFree(ekuBuf.buf, pool);
        }
        return -1;
    }

    buf->size = totLen;

    if (addExtensionRequest)
    {
        buf->start = buf->end += ASN_SEQUENCE_OH;
        oidLen = sizeof(extReqOID) / sizeof(int32);
        if (asnWriteOid(buf, extReqOID, oidLen) < 0)
        {
            if (sanLen)
            {
                psFree(sanBuf.buf, pool);
            }
            if (issuerAltNameLen)
            {
                psFree(issuerAltNameBuf.buf, pool);
            }
            if (bcLen)
            {
                psFree(bcBuf.buf, pool);
            }
            if (kuLen)
            {
                psFree(kuBuf.buf, pool);
            }
            if (ekuLen)
            {
                psFree(ekuBuf.buf, pool);
            }
            return -1;
        }

        /* reusing totLen */
        totLen = sanLen + issuerAltNameLen + kuLen + skLen + bcLen + ekuLen;
        totLen += polLen + polConLen + polMapLen + authInfoLen + nsCmtLen;

        /* magic 1 is for the SEQUENCE id to follow */
        asnWriteSet(buf, totLen + asnBytesToHold(totLen) + 1);
        asnWriteSequence(buf, totLen);

        /* basicConstraints */
        if (bcLen > 0)
        {
            Memcpy(buf->end, bcBuf.start, bcLen);
            buf->end += bcLen;
            psFree(bcBuf.buf, pool);
        }

        /* SubjectKeyId */
        if (skLen > 0)
        {
            Memcpy(buf->end, skBuf.start, skLen);
            buf->end += skLen;
            psFree(skBuf.buf, pool);
        }

        /* SAN */
        if (sanLen > 0)
        {
            Memcpy(buf->end, sanBuf.start, sanLen);
            buf->end += sanLen;
            psFree(sanBuf.buf, pool);
        }

        /* issuerAltName */
        if (issuerAltNameLen > 0)
        {
            Memcpy(buf->end, issuerAltNameBuf.start, issuerAltNameLen);
            buf->end += issuerAltNameLen;
            psFree(issuerAltNameBuf.buf, pool);
        }

        /* authorityInfoAccess */
        if (authInfoLen > 0)
        {
            Memcpy(buf->end, authInfoBuf.start, authInfoLen);
            buf->end += authInfoLen;
            psFree(authInfoBuf.buf, pool);
        }

        /* certificatePolicies */
        if (polLen > 0)
        {
            Memcpy(buf->end, polBuf.start, polLen);
            buf->end += polLen;
            psFree(polBuf.buf, pool);
        }

        /* policyConstraints */
        if (polConLen > 0)
        {
            Memcpy(buf->end, polConBuf.start, polConLen);
            buf->end += polConLen;
            psFree(polConBuf.buf, pool);
        }

        /* policyMappings */
        if (polMapLen > 0)
        {
            Memcpy(buf->end, polMapBuf.start, polMapLen);
            buf->end += polMapLen;
            psFree(polMapBuf.buf, pool);
        }

        /* netscape-comment */
        if (nsCmtLen > 0)
        {
            Memcpy(buf->end, nsCmtBuf.start, nsCmtLen);
            buf->end += nsCmtLen;
            psFree(nsCmtBuf.buf, pool);
        }

        /* KeyUsage */
        if (kuLen > 0)
        {
            Memcpy(buf->end, kuBuf.start, kuLen);
            buf->end += kuLen;
            psFree(kuBuf.buf, pool);
        }

        /* ExtendedKeyUsage */
        if (ekuLen > 0)
        {
            Memcpy(buf->end, ekuBuf.start, ekuLen);
            buf->end += ekuLen;
            psFree(ekuBuf.buf, pool);
        }

        /* done */
        asnPrependSequence(buf);
    } /* endif (addExtensionRequest) */

    /* other attributes */
    if (otherLen > 0)
    {
        Memcpy(buf->end, psBufGetData(&ext->otherAttributes->buf), otherLen);
        buf->end += otherLen;
    }

/*
    copy it over and free buf
 */
    *extLen = (int32) (buf->end - buf->start);
    return 0;
}


/******************************************************************************/
/*
    psWriteSignature helper

    signatureValue       BIT STRING
 */
static int32 writeSignature(psBuf_t *certBuf, unsigned char *certSig,
    int32 certSigLen)
{
    psBuf_t *sigBuf;
    int32 rc;
    int32 rv = PS_SUCCESS;
    int32 spaceLeft; /* Space left in certBuf. */
    int32 resLen; /* Length of the encoded BIT STRING. */

    rc = psAsnWriteBitStringDER(NULL,
            &sigBuf,
            certSig,
            certSigLen,
            0,
            0);
    if (rc < 0)
    {
        return rc;
    }

    /* Ensure there is enough room in certBuf. If yes, append the
       encoding to certBuf. */
    resLen = rc;
    spaceLeft = certBuf->size - (certBuf->end - certBuf->start);
    if (spaceLeft < resLen)
    {
        psTraceCrypto("Not enough space in certBuf for sig\n");
        rv = PS_FAILURE;
        goto out;
    }

    Memcpy(certBuf->end, sigBuf->start, resLen);
    certBuf->end += resLen;
out:
    psBufUninit(NULL, sigBuf);
    psFree(sigBuf, NULL);

    return rv;
}

/******************************************************************************/
/*
    psWriteSignature helper
    Raw signature creation given a buffer, key, and algorithm
 */
static int32 createSignature(psPool_t *pool, const unsigned char *buf,
    unsigned long bufLen, int32 hashAlg, psPubKey_t *signingKey,
    unsigned char **signature, int32 *sigLen)
{
    psDigestContext_t digest;
    int32 *certAlg;
    unsigned char certHash[SHA512_HASH_SIZE];
    int32 oidLen, hashSize;
# ifdef USE_RSA 
    psBuf_t sigBufAlg, sigBuf;
    int32 sigAlgIdLen, sigBufLen;
# endif
/*
    Run hash across whole thing with proper algorithm.
    Assign the certAlg and oidLen for the SHA1 or MD5 digestInfo structure
 */
    switch (hashAlg)
    {
# ifdef USE_MD5
    case ALG_MD5:
        psMd5Init(&digest.u.md5);
        psMd5Update(&digest.u.md5, buf, (uint32) bufLen);
        psMd5Final(&digest.u.md5, certHash);
        certAlg = &md5OID[0];
        oidLen = sizeof(md5OID) / sizeof(int32);
        hashSize = MD5_HASH_SIZE;
        break;
# endif
# ifdef USE_SHA1
    case ALG_SHA1:
        psSha1PreInit(&digest.u.sha1);
        psSha1Init(&digest.u.sha1);
        psSha1Update(&digest.u.sha1, buf, (uint32) bufLen);
        psSha1Final(&digest.u.sha1, certHash);
        certAlg = &sha1OID[0];
        oidLen = sizeof(sha1OID) / sizeof(int32);
        hashSize = SHA1_HASH_SIZE;
        break;
# endif
# ifdef USE_SHA224
    case ALG_SHA224:
        psSha224PreInit(&digest.u.sha256);
        psSha224Init(&digest.u.sha256);
        psSha224Update(&digest.u.sha256, buf, (uint32) bufLen);
        psSha224Final(&digest.u.sha256, certHash);
        certAlg = &sha224OID[0];
        oidLen = sizeof(sha224OID) / sizeof(int32);
        hashSize = SHA224_HASH_SIZE;
        break;
# endif
# ifdef USE_SHA256
    case ALG_SHA256:
        psSha256PreInit(&digest.u.sha256);
        psSha256Init(&digest.u.sha256);
        psSha256Update(&digest.u.sha256, buf, (uint32) bufLen);
        psSha256Final(&digest.u.sha256, certHash);
        certAlg = &sha256OID[0];
        oidLen = sizeof(sha256OID) / sizeof(int32);
        hashSize = SHA256_HASH_SIZE;
        break;
# endif
# ifdef USE_SHA384
    case ALG_SHA384:
        psSha384PreInit(&digest.u.sha384);
        psSha384Init(&digest.u.sha384);
        psSha384Update(&digest.u.sha384, buf, (uint32) bufLen);
        psSha384Final(&digest.u.sha384, certHash);
        certAlg = &sha384OID[0];
        oidLen = sizeof(sha384OID) / sizeof(int32);
        hashSize = SHA384_HASH_SIZE;
        break;
# endif
# ifdef USE_SHA512
    case ALG_SHA512:
        psSha512PreInit(&digest.u.sha512);
        psSha512Init(&digest.u.sha512);
        psSha512Update(&digest.u.sha512, buf, (uint32) bufLen);
        psSha512Final(&digest.u.sha512, certHash);
        certAlg = &sha512OID[0];
        oidLen = sizeof(sha512OID) / sizeof(int32);
        hashSize = SHA512_HASH_SIZE;
        break;
# endif
    default:
        return PS_UNSUPPORTED_FAIL;
    }

    switch (signingKey->type)
    {
# ifdef USE_RSA      
    case PS_RSA:
        /*
          Signature is yet another ASN.1 encoded SEQUENCE and OID surrounding
          the hash.  DigestInfo structure.  The algorithm id here is strictly
          for the hash that was used (not the RSA/ECC OID versions).

          This is called a "SignedElement" in the Matrix crypto library.
        */
        if (psWriteCertAlgorithmId(pool, &sigBufAlg, certAlg,
                oidLen, &sigAlgIdLen) < 0)
        {
            psTraceCrypto("Error constructing digestInfo\n");
            return -1;
        }
        sigBufLen = ((int32) (sigBufAlg.end - sigBufAlg.start)) +
                    ASN_SEQUENCE_OH + ASN_OCTET_STRING_OH + hashSize;
        sigBuf.buf = sigBuf.start = sigBuf.end = psMalloc(pool, sigBufLen);
        if (sigBuf.buf == NULL)
        {
            return PS_MEM_FAIL;
        }
        sigBuf.size = sigBufLen;
        sigBuf.start = sigBuf.end += ASN_SEQUENCE_OH;
        /* Cert algorithm as constructed above in sigBufAlg */
        Memcpy(sigBuf.end, sigBufAlg.start, sigAlgIdLen);
        psFree(sigBufAlg.buf, pool);
        sigBuf.end += sigAlgIdLen;

        /* The octet string of the hash itself and wrapper SEQUENCE */
        *sigBuf.end = ASN_OCTET_STRING; sigBuf.end++;
        sigBuf.end += asnHelpWriteLength(sigBuf.end, hashSize);
        Memcpy(sigBuf.end, certHash, hashSize);
        sigBuf.end += hashSize;
        asnPrependSequence(&sigBuf);
        sigBufLen = (int32) (sigBuf.end - sigBuf.start);
        /* Now have the digestInfo structure complete to sign */

        *sigLen = signingKey->keysize;
        if ((*signature = psMalloc(pool, *sigLen)) == NULL)
        {
            psFree(sigBuf.buf, pool);
            return PS_MEM_FAIL;
        }
        /* psTraceBytes("Signing", sigBuf.start, sigBufLen); */
        if (psRsaEncryptPriv(pool, &signingKey->key.rsa, sigBuf.start, sigBufLen,
                *signature, *sigLen, NULL) < 0)
        {
            psTraceCrypto("Error encrypting hash for signature\n");
            psFree(*signature, pool);
            psFree(sigBuf.buf, pool);
            return -1;
        }
        psFree(sigBuf.buf, pool);
        break;
#endif
# ifdef USE_ECC
case PS_ECC:
        *sigLen = signingKey->keysize;
        /* NEGATIVE ECDSA - Adding room for two 0x0 bytes in the
            ECDSA signature.

            However, if this is a 521 curve there is no chance
            for negative because there can only be a single
            low bit for that sig size. */
        if (signingKey->keysize != 132)
        {
            *sigLen += 2;
        }
        /* Signature portion */
        *sigLen += 6; /* 6 = 2 ASN_SEQ, 4 ASN_BIG */
        /* BIG EC KEY.  The sig is 2 bytes len, 1 byte SEQ,
            1 byte length (+1 OPTIONAL byte if length is >=128),
            1 byte INT, 1 byte rLen, r, 1 byte INT, 1 byte sLen, s.
            So the +4 here are the 2 INT and 2 rLen/sLen bytes on
            top of the keysize */
        if (signingKey->keysize + 4 >= 128)
        {
            *sigLen += 1; /* Extra byte for 'long' asn.1 encode */
        }
        if ((*signature = psMalloc(pool, *sigLen)) == NULL)
        {
            return PS_MEM_FAIL;
        }
        /* ECDSA just signs the raw hash.. no SignedElement wrapping */
        /* OK to downcast sigLen because it's already coming in as sane */
        if (psEccDsaSign(pool, &signingKey->key.ecc, certHash, hashSize,
                *signature, (uint16_t *) sigLen, 0, NULL) < 0)
        {
            psTraceCrypto("Error encrypting hash for signature\n");
            psFree(*signature, pool);
            return -1;
        }
        break;
# endif /* USE_ECC */
    default:
        psTraceIntCrypto("Unsupported signing key type: %d\n",
                signingKey->type);
        return PS_UNSUPPORTED_FAIL;
    }

    return 0;
}

/******************************************************************************/
/*
    Writes out the signature portion of the certificate and cert request files
 */
int32 psWriteSignature(psPool_t *pool, psBuf_t *buf, unsigned char *algIdBuf,
    int32 algIdBufLen, psPubKey_t *signingKey, int32 hashAlg)
{
    unsigned char *certSignature;
    int32 certSigLen;

/*
    Generate the raw signature for the given buffer
 */
    certSignature = NULL;
    if (createSignature(pool, buf->start, (unsigned long) (buf->end - buf->start),
            hashAlg, signingKey, &certSignature, &certSigLen) < 0)
    {
        psTraceCrypto("Error generating signature\n");
        return -1;
    }

/*
    Still writing to the certBuf.  Continute with cert algorithm id that
    was used to hash the certificate contents
 */
    Memcpy(buf->end, algIdBuf, algIdBufLen);
    buf->end += algIdBufLen;

    if (writeSignature(buf, certSignature, certSigLen) < 0)
    {
        psTraceCrypto("Error writing final cert signature\n");
        psFree(certSignature, pool);
        return -1;
    }
    psFree(certSignature, pool);

    asnPrependSequence(buf);

    return 0;
}

static
int32 handleAuthorityInfoAccess(psPool_t *pool, psCertConfig_t *certConfig,
    char *name, char *value, int32 valLen)
{
    x509authorityInfoAccess_t *authInfo;
    size_t prefix_len = Strlen("authorityInfoAccess-");

    if (Strncmp(name, "authorityInfoAccess-", prefix_len))
    {
        psTraceCrypto("Wrong prefix\n");
        return PS_PARSE_FAIL;
    }
    if (valLen < 1)
    {
        return PS_PARSE_FAIL;
    }

    if (certConfig->ext->authorityInfoAccess == NULL)
    {
        /* This is the first authorityInfoAccess entry. */
        certConfig->ext->authorityInfoAccess =
            psMalloc(pool, sizeof(x509authorityInfoAccess_t));
        Memset(certConfig->ext->authorityInfoAccess, 0,
            sizeof(x509authorityInfoAccess_t));
        authInfo = certConfig->ext->authorityInfoAccess;
    }
    else
    {
        /* Append another entry to the list. */
        authInfo = certConfig->ext->authorityInfoAccess;
        while (authInfo->next)
        {
            authInfo = authInfo->next;
        }
        authInfo->next = psMalloc(pool, sizeof(x509authorityInfoAccess_t));
        Memset(authInfo->next, 0, sizeof(x509authorityInfoAccess_t));
        authInfo = authInfo->next;
    }

    if (!Strncmp(name + prefix_len, "ocsp", 4))
    {
        authInfo->ocsp = psMalloc(pool, valLen);
        if (authInfo->ocsp == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memset(authInfo->ocsp, 0, valLen);
        Memcpy(authInfo->ocsp, value, valLen);
        authInfo->ocspLen = valLen;
    }
    else if (!Strncmp(name + prefix_len, "caIssuers", 9))
    {
        authInfo->caIssuers = psMalloc(pool, valLen);
        if (authInfo->caIssuers == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memset(authInfo->caIssuers, 0, valLen);
        Memcpy(authInfo->caIssuers, value, valLen);
        authInfo->caIssuersLen = valLen;
    }
    else
    {
        psTraceCrypto("Unsupported authorityInfoAccess attrib name\n");
        return PS_PARSE_FAIL;
    }

    return PS_SUCCESS;
}

static
int32 handleNetscapeComment(psPool_t *pool, psCertConfig_t *certConfig,
    char *name, char *value, int32 valLen)
{
    size_t prefix_len = Strlen("netscapeComment");

    if (Strncmp(name, "netscapeComment", prefix_len))
    {
        psTraceCrypto("Wrong prefix\n");
        return PS_PARSE_FAIL;
    }
    if (valLen < 1)
    {
        return PS_PARSE_FAIL;
    }

    return psX509SetNetscapeComment(pool, certConfig, value,
        (size_t) valLen);
}

static
int32 handlePolicyConstraints(psPool_t *pool, psCertConfig_t *certConfig,
    char *name, char *value, int32 valLen)
{
    x509policyConstraints_t *pol_con;
    size_t prefix_len = Strlen("policyConstraints-");

    pol_con = &certConfig->ext->policyConstraints;

    if (!Strncmp(name + prefix_len, "requireExplicitPolicy", 21))
    {
        if (valLen != 1)
        {
            psTraceCrypto("Too long value in requireExplicitPolicy\n");
        }
        pol_con->requireExplicitPolicy = atoi(value);
    }
    else if (!Strncmp(name + prefix_len, "inhibitPolicyMapping", 20))
    {
        if (valLen != 1)
        {
            psTraceCrypto("Too long value in inhibitPolicyMapping\n");
        }
        pol_con->inhibitPolicyMappings = atoi(value);
    }
    else
    {
        psTraceCrypto("Illegal policyConstraints\n");
        return PS_PARSE_FAIL;
    }

    return PS_SUCCESS;
}

static int32 handlePolicyMappings(psPool_t *pool, psCertConfig_t *certConfig,
    char *name, char *value, int32 valLen)
{
    x509policyMappings_t *pol_map;
    const char *end;
    char *oid1_str, *oid2_str;
    size_t oid1_len, oid2_len;
    char buf[256] = { 0 };
    char *p;
    unsigned char oid1[MAX_OID_LEN] = { 0 };
    unsigned char oid2[MAX_OID_LEN] = { 0 };
    int32 written = 0;

    if (Strncmp(name, "policyMappings", 14))
    {
        psTraceCrypto("Error in handlePolicyMappings\n");
        return PS_FAILURE;
    }

    if (certConfig->ext->policyMappings == NULL)
    {
        /* This is the first policyMapping. */
        certConfig->ext->policyMappings = psMalloc(pool, sizeof(x509policyMappings_t));
        Memset(certConfig->ext->policyMappings, 0, sizeof(x509policyMappings_t));
        pol_map = certConfig->ext->policyMappings;
    }
    else
    {
        /* Add another policy mapping to the list. */
        pol_map = certConfig->ext->policyMappings;
        pol_map->next = psMalloc(pool, sizeof(x509policyMappings_t));
        Memset(pol_map->next, 0, sizeof(x509policyMappings_t));
        pol_map = pol_map->next;
    }

    Memcpy(buf, value, valLen);
    p = buf;
    end = buf + valLen;

    /* Split into oid1 and oid2. The OIDs are assumed to be in ASCII hex
       format containing the DER encoded OID. */
    oid1_str = Strtok(p, ":");
    if (!oid1_str || oid1_str > end)
    {
        return PS_PARSE_FAIL;
    }

    oid2_str = Strtok(NULL, ":");
    if (!oid2_str || oid2_str > end)
    {
        return PS_PARSE_FAIL;
    }

    oid1_len = Strlen(oid1_str) / 2; /* Two hex digits per byte. */
    oid2_len = Strlen(oid2_str) / 2;

    if (psHexToBinary((unsigned char *) oid1_str, oid1, oid1_len) < 0)
    {
        psTraceCrypto("psHexToBinary failed\n");
        return PS_PARSE_FAIL;
    }
    if (psHexToBinary((unsigned char *) oid2_str, oid2, oid2_len) < 0)
    {
        psTraceCrypto("psHexToBinary failed\n");
        return PS_PARSE_FAIL;
    }

    /* Alloc space in extension struct. */
    pol_map->issuerDomainPolicy = psMalloc(pool, sizeof(psAsnOid_t));
    if (pol_map->issuerDomainPolicy == NULL)
    {
        psTraceCrypto("memory allocation failure\n");
        return PS_PARSE_FAIL;
    }
    pol_map->subjectDomainPolicy = psMalloc(pool, sizeof(psAsnOid_t));
    if (pol_map->subjectDomainPolicy == NULL)
    {
        psTraceCrypto("memory allocation failure\n");
        psFree(pol_map->issuerDomainPolicy, pool);
        pol_map->issuerDomainPolicy = NULL;
        return PS_PARSE_FAIL;
    }

    /* Because psAsnOid_t is actually just encoded binary representation of
       oid, we can use asnWriteOidChars() to fill in the structure. */
    written = asnWriteOidChars((unsigned char *) *pol_map->issuerDomainPolicy,
        oid1, oid1_len);
    if (written <= 0)
    {
        psTraceCrypto("asnWriteOidChars failed\n");
        return PS_PARSE_FAIL;
    }

    written = asnWriteOidChars((unsigned char *) *pol_map->subjectDomainPolicy,
        oid2, oid2_len);
    if (written <= 0)
    {
        psTraceCrypto("asnWriteOidChars failed\n");
        return PS_PARSE_FAIL;
    }

    return PS_SUCCESS;
}

static int32 handlePolicy(psPool_t *pool, psCertConfig_t *certConfig,
    char *name, char *value, int32 valLen)
{
    int n, un;
    policy_parse_helper_t *h;

    if (Strncmp(name, "certPolicy", 10))
    {
        return PS_FAILURE;
    }
    name += 10;

    if (certConfig->polh == NULL)
    {
        /* Alloc parse helper struct. */
        certConfig->polh = psMalloc(pool, sizeof(policy_parse_helper_t));
        if (certConfig->polh == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memset(certConfig->polh, 0, sizeof(policy_parse_helper_t));
    }
    h = certConfig->polh;

    /* First char in name tells the policy index (0..9). */
    n = name[0] - '0';
    name++;
    if (n < 1 || n >= MAX_POLICIES)
    {
        psTraceCrypto("Invalid policy index\n");
        return PS_PARSE_FAIL;
    }

    name++; /* Skip over '-'. */

    if (h->num_policies == 0)
    {
        /* Malloc policy linked list root. */
        certConfig->ext->certificatePolicy.policy =
            psMalloc(pool, sizeof(x509PolicyInformation_t));
        if (certConfig->ext->certificatePolicy.policy == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memset(certConfig->ext->certificatePolicy.policy, 0,
            sizeof(x509PolicyInformation_t));
    }

    /*
       Problem: we get only one policy OID, CPS or UserNotice per call
       to this function. So it is difficult to create the
       PolicyInformation structs at this point. Instead, we just copy
       the values to a temporary (global) policy_contents array.
       Creating the actual structs and linked lists is then up to
       psWriteCertPoliciesExt.
     */
    if (!Strncmp(name, "id", 2))
    {
        Memcpy(h->policies[n].oid, value, valLen);
        h->policies[n].oid_len = valLen;
        /* id is obligatory in each policy. Therefore,
         #ids == num policies. */
        h->num_policies++;
    }
    else if (!Strncmp(name, "cps", 3))
    {
        Memcpy(h->policies[n].cps[h->policies[n].num_cps], value, valLen);
        h->policies[n].num_cps++;
    }
    else if (!Strncmp(name, "unotice", 7))
    {
        name += 7;
        un = name[0] - '0'; /* UserNotice index. */
        un--;               /* Indexing starts from 1 in the config file. */
        name++;
        name++;             /* Skip over '-'. */
        if (!Strncmp(name, "explicitText", 12))
        {
            Memcpy(h->policies[n].explicitText[un], value, valLen);
        }
        else if (!Strncmp(name, "organization", 12))
        {
            Memcpy(h->policies[n].organization[un], value, valLen);
        }
        else if (!Strncmp(name, "noticeNumbers", 13))
        {
            /* Only noticeNumbers 0..9 are supported. */
            do
            {
                h->policies[n].noticeNumbers[un][h->policies[n].num_noticeNumbers[un]++] = *value - '0';
                value++;
            }
            while (*value++ == ',');
        }
        else
        {
            psTraceCrypto("Failed to parse UserNotice in policy config\n");
            return PS_PARSE_FAIL;
        }
        if ((un + 1) > h->policies[n].num_userNotice)
        {
            h->policies[n].num_userNotice = un + 1;
        }
    }
    else
    {
        psTraceCrypto("Failed to parse policy config entry\n");
        return PS_PARSE_FAIL;
    }

    return PS_SUCCESS;
}

static int32 handleSubAltName(psPool_t *pool, psCertConfig_t *certConfig,
    char *name, char *value, int32 valLen)
{
    x509GeneralName_t **prev = NULL, *curr, *next;
    int32 i;
    size_t prefix_len;

    curr = psMalloc(pool, sizeof(x509GeneralName_t));
    if (curr == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(curr, 0x0, sizeof(x509GeneralName_t));
    curr->pool = pool;

    if (!Strncmp(name, "subjectAltName-", 15))
    {
        prefix_len = 15;
        if (certConfig->ext->san == NULL)
        {
            /* First one */
            /* certConfig->ext = psMalloc(pool, sizeof(x509v3extensions_t)); */
            /* if (certConfig->ext == NULL) { */
            /*  return PS_MEM_FAIL; */
            /* } */
            /* Memset(certConfig->ext, 0x0, sizeof(x509v3extensions_t)); */
            certConfig->ext->san = curr;
            prev = &certConfig->ext->san;
        }
        else
        {
            next = certConfig->ext->san;
            while (next != NULL)
            {
                if (next->next == NULL)
                {
                    next->next = curr;
                    prev = &next->next;
                    break;
                }
                next = next->next;
            }
        }
    }
    else if (!Strncmp(name, "issuerAltName-", 14))
    {
        prefix_len = 14;
        if (certConfig->ext->issuerAltName == NULL)
        {
            certConfig->ext->issuerAltName = curr;
            prev = &certConfig->ext->issuerAltName;
        }
        else
        {
            next = certConfig->ext->issuerAltName;
            while (next != NULL)
            {
                if (next->next == NULL)
                {
                    next->next = curr;
                    prev = &next->next;
                    break;
                }
                next = next->next;
            }
        }
    }
    else
    {
        psTraceCrypto("Error parsing subjectAltName/issuerAltName config.\n");
        psFree(curr, pool);
        return PS_FAILURE;
    }

    if (Strncmp(name + prefix_len, "rfc822Name", 10) == 0)
    {
        Memcpy(curr->name, "email", 5);
        curr->id =  GN_EMAIL;
    }
    else if (Strncmp(name + prefix_len, "dNSName", 7) == 0)
    {
        Memcpy(curr->name, "DNS", 3);
        curr->id =  GN_DNS;
/*      TODO: This is a Name type (same as subject and issuer) */
/*      } else if (Strncmp(name + prefix_len, "directoryName", 13) == 0) { */
/*              Memcpy(name->name, "directoryName", 13); */
/*              name->id =  4; */
    }
    else if (Strncmp(name + prefix_len, "uniformResourceIdentifier", 25) == 0)
    {
        Memcpy(curr->name, "URI", 3);
        curr->id =  GN_URI;
    }
    else if (Strncmp(name + prefix_len, "iPAddress", 9) == 0)
    {
        Memcpy(curr->name, "iPAddress", 9);
        curr->id =  GN_IP;
    }
    else if (Strncmp(name + prefix_len, "otherNameOIDDotNotation", 23) == 0)
    {
        unsigned char *oid_buf;
        psSizeL_t oid_buf_len, oid_enc_len;
        int32_t oid_rc;
        int num_sub_ids;

        Memcpy(curr->name, "otherName", 9);
        curr->id = GN_OTHER;
        i = 0;

        /* OID is stuff before : */
        num_sub_ids = 0;

        while (value[i] != ':')
        {
            if (value[i] == '\000')
            { /* end-of-string before colon */
                return PS_PARSE_FAIL;
            }
            if (value[i] == '.')
            {
                num_sub_ids++;
            }
            i++;
        }
        num_sub_ids++;

        /* Guesstimate needed encoding buffer size. */
        oid_buf_len = num_sub_ids * 8;
        oid_buf = psMalloc(pool, oid_buf_len);

        /* Convert OID dot notation to DER. */
        do
        {
            oid_rc = asnEncodeDotNotationOID(pool,
                    oid_buf, oid_buf_len,
                    &oid_enc_len, value, i);
            if (oid_rc == PS_OUTPUT_LENGTH)
            {
                psFree(oid_buf, pool);
                oid_buf_len *= 2;
                oid_buf = psMalloc(pool, oid_buf_len);
            }
        }
        while (oid_rc == PS_OUTPUT_LENGTH);

        if (oid_rc < 0)
        {
            psFree(oid_buf, pool);
            psFree(curr, pool);
            *prev = NULL;
            return oid_rc;
        }

        if ((curr->oid = psMalloc(pool, oid_enc_len)) == NULL)
        {
            psFree(oid_buf, pool);
            psFree(curr, pool);
            *prev = NULL;
            return PS_MEM_FAIL;
        }
        Memcpy(curr->oid, oid_buf, oid_enc_len);
        curr->oidLen = oid_enc_len;
        curr->oidHasTagLenPrefix = 1;
        psFree(oid_buf, pool);

        curr->dataLen = valLen - i - 1;
        if ((curr->data = psMalloc(pool, curr->dataLen)) == NULL)
        {
            psFree(curr->oid, pool);
            psFree(curr, pool);
            *prev = NULL;
            return PS_MEM_FAIL;
        }
        Memcpy(curr->data, value + i + 1, curr->dataLen);
    }
    else if (Strncmp(name + prefix_len, "otherName", 9) == 0)
    {
        /* Not like the others */
        Memcpy(curr->name, "otherName", 9);
        curr->id = GN_OTHER;
        i = 0;
        /* OID is stuff before : */
        while (value[i] != ':')
        {
            if (value[i] == '\000')
            { /* end of string before colon */
                return PS_PARSE_FAIL;
            }
            i++;
        }
        curr->oidLen = i / 2;

        if ((curr->oid = psMalloc(pool, curr->oidLen)) == NULL)
        {
            psFree(curr, pool);
            *prev = NULL;
            return PS_MEM_FAIL;
        }
        if (psHexToBinary((unsigned char *)value,
                        curr->oid, curr->oidLen) < 0)
        {
            psTraceCrypto("psHexToBinary failed\n");
            psFree(curr->oid, pool);
            psFree(curr, pool);
            *prev = NULL;
            return PS_PARSE_FAIL;
        }

        curr->oidHasTagLenPrefix = 0;

        curr->dataLen = valLen - i - 1;
        if ((curr->data = psMalloc(pool, curr->dataLen)) == NULL)
        {
            psFree(curr->oid, pool);
            psFree(curr, pool);
            *prev = NULL;
            return PS_MEM_FAIL;
        }
        Memcpy(curr->data, value + i + 1, curr->dataLen);
        return PS_SUCCESS;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    if (curr->id == 7)
    {
        unsigned char p[16];
        int r, len = 0;

        r = inet_pton(AF_INET, value, p);
        if (r == 1)
            len = 4;
        else if (r == 0)
        {
            r = inet_pton(AF_INET6, value, p);
            if (r == 1)
                len = 16;
            else
                return PS_PARSE_FAIL;
        }
        /* Convert dot notation to OCTET_STRING */
        if ((curr->data = psMalloc(pool, len)) == NULL)
        {
            psFree(curr, pool);
            *prev = NULL;
            return PS_MEM_FAIL;
        }
        Memcpy(curr->data, p, len);
        curr->dataLen = len;
    }
    else if (curr->id == 4)
    {
        /* ASN.1 Name type (same as a distinguishedName) */
    }
    else if (curr->id != 0)
    {
        if ((curr->data = psMalloc(pool, valLen)) == NULL)
        {
            psFree(curr, pool);
            *prev = NULL;
            return PS_MEM_FAIL;
        }
        Memcpy(curr->data, value, valLen);
        curr->dataLen = valLen;
    }

    return PS_SUCCESS;
}


/******************************************************************************/
/*
    Take a string of key=val pairs for parsing
 */
int32 psX509ParseCertConfigBin(psPool_t *pool, unsigned char *fileBin,
    int32 len, psCertConfig_t *certConfig)
{
    unsigned char *tmp, *DNvalMemStart, *DNvalMemEnd;
    char *stmp;
    char idName[64], charTmp[8];
    int32 n, dnfound, DNvalLen, idNameIndex, DNvalIndex, DNLen;
    int32 valIndex, valLen;
    short attcount;

/*
    Parse the config buffer
 */
    Memset(certConfig, 0x0, sizeof(psCertConfig_t));
    /* Callers are using stack for certConfig but we're using this pool
        for all the submembers */
    certConfig->pool = pool;
    Memset(charTmp, 0x0, 8);
    valLen = DNLen = 0;
    tmp = fileBin;
    while ((tmp - fileBin) < len)
    {
        idNameIndex = 0;
        DNvalIndex = (int32) (tmp - fileBin);
        DNvalMemStart = tmp;
        while (*tmp != '=')
        {
            idName[idNameIndex++] = *tmp;
            tmp++;
        }
        tmp++;
/*
        Value must be in double quotes
 */
        if (*tmp != '\"')
        {
            psTraceCrypto("Parse error: values must be double quoted\n");
            return -1;
        }
        tmp++;

        valIndex = (int32) (tmp - fileBin);
/*
        Skip over the value itself
 */
        valLen = 0;
        while (*tmp != '\"')
        {
            tmp++; valLen++;
        }
        tmp++;
/*
        Value must be followed by semicolon
 */
        if (*tmp != ';')
        {
            psTraceCrypto("Parse error: values must be ; terminated\n");
            return -1;
        }
        tmp++;
        DNvalMemEnd = tmp;
/*
        Skip any newlines or whitespace.
 */
        while (*tmp == '\n' || *tmp == ' ' || *tmp == '\r' || *tmp == '\t')
        {
            tmp++;
        }
/*
        If it's a DN entry, just mark the location because it will all
        be put together at the end.
 */
        n = dnfound = 0;
        DNvalLen = (int32) (DNvalMemEnd - DNvalMemStart);
        while (supportedDNTypes[n].name != NULL)
        {
            if (Strncmp(idName, supportedDNTypes[n].name, idNameIndex) == 0)
            {
                attcount = 0;
                while (supportedDNTypes[n].index[attcount] >= 0)
                {
                    attcount++;
                    if (attcount == MAX_DN_ATTRIBUTE_INSTANCES)
                    {
                        psTraceCrypto("Too many DN attribute instances\n");
                        return -1;
                    }
                }
                supportedDNTypes[n].index[attcount] = DNvalIndex;
                supportedDNTypes[n].len[attcount] = DNvalLen;
                DNLen += DNvalLen;
                dnfound++;
                break;
            }
            n++;
        }
        if (dnfound)
        {
            continue;
        }

        if (certConfig->ext == NULL)
        {
            if (x509NewExtensions(&certConfig->ext, pool) < 0)
            {
                return PS_MEM_FAIL;
            }
        }
/*
        Otherwise, just deal with it here
 */
        if (Strncmp(idName, "ca", 2) == 0)
        {
            if (fileBin[valIndex] == '1')
            {
                certConfig->ext->bc.cA = CA_TRUE;
            }
            else
            {
                certConfig->ext->bc.cA = CA_FALSE;
            }
        }
        else if (Strncmp(idName, "pathLen", 6) == 0)
        {
            if (valLen > MAX_CA_PATH_LEN)
            {
                psTraceIntCrypto("MAX PATHLEN EXCEEDED BY %d ", valLen);
                psTraceCrypto("Increase MAX_CA_PATH_LEN if needed\n");
                certConfig->ext->bc.pathLenConstraint = 0;
            }
            else
            {
                Memcpy(charTmp, &fileBin[valIndex], valLen);
                certConfig->ext->bc.pathLenConstraint = atoi(charTmp);
                Memset(charTmp, 0, 8);
            }
        }
        else if (Strncmp(idName, "algorithm", 9) == 0)
        {
            if (Strncmp("md5", (char *) &fileBin[valIndex], 3) == 0)
            {
                certConfig->certAlg = ALG_MD5;
            }
            else if (Strncmp("sha1", (char *) &fileBin[valIndex], 4) == 0)
            {
                certConfig->certAlg = ALG_SHA1;
            }
            else if (Strncmp("sha256", (char *) &fileBin[valIndex], 6) == 0)
            {
                certConfig->certAlg = ALG_SHA256;
            }
            else if (Strncmp("sha384", (char *) &fileBin[valIndex], 6) == 0)
            {
                certConfig->certAlg = ALG_SHA384;
            }
            else if (Strncmp("sha512", (char *) &fileBin[valIndex], 6) == 0)
            {
                certConfig->certAlg = ALG_SHA512;
            }
            else
            {
                psTraceCrypto("Invalid algorithm in cert config file\n");
                certConfig->certAlg = ALG_SHA1;
            }
        }
        else if (Strncmp(idName, "subjectAltName-", 15) == 0)
        {
            if (handleSubAltName(pool, certConfig, idName,
                    (char *) &fileBin[valIndex], valLen) < 0)
            {
                psTraceCrypto("Error parsing subjectAltName- format in config\n");
            }
        }
        else if (Strncmp(idName, "issuerAltName-", 14) == 0)
        {
            if (handleSubAltName(pool, certConfig, idName,
                    (char *) &fileBin[valIndex], valLen) < 0)
            {
                psTraceCrypto("Error parsing issuerAltName- format in config\n");
            }
        }
        else if (Strncmp(idName, "certPolicy", 10) == 0)
        {
            if (handlePolicy(pool, certConfig, idName,
                    (char *) &fileBin[valIndex], valLen) < 0)
            {
                psTraceCrypto("Error parsing certPolicy format in config\n");
            }
        }
        else if (Strncmp(idName, "policyConstraints-", 18) == 0)
        {
            if (handlePolicyConstraints(pool, certConfig, idName,
                    (char *) &fileBin[valIndex], valLen) < 0)
            {
                psTraceCrypto("Error parsing policyConstraints- format in config\n");
            }
        }
        else if (Strncmp(idName, "policyMappings", 14) == 0)
        {
            if (handlePolicyMappings(pool, certConfig, idName,
                    (char *) &fileBin[valIndex], valLen) < 0)
            {
                psTraceCrypto("Error parsing policyMappings format in config\n");
            }
        }
        else if (Strncmp(idName, "authorityInfoAccess", 19) == 0)
        {
            if (handleAuthorityInfoAccess(pool, certConfig, idName,
                    (char *) &fileBin[valIndex], valLen) < 0)
            {
                psTraceCrypto("Error parsing authorityInfoAccess format in config\n");
            }
        }
        else if (Strncmp(idName, "netscapeComment", 15) == 0)
        {
            if (handleNetscapeComment(pool, certConfig, idName,
                    (char *) &fileBin[valIndex], valLen) < 0)
            {
                psTraceCrypto("Error parsing netscapeComment in config\n");
            }
        }
        else if (Strncmp(idName, "validDays", 9) == 0)
        {
            if (valLen > 8)
            {
                certConfig->validDays = 0; /* a sanity check */
            }
            else
            {
                Memcpy(charTmp, &fileBin[valIndex], valLen);
                certConfig->validDays = atoi(charTmp);
                Memset(charTmp, 0, 8);
            }
        }
        else if (Strncmp(idName, "serialNum", 9) == 0)
        {
            if (valLen > 16)
            {
                psTraceCrypto("Serial number too large\n");
            }
            else
            {
                Memcpy(certConfig->serialNumBuf,  &fileBin[valIndex], valLen);
                certConfig->serialNumLen = valLen;
            }
        }
        else if (Strncmp(idName, "keyUsage", 8) == 0)
        {
            if (Strstr((char *) &fileBin[valIndex], "keyCertSign") != NULL)
            {
                certConfig->ext->keyUsageFlags |= KEY_USAGE_KEY_CERT_SIGN;
            }
            if (Strstr((char *) &fileBin[valIndex], "keyAgreement") != NULL)
            {
                certConfig->ext->keyUsageFlags |= KEY_USAGE_KEY_AGREEMENT;
            }
            if (Strstr((char *) &fileBin[valIndex], "crlSign") != NULL)
            {
                certConfig->ext->keyUsageFlags |= KEY_USAGE_CRL_SIGN;
            }
            if (Strstr((char *) &fileBin[valIndex], "digitalSignature") != NULL)
            {
                certConfig->ext->keyUsageFlags |= KEY_USAGE_DIGITAL_SIGNATURE;
            }
            if (Strstr((char *) &fileBin[valIndex], "keyEncipherment") != NULL)
            {
                certConfig->ext->keyUsageFlags |= KEY_USAGE_KEY_ENCIPHERMENT;
            }
            if (Strstr((char *) &fileBin[valIndex], "dataEncipherment") != NULL)
            {
                certConfig->ext->keyUsageFlags |= KEY_USAGE_DATA_ENCIPHERMENT;
            }
            if (Strstr((char *) &fileBin[valIndex], "nonRepudiation") != NULL)
            {
                certConfig->ext->keyUsageFlags |= KEY_USAGE_NON_REPUDIATION;
            }
        }
        else if (Strncmp(idName, "extendedKeyUsage", 8) == 0)
        {
            if (Strstr((char *) &fileBin[valIndex], "serverAuth") != NULL)
            {
                certConfig->ext->ekuFlags |= EXT_KEY_USAGE_TLS_SERVER_AUTH;
            }
            if (Strstr((char *) &fileBin[valIndex], "clientAuth") != NULL)
            {
                certConfig->ext->ekuFlags |= EXT_KEY_USAGE_TLS_CLIENT_AUTH;
            }
            if (Strstr((char *) &fileBin[valIndex], "codeSigning") != NULL)
            {
                certConfig->ext->ekuFlags |= EXT_KEY_USAGE_CODE_SIGNING;
            }
        }
    }

/*
    Have all the DN info indexed in the original fileBuf.  Squish it all
    together in the certConfig members
 */
    if (DNLen > 0)
    {
        n = 0;
        certConfig->DNPairsLen = DNLen;
        stmp = certConfig->DNPairs = psMalloc(pool, DNLen);
        if (stmp == NULL)
        {
            x509FreeExtensions(certConfig->ext);
            if (certConfig->ext->refCount == 0)
            {
                psFree(certConfig->ext, pool);
                certConfig->ext = NULL;
            }
            return PS_MEM_FAIL;
        }
        while (supportedDNTypes[n].name != NULL)
        {
            attcount = 0;
            while (supportedDNTypes[n].index[attcount] >= 0)
            {
                Memcpy(certConfig->DNPairs,
                    &fileBin[supportedDNTypes[n].index[attcount]],
                    supportedDNTypes[n].len[attcount]);
                certConfig->DNPairs += supportedDNTypes[n].len[attcount];
/*
                Clear the index and len members.  This static struct is
                used again during the writing of the DN attributes.
 */
                supportedDNTypes[n].len[attcount] = 0;
                supportedDNTypes[n].index[attcount] = -1;
                attcount++;
                if (attcount == MAX_DN_ATTRIBUTE_INSTANCES)
                {
                    attcount--; /* if all instances are used */
                }
            }
            n++;
        }
        certConfig->DNPairs = stmp;
    }

    return 0;
}

void psX509FreeSAN(x509GeneralName_t *san)
{
    x509GeneralName_t *active, *inc;

    active = san;
    while (active != NULL)
    {
        inc = active->next;
        psFree(active->data, active->pool);
        psFree(active, active->pool);
        active = inc;
    }
}


void psX509FreeCertConfig(psCertConfig_t *certConfig)
{
    if (certConfig)
    {
        if (certConfig->DNPairs != NULL)
        {
            psFree(certConfig->DNPairs, certConfig->pool);
        }
        if (certConfig->DNPairsEncoding != NULL)
        {
            psFree(certConfig->DNPairsEncoding, certConfig->pool);
        }
        if (certConfig->ext != NULL)
        {
            x509FreeExtensions(certConfig->ext);
            if (certConfig->ext->refCount == 0)
            {
                psFree(certConfig->ext, certConfig->pool);
                certConfig->ext = NULL;
            }
        }
        if (certConfig->polh != NULL)
        {
            psFree(certConfig->polh, certConfig->pool);
        }
        if (certConfig->notBefore != NULL)
        {
            psFree(certConfig->notBefore, certConfig->pool);
        }
        if (certConfig->notAfter != NULL)
        {
            psFree(certConfig->notAfter, certConfig->pool);
        }
    }
}


# ifdef USE_OCSP_REQUEST

#  define OCSP_REQUEST_DEFAULT_SIZE 512
static int32_t psWriteOCSPTBSRequestNew(psPool_t *pool, int32_t infoFlags,
    int version,
    const psBuf_t *requestorNameBuf,
    const psBuf_t *requestBuf,
    const psBuf_t *nonceExtension,
    const psBuf_t *requestExtensions,
    int32_t signingOid,
    psPubKey_t *signingKey,
    psX509Cert_t *signingCert,
    psBuf_t *TBSRequestBuf)
{
    psDynBuf_t seq;
    psDynBuf_t ocsp; /* OCSPRequest     ::=     SEQUENCE { tbsRequest,
                                                           optionalSignature }*/
    psDynBuf_t content;

    /* TBSRequest ::= SEQUENCE {
       version             [0] EXPLICIT Version DEFAULT v1,
       requestorName       [1] EXPLICIT GeneralName OPTIONAL,
       requestList             SEQUENCE OF Request,
       requestExtensions   [2] EXPLICIT Extensions OPTIONAL }
     */

    /* At least one request is mandatory. */
    if (requestBuf == NULL)
    {
        return PS_ARG_FAIL;
    }
    /* Version is not encoded, because we always use the default version. */

    /* Start building TBSRequest */
    psDynBufInit(pool, &seq, OCSP_REQUEST_DEFAULT_SIZE);
    psDynBufBeginSequence(&seq, &ocsp);
    psDynBufBeginSequence(&ocsp, &content);

    /* Currently supported version identifier range v1...v128.
       The OCSP is still built according to RFC 6960. */
    if (version > 0 && version <= 127)
    {
        psDynBuf_t versionSub;
        unsigned char version_ch = (unsigned char) version;
        psDynBufBeginConstructedTag(&content, &versionSub);
        psDynBufAppendAsn1TagGen(&versionSub, 2, &version_ch, 1);
        psDynBufEndConstructedTag(&versionSub, 0xA0);
    }
    else if (version == 0)
    {
        /* Version == 0 (v1) => omit default version identifier. */
    }
    else
    {
        psDynBufUninit(&seq);
        return PS_ARG_FAIL; /* Version number outside supported range. */
    }

    /* requestorName: optional */
    if (requestorNameBuf)
    {
        psDynBuf_t reqNameSub;
        psDynBufBeginConstructedTag(&content, &reqNameSub);
        psDynBufAppendBuf(&reqNameSub, requestorNameBuf);
        psDynBufEndConstructedTag(&reqNameSub, 0xA1);
    }
    /* requestList mandatory. */
    psDynBufAppendBuf(&content, requestBuf);

    /* requestExtensions. */
    if ((nonceExtension &&
         (nonceExtension->start != nonceExtension->end)) ||
        requestExtensions)
    {
        psDynBuf_t reqExtSub;
        psDynBuf_t reqExtSub2;
        psDynBufBeginConstructedTag(&content, &reqExtSub);
        psDynBufBeginSequence(&reqExtSub, &reqExtSub2);
        if (nonceExtension &&
            (nonceExtension->start != nonceExtension->end))
        {
            psDynBufAppendBuf(&reqExtSub2, nonceExtension);
        }
        if (requestExtensions)
        {
            psDynBufAppendBuf(&reqExtSub2, requestExtensions);
        }
        psDynBufEndSequence(&reqExtSub2);
        psDynBufEndConstructedTag(&reqExtSub, 0xA2);
    }
    psDynBufEndSequence(&content);

    if (signingKey)
    {
        if ((signingKey->type == PS_RSA &&
             (signingOid == OID_SHA1_RSA_SIG ||
              signingOid == OID_SHA256_RSA_SIG ||
              signingOid == OID_SHA384_RSA_SIG ||
              signingOid == OID_SHA512_RSA_SIG)) ||
            (signingKey->type == PS_ECC &&
             (signingOid == OID_SHA1_ECDSA_SIG ||
              signingOid == OID_SHA256_ECDSA_SIG ||
              signingOid == OID_SHA384_ECDSA_SIG ||
              signingOid == OID_SHA512_ECDSA_SIG)))
        {
            int32 rc;
            int32 hashAlg;
            unsigned char *sig = NULL;
            int32 sigLen;
            psDynBuf_t sigExplicit;
            psDynBuf_t sigSeq;
            psDynBuf_t algSeq;
            psDynBuf_t algBits;

            switch (signingOid)
            {
            case OID_SHA1_RSA_SIG:
            case OID_SHA1_ECDSA_SIG:
                hashAlg = ALG_SHA1;
                break;
            case OID_SHA384_RSA_SIG:
            case OID_SHA384_ECDSA_SIG:
                hashAlg = ALG_SHA384;
                break;
            case OID_SHA512_RSA_SIG:
            case OID_SHA512_ECDSA_SIG:
                hashAlg = ALG_SHA512;
                break;
            default: /* case OID_SHA256_RSA_SIG: case OID_SHA256_ECDSA_SIG: */
                hashAlg = ALG_SHA256;
            }

            rc = createSignature(pool,
                ocsp.buf.start,
                (unsigned int) (ocsp.buf.end - ocsp.buf.start),
                hashAlg, signingKey, &sig, &sigLen);

            if (sig == NULL && rc == PS_SUCCESS)
            {
                rc = PS_MEM_FAIL;
            }

            /* Handle errors if encountered. */
            if (rc != PS_SUCCESS)
            {
                psDynBufUninit(&seq);
                return rc;
            }

            /* Signature       ::=     SEQUENCE { (members) } */
            psDynBufBeginConstructedTag(&ocsp, &sigExplicit);
            psDynBufBeginSequence(&sigExplicit, &sigSeq);

            /* Output Signature algorithm
               signatureAlgorithm   AlgorithmIdentifier */

            psDynBufBeginSequence(&sigSeq, &algSeq);

            switch (signingOid)
            {
            case OID_SHA1_RSA_SIG:
                psDynBufAppendOctets(
                    &algSeq,
                    OID_SHA1_RSA_SIG_HEX "\x05\x00",
                    sizeof(OID_SHA1_RSA_SIG_HEX "\x05\x00") - 1);
                break;
            case OID_SHA384_RSA_SIG:
                psDynBufAppendOctets(
                    &algSeq,
                    OID_SHA384_RSA_SIG_HEX "\x05\x00",
                    sizeof(OID_SHA384_RSA_SIG_HEX "\x05\x00") - 1);
                break;
            case OID_SHA512_RSA_SIG:
                psDynBufAppendOctets(
                    &algSeq,
                    OID_SHA512_RSA_SIG_HEX "\x05\x00",
                    sizeof(OID_SHA512_RSA_SIG_HEX "\x05\x00") - 1);
                break;
            case OID_SHA1_ECDSA_SIG:
                psDynBufAppendOctets(
                    &algSeq,
                    OID_SHA1_ECDSA_SIG_HEX,
                    sizeof(OID_SHA1_ECDSA_SIG_HEX) - 1);
                break;
            case OID_SHA256_ECDSA_SIG:
                psDynBufAppendOctets(
                    &algSeq,
                    OID_SHA256_ECDSA_SIG_HEX,
                    sizeof(OID_SHA256_ECDSA_SIG_HEX) - 1);
                break;
            case OID_SHA384_ECDSA_SIG:
                psDynBufAppendOctets(
                    &algSeq,
                    OID_SHA384_ECDSA_SIG_HEX,
                    sizeof(OID_SHA384_ECDSA_SIG_HEX) - 1);
                break;
            case OID_SHA512_ECDSA_SIG:
                psDynBufAppendOctets(
                    &algSeq,
                    OID_SHA512_ECDSA_SIG_HEX,
                    sizeof(OID_SHA512_ECDSA_SIG_HEX) - 1);
                break;
            default: /* case OID_SHA256_RSA_SIG: */
                psDynBufAppendOctets(
                    &algSeq,
                    OID_SHA256_RSA_SIG_HEX "\x05\x00",
                    sizeof(OID_SHA256_RSA_SIG_HEX "\x05\x00") - 1);
            }
            psDynBufEndSequence(&algSeq);

            /* and the signature itself
               signature            BIT STRING */
            psDynBufBeginConstructedTag(&sigSeq, &algBits);
            psDynBufAppendChar(&algBits, 0); /* Num padding bits. */
            psDynBufAppendOctets(&algBits, sig, sigLen);
            psFree(sig, pool);
            psDynBufEndConstructedTag(&algBits, 0x03);

            /* Create certificate sequence (len == 1).
               certs [0] EXPLICIT SEQUENCE OF Certificate.

               Note: The sequence is omitted if certificate is not specified. */
            if (signingCert && signingCert->unparsedBin != NULL &&
                signingCert->binLen > 0)
            {
                psDynBuf_t certExplicit;
                psDynBuf_t certSeq;
                psDynBufBeginConstructedTag(&sigSeq, &certExplicit);
                psDynBufBeginSequence(&certExplicit, &certSeq);
                while (signingCert)
                {
                    psDynBufAppendOctets(&certSeq, signingCert->unparsedBin,
                        signingCert->binLen);
                    if ((infoFlags &
                         MATRIXSSL_WRITE_OCSP_REQUEST_SIGN_CERT_LIST) == 0)
                    {
                        break;
                    }
                    signingCert = signingCert->next;
                }
                psDynBufEndSequence(&certSeq);
                psDynBufEndConstructedTag(&certExplicit, 0xA0);
            }
            psDynBufEndSequence(&sigSeq);
            psDynBufEndConstructedTag(&sigExplicit, 0xA0);
        }
        else
        {
            /* Free allocated temporary resources */
            psDynBufUninit(&seq);
            return PS_UNSUPPORTED_FAIL;
        }
    }

    psDynBufEndSequence(&ocsp);
    return psDynBufDetachBuf(&seq, TBSRequestBuf);
}

#  ifdef PS_WRITE_OCSP_TBSREQUEST_OLD_API
/* TBSRequest ::= SEQUENCE {
   version             [0] EXPLICIT Version DEFAULT v1,
   requestorName       [1] EXPLICIT GeneralName OPTIONAL,
   requestList             SEQUENCE OF Request,
   requestExtensions   [2] EXPLICIT Extensions OPTIONAL }
 */
static int32_t psWriteOCSPTBSRequest(psPool_t *pool, psBuf_t *requestBuf,
    psBuf_t *TBSRequestBuf)
{
    int32_t requestBufLen;

    requestBufLen = (requestBuf->end - requestBuf->start);

    /* Currently not supporting any OPTIONAL parts and Version has a DEFAULT so
        we just need to add another outer SEQUENCE to wrap requestList that
        is passed in as the requestBuf param */
    requestBufLen += ASN_SEQUENCE_OH;

    TBSRequestBuf->start = TBSRequestBuf->end = TBSRequestBuf->buf =
                                                    psMalloc(pool, requestBufLen);
    if (TBSRequestBuf->start == NULL)
    {
        return PS_MEM_FAIL;
    }
    TBSRequestBuf->size = requestBufLen;

    /* Skip for the asnPrependSequence below */
    TBSRequestBuf->start = TBSRequestBuf->end += ASN_SEQUENCE_OH;

    /* Copy in the requestList portion */
    Memcpy(TBSRequestBuf->end, requestBuf->start,
        (requestBuf->end - requestBuf->start));
    TBSRequestBuf->end += (requestBuf->end - requestBuf->start);

    asnPrependSequence(TBSRequestBuf); /* CertID SEQUENCE */
    return PS_SUCCESS;
}
#  endif /* PS_WRITE_OCSP_TBSREQUEST_OLD_API */

/*
    requestList             SEQUENCE OF Request,

    Request ::= SEQUENCE {
            reqCert                     CertID,
            singleRequestExtensions [0] EXPLICIT Extensions OPTIONAL }

    CertID ::= SEQUENCE {
            hashAlgorithm           AlgorithmIdentifier,
            issuerNameHash          OCTET STRING, -- Hash of issuer's DN
            issuerKeyHash           OCTET STRING, -- Hash of issuer's public key
            serialNumber            CertificateSerialNumber }
 */
static int32_t psWriteOCSPRequest(psPool_t *pool, psX509Cert_t *cert,
    psX509Cert_t *certIssuer, psBuf_t *requestBuf)
{
    unsigned char *strings, *serialNumBuf = NULL;
    psBuf_t hashAlgBuf;
    int32_t oidLen, algIdLen, stringlen, serialNumLen, requestBufLen;

    oidLen = sizeof(sha1OID) / sizeof(int32);
    if (psWriteCertAlgorithmId(pool, &hashAlgBuf, sha1OID, oidLen, &algIdLen)
        < 0)
    {
        return PS_MEM_FAIL;
    }

    /* Room for two SHA1 hashes and OCTET_STRING overhead */
    if ((strings = psMalloc(pool, (20 + ASN_OCTET_STRING_OH) * 2)) == NULL)
    {
        psFree(hashAlgBuf.buf, pool);
        return PS_MEM_FAIL;
    }
    /* Returns how many bytes were written.  Moves out */

    /* OCSP requires SHA1 to be enabled which forces the issuerNameHash
        to be SHA1 based. */
    stringlen = asn1WriteOctetString(strings,
        (unsigned char *) certIssuer->subject.hash, SHA1_HASH_SIZE);
    stringlen += asn1WriteOctetString(strings + stringlen,
        certIssuer->sha1KeyHash, SHA1_HASH_SIZE);

    /* The serialNumber is from the subject cert that we want to have
        validated with this request */
    serialNumLen = cert->serialNumberLen;
    psWriteCertSerialNumber(pool, &serialNumBuf, cert->serialNumber,
        &serialNumLen);

    requestBufLen = serialNumLen + stringlen + algIdLen + (ASN_SEQUENCE_OH * 3);

    requestBuf->start = requestBuf->end = requestBuf->buf =
                                              psMalloc(pool, requestBufLen);
    if (requestBuf->start == NULL)
    {
        psFree(hashAlgBuf.buf, pool);
        psFree(strings, pool);
        psFree(serialNumBuf, pool);
        return PS_MEM_FAIL;
    }
    requestBuf->size = requestBufLen;

    /* Make room for a few prepended SEQUENCE */
    requestBuf->start = requestBuf->end += (ASN_SEQUENCE_OH * 3);

    /* Write CertID */
    Memcpy(requestBuf->end, hashAlgBuf.start, algIdLen);
    psFree(hashAlgBuf.buf, pool);
    requestBuf->end += algIdLen;

    Memcpy(requestBuf->end, strings, stringlen);
    requestBuf->end += stringlen;
    psFree(strings, pool);

    Memcpy(requestBuf->end, serialNumBuf, serialNumLen);
    requestBuf->end += serialNumLen;
    psFree(serialNumBuf, pool);


    asnPrependSequence(requestBuf); /* CertID SEQUENCE */
    asnPrependSequence(requestBuf); /* Request SEQUENCE */

    return PS_SUCCESS;
}

int32_t psOcspWriteNonceExtension(psPool_t *pool, psBuf_t *bufOut)
{
    int32_t rc;
    unsigned char ext_nonce[] = {
        0x30, 0x1f, 0x06, 0x09, 0x2b, 0x06,
        0x01, 0x05, 0x05, 0x07, 0x30, 0x01,0x02,  0x04,  0x12,  0x04,
        0x10,
        /* The bytes will be replaced with random. */
        0,    0,    0,    0,    0,    0,   0,     0,     0,     0,    0,0, 0, 0, 0, 0
    };

    rc = psGetPrng(NULL, ext_nonce + sizeof ext_nonce - 16, 16, NULL);
    if (rc != 16)
    {
        /* Clear bufOut. */
        (void) psBufFromData(pool, bufOut, NULL, 0);
        return rc;
    }

    return psBufFromData(pool, bufOut, ext_nonce, sizeof ext_nonce);
}

int32_t psOcspRequestWrite(psPool_t *pool, psX509Cert_t *cert,
    psX509Cert_t *certIssuer,
    unsigned char **request,
    uint32_t *requestLen,
    psOcspRequestWriteInfo_t *info_p)
{
    static psOcspRequestWriteInfo_t info = { 0 };
    psBuf_t reqNew = { NULL };
    psBuf_t requestBuf_tmp;
    psBuf_t requestBuf;
    psBuf_t nonceExt = { NULL };
    size_t requestSize;
    int32_t rc;
    psDynBuf_t requestBufs;
    psDynBuf_t requestBuf1;

    if (info_p == NULL)
    {
        info_p = &info;
    }

    /* Creates "requestList SEQUENCE OF Request" portion of TBSRequest */

    /* Start building SEQUENCE of Request */
    psDynBufInit(pool, &requestBufs, OCSP_REQUEST_DEFAULT_SIZE);
    psDynBufBeginSequence(&requestBufs, &requestBuf1);
    do
    {
        if (psWriteOCSPRequest(pool, cert, certIssuer, &requestBuf_tmp) < 0)
        {
            psDynBufUninit(&requestBufs);
            return PS_MEM_FAIL;
        }
        psDynBufAppendBuf(&requestBuf1, &requestBuf_tmp);
        psFree(requestBuf_tmp.buf, pool);
        if (cert->next &&
            (info_p->flags & MATRIXSSL_WRITE_OCSP_REQUEST_FLAG_CERT_LIST) > 0)
        {
            cert = cert->next;
        }
        else
        {
            cert = NULL;
        }
    }
    while (cert);
    psDynBufEndSequence(&requestBuf1);
    psDynBufDetachBuf(&requestBufs, &requestBuf);

    if ((info_p->flags & MATRIXSSL_WRITE_OCSP_REQUEST_FLAG_NONCE) != 0)
    {
        rc = psOcspWriteNonceExtension(pool, &nonceExt);
        if (rc != PS_SUCCESS)
        {
            psFree(requestBuf.buf, pool);
            return rc;
        }
    }
    psWriteOCSPTBSRequestNew(pool, info_p->flags,
        info_p->ocspRequestVersion,
        info_p->requesterId, &requestBuf,
        &nonceExt, info_p->requestExtensions,
        info_p->sign_oid,
        info_p->sign_key, info_p->sign_cert, &reqNew);

    /* Free allocated temporary resources */
    psFree(requestBuf.buf, pool);
    psFree(nonceExt.buf, pool);

    *request = psBufDetach(pool, &reqNew, &requestSize);
    *requestLen = (uint32) requestSize;
    if (!*request)
    {
        return PS_MEM_FAIL;
    }

    return PS_SUCCESS;
}

/* Older API: just one integer for flags (sufficient for no options or
   nonce option). */
int32_t psOcspRequestWriteOld(
    psPool_t *pool, psX509Cert_t *cert,
    psX509Cert_t *certIssuer, unsigned char **request, uint32_t *requestLen,
    int32_t flags)
{
    psOcspRequestWriteInfo_t info = { flags };

    return psOcspRequestWrite(pool, cert, certIssuer, request,
        requestLen, &info);
}

int32_t psOcspRequestWriteInfoSetRequestorId(
    psPool_t *pool,
    psOcspRequestWriteInfo_t *info,
    const char *str, size_t strLen, x509GeneralNameType_t type)
{
    psDynBuf_t buf;
    psDynBuf_t content;
    psBuf_t *newBuf;
    unsigned char tag;

    switch (type)
    {
    case GN_OTHER:
    case GN_EMAIL:
    case GN_DNS:
    case GN_X400:
    case GN_EDI:
    case GN_URI:
    case GN_IP:
    case GN_REGID:
        tag = ASN_CONTEXT_SPECIFIC | (unsigned char) (type);
        break;
    case GN_DIR:
        tag = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | (unsigned char) (type);
        break;
    default:
        /* Unsupported x509GeneralNameType_t. */
        return PS_FAILURE;
    }
    newBuf = psMalloc(pool, sizeof(*newBuf));
    if (newBuf == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(newBuf, 0, sizeof(*newBuf));
    psDynBufInit(pool, &buf, /* Initial buffer size guess */ 8 + strLen);
    psDynBufBeginConstructedTag(&buf, &content);
    psDynBufAppendOctets(&content, str, strLen);
    psDynBufEndConstructedTag(&content, tag);
    psDynBufDetachBuf(&buf, newBuf);
    if (newBuf->buf == NULL)
    {
        psFree(newBuf, pool);
        return PS_FAILURE;
    }

    info->requesterId = newBuf;
    return PS_SUCCESS;
}

void psOcspRequestWriteInfoFreeRequestorId(
    psPool_t *pool, psOcspRequestWriteInfo_t *info)
{
    if (info->requesterId)
    {
        psBufUninit(pool, info->requesterId);
        psFree(info->requesterId, pool);
        info->requesterId = NULL;
    }
}

int32_t psOcspRequestWriteInfoSetSigning(
    psOcspRequestWriteInfo_t *info_p,
    int32_t sign_oid,     /* designate algorithm to use for signing. */
    psPubKey_t *priv_key,
    psX509Cert_t *cert,
    int is_cert_chain)
{
    if (sign_oid == OID_SHA1_RSA_SIG ||
        sign_oid == OID_SHA256_RSA_SIG ||
        sign_oid == OID_SHA384_RSA_SIG ||
        sign_oid == OID_SHA512_RSA_SIG ||
        sign_oid == OID_SHA1_ECDSA_SIG ||
        sign_oid == OID_SHA256_ECDSA_SIG ||
        sign_oid == OID_SHA384_ECDSA_SIG ||
        sign_oid == OID_SHA512_ECDSA_SIG)
    {
        info_p->flags |= MATRIXSSL_WRITE_OCSP_REQUEST_SIGN;
        if (is_cert_chain)
        {
            info_p->flags |= MATRIXSSL_WRITE_OCSP_REQUEST_SIGN_CERT_LIST;
        }
        info_p->sign_oid = sign_oid;
        info_p->sign_key = priv_key;
        info_p->sign_cert = cert;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }
    return PS_SUCCESS;
}

/* Override version of OCSP request. */
extern void psOcspRequestWriteVersion(
    int version,
    psOcspRequestWriteInfo_t *info)
{
    info->ocspRequestVersion = version;
}

# endif /* USE_OCSP_REQUEST */

/**************************************************************/

/*
   Setter/getter API for psCertConfig_t.
 */

# define INIT_DN_BUF_SIZE 8192
# define INIT_NUM_DN 16

int32 psX509SetVersion(psPool_t *pool,
        psCertConfig_t *config,
        x509_cert_version version)
{
    if (version != x509_cert_v1 &&
            version != x509_cert_v2 &&
            version != x509_cert_v3)
    {
        return PS_ARG_FAIL;
    }

    config->version = version;

    /**/
    return PS_SUCCESS;
}

int32 psX509SetDNAttribute(psPool_t *pool,
    psCertConfig_t *config,
    const char *name,
    size_t name_len,
    const char *value,
    size_t value_len,
    int encoding)
{
    char *tmp;
    const char *iter;
    size_t illegal_char_count = 0;
    char *new_value = NULL;
    size_t new_value_len;
    size_t s, t;
    int32_t rc;

    if (encoding != ASN_UTF8STRING &&
        encoding != ASN_IA5STRING &&
        encoding != ASN_PRINTABLESTRING)
    {
        psTraceCrypto("Error: unsupported ASN.1 type. " \
                "Only UTF8String, ASN_IA5STRING and ASN_PRINTABLESTRING " \
                " are supported in DN AttributeValue encoding\n");
        rc = PS_UNSUPPORTED_FAIL;
        goto out_fail;
    }

    /* Double quote is not allowed in the value itself.
       Count occurrences so we can add escapes. */
    iter = value;
    while (iter < (value + value_len))
    {
        if (*iter == '\"')
        {
            illegal_char_count++;
        }
        iter++;
    }
    if (illegal_char_count > 0)
    {
        /* Create new string with the illegal characters escaped. */
        new_value_len = value_len + illegal_char_count;
        new_value = psMalloc(pool, new_value_len);
        if (new_value == NULL)
        {
            rc = PS_MEM_FAIL;
            goto out_fail;
        }
        s = 0;
        t = 0;
        iter = value;
        while (iter < (value + value_len))
        {
            if (*iter == '\"')
            {
                new_value[t++] = '\\';
            }
            new_value[t++] = value[s++];
            iter++;
        }
        value = new_value;
        value_len = new_value_len;
    }

    if (config->DNPairs == NULL)
    {
        config->DNPairs = psMalloc(pool, INIT_DN_BUF_SIZE);
        if (config->DNPairs == NULL)
        {
            rc = PS_MEM_FAIL;
            goto out_fail;
        }
        Memset(config->DNPairs, 0, INIT_DN_BUF_SIZE);

        config->DNPairsEncoding = psMalloc(pool,
                sizeof(config->DNPairsEncoding)*INIT_NUM_DN);
        if (config->DNPairsEncoding == NULL)
        {
            rc = PS_MEM_FAIL;
            goto out_fail;
        }
    }
    else
    {
        int32 need_space;

        need_space = name_len + value_len + 1 + 2 + 1;
        if ((config->DNPairsLen + need_space) > INIT_DN_BUF_SIZE)
        {
            config->DNPairs = psRealloc(config->DNPairs,
                config->DNPairsLen + INIT_DN_BUF_SIZE,
                pool);
            if (config->DNPairs == NULL)
            {
                rc = PS_MEM_FAIL;
                goto out_fail;
            }
        }
        if ((config->DNPairsNum + 1) > INIT_NUM_DN)
        {
            config->DNPairsEncoding = psRealloc(config->DNPairsEncoding,
                    (config->DNPairsNum + 1)*sizeof(config->DNPairsEncoding[0]),
                    pool);
            if (config->DNPairsEncoding == NULL)
            {
                rc = PS_MEM_FAIL;
                goto out_fail;
            }
        }
    }

    tmp = config->DNPairs;

    if (config->DNPairsLen > 0)
    {
        config->DNPairs += config->DNPairsLen;
    }

    Memcpy(config->DNPairs, name, name_len);
    config->DNPairs += name_len;
    config->DNPairsLen += name_len;
    config->DNPairsNum++;

    config->DNPairsEncoding[config->DNPairsNum - 1] = encoding;

    *(config->DNPairs) = '=';
    config->DNPairs++; config->DNPairsLen++;

    *(config->DNPairs) = '\"';
    config->DNPairs++; config->DNPairsLen++;

    Memcpy(config->DNPairs, value, value_len);
    config->DNPairs += value_len;
    config->DNPairsLen += value_len;

    *(config->DNPairs) = '\"';
    config->DNPairs++; config->DNPairsLen++;

    *(config->DNPairs) = ';';
    config->DNPairs++; config->DNPairsLen++;

    config->DNPairs = tmp;

    rc = PS_SUCCESS;

out_fail:
    if (new_value != NULL)
    {
        psFree(new_value, pool);
    }
    return rc;
}

int32 psX509SetSerialNum(psPool_t *pool,
    psCertConfig_t *config,
    unsigned char *serialNum,
    size_t serialNumLen)
{
    if (serialNumLen < 1)
    {
        return PS_ARG_FAIL;
    }

    Memcpy(config->serialNumBuf, serialNum, serialNumLen);
    config->serialNumLen = serialNumLen;

    return PS_SUCCESS;
}

int32 psX509SetValidDays(psPool_t *pool,
    psCertConfig_t *config,
    int32 validDays)
{
    config->validDays = validDays;

    return PS_SUCCESS;
}

int32 psX509SetValidNotBefore(psPool_t *pool,
        psCertConfig_t *config,
        const char *date,
        psSize_t date_len,
        int32 encoding)
{
    int32 rc;
    unsigned int opts;

    if (encoding == ASN_UTCTIME)
    {
        opts = PS_BROKENDOWN_TIME_IMPORT_2DIGIT_YEAR;
    }
    else if (encoding == ASN_GENERALIZEDTIME)
    {
        opts = 0;
    }
    else
    {
        psTraceIntCrypto("Invaliding encoding type: %d\n", encoding);
        return PS_ARG_FAIL;
    }

    config->notBefore = psMalloc(pool, sizeof(psBrokenDownTime_t));
    if (config->notBefore == NULL)
    {
        return PS_MEM_FAIL;
    }

    config->notBeforeEncoding = encoding;

    rc = psBrokenDownTimeImport(config->notBefore,
            date,
            date_len,
            opts);
    if (rc < 0)
    {
        psTraceCrypto("psBrokenDownTimeImport failed. " \
                "notBefore has invalid date format?\n");
        return rc;
    }

    return PS_SUCCESS;
}

int32 psX509SetValidNotAfter(psPool_t *pool,
        psCertConfig_t *config,
        const char *date,
        psSize_t date_len,
        int32 encoding)
{
    int32 rc;
    unsigned int opts;

    if (encoding == ASN_UTCTIME)
    {
        opts = PS_BROKENDOWN_TIME_IMPORT_2DIGIT_YEAR;
    }
    else if (encoding == ASN_GENERALIZEDTIME)
    {
        opts = 0;
    }
    else
    {
        psTraceIntCrypto("Invaliding encoding type: %d\n", encoding);
        return PS_ARG_FAIL;
    }

    config->notAfter = psMalloc(pool, sizeof(psBrokenDownTime_t));
    if (config->notAfter == NULL)
    {
        return PS_MEM_FAIL;
    }

    config->notAfterEncoding = encoding;

    /*
      Converting to psBrokenDownTime_t mostly because psBrokenDownTimeImport
      does a useful validity check on the date string.
    */
    rc = psBrokenDownTimeImport(config->notAfter,
            date,
            date_len,
            opts);
    if (rc < 0)
    {
        psTraceCrypto("psBrokenDownTimeImport failed. " \
                "notAfter has invalid date format?\n");
        return rc;
    }

    return PS_SUCCESS;
}

int32 psX509SetPublicKey(psPool_t *pool,
    psCertConfig_t *config,
    psPubKey_t *pk)
{
    config->publicKey = pk;

    return PS_SUCCESS;
}

int32 psX509SetCertHashAlg(psPool_t *pool,
    psCertConfig_t *config,
    int32 certAlg)
{
    if (certAlg != ALG_MD5 &&
        certAlg != ALG_SHA1 &&
        certAlg != ALG_SHA224 &&
        certAlg != ALG_SHA256 &&
        certAlg != ALG_SHA384 &&
        certAlg != ALG_SHA512)
    {
        psTraceCrypto("Unsupported certificate hash alg\n");
        return PS_UNSUPPORTED_FAIL;
    }

    config->certAlg = certAlg;

    return PS_SUCCESS;
}

/*
   The certificate extension setters take in a filled extension entry
   structs (e.g. a certificatePoliciesEntry_t.) From these, they
   create name-value string pairs, having the same format as config
   file entry lines (e.g. ("certPolicy1-id", "67810C010201")).
   Then they parse those pairs with the handleExtension API
   (e.g. handlePolicy()). The handleExtension API creates the actual
   extension structs, which will be encoded by e.g.
   psX509WriteSelfSignedCertMem.
 */

int32 psX509AddPolicy(psPool_t *pool,
    psCertConfig_t *config,
    certificatePoliciesEntry_t *entry)
{
    int32 rc;
    char name[256];
    char prefix[256] = { 0 };
    char unotice_prefix[256] = { 0 };
    const char *prefix_pre = "certPolicy";
    size_t prefix_pre_len = Strlen(prefix_pre);
    size_t prefix_len;
    const char *unotice_prefix_pre = "unotice";
    size_t unotice_prefix_pre_len = Strlen(unotice_prefix_pre);
    size_t unotice_prefix_len;
    int policy_index = entry->policyIndex;
    int unotice_index = entry->unoticeIndex;

    if (policy_index < 1)
    {
        psTraceCrypto("Policy index must start from 1\n");
        return PS_ARG_FAIL;
    }
    if (policy_index > 99)
    {
        psTraceCrypto("Maximum policy number limit (99) exceeded\n");
        return PS_ARG_FAIL;
    }

    /*
       Construct the policy entry prefix.
       This must be of the form "certPolicyX-", where X is the index
       of the policy.
     */
    Memcpy(prefix, prefix_pre, prefix_pre_len);
    Sprintf(prefix + prefix_pre_len, "%d", policy_index);
    if (policy_index < 10)
    {
        Memcpy(prefix + prefix_pre_len + 1, "-", 1);
    }
    else
    {
        Memcpy(prefix + prefix_pre_len + 2, "-", 1);
    }
    prefix_len = Strlen(prefix);

    /*
       Construct the UserNotice entry prefix.
       This must be of the form "certPolicyX-unoticeY-" where Y is the
       index of the UserNotice and X is the index of the policy.
     */
    Memcpy(unotice_prefix, prefix, prefix_len);
    Memcpy(unotice_prefix + prefix_len,
        unotice_prefix_pre, unotice_prefix_pre_len);
    Sprintf(unotice_prefix + prefix_len + unotice_prefix_pre_len,
        "%d", unotice_index);
    if (unotice_index < 10)
    {
        Memcpy(unotice_prefix + prefix_len + unotice_prefix_pre_len + 1,
            "-", 1);
    }
    else
    {
        Memcpy(unotice_prefix + prefix_len + unotice_prefix_pre_len + 2,
            "-", 1);
    }
    unotice_prefix_len = Strlen(unotice_prefix);

    if (config == NULL || entry == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    /* Policy OID is an obligatory field. */
    if (entry->policyOid != NULL && entry->policyOidLen != 0)
    {
        Memset(name, 0, sizeof(name));
        Strcpy(name, prefix);
        Strcpy(name + prefix_len, "id");
        rc = handlePolicy(pool, config,
            name,
            entry->policyOid,
            entry->policyOidLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    /* The PolicyQualifierInfo is either a CPS or a UserNotice. */
    if (entry->cps != NULL && entry->cpsLen != 0)
    {
        Memset(name, 0, sizeof(name));
        Strcpy(name, prefix);
        Strcpy(name + prefix_len, "cps");
        rc = handlePolicy(pool, config,
            name,
            entry->cps,
            entry->cpsLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    if (entry->unoticeOrganization != NULL && entry->unoticeOrganization)
    {
        if (entry->unoticeOrganizationEncoding == 0)   /* Default */
        {
            entry->unoticeOrganizationEncoding = ASN_UTF8STRING;
        }
        else if (entry->unoticeOrganizationEncoding != ASN_UTF8STRING)
        {
            psTraceCrypto("Unsupported unoticeOrganizationEncoding " \
                "only ASN_UTF8String is supported\n");
            return PS_UNSUPPORTED_FAIL;
        }
        Memset(name, 0, sizeof(name));
        Strcpy(name, unotice_prefix);
        Strcpy(name + unotice_prefix_len, "organization");
        rc = handlePolicy(pool, config,
            name,
            entry->unoticeOrganization,
            entry->unoticeOrganizationLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    if (entry->unoticeExplicitText != NULL && entry->unoticeExplicitText)
    {
        if (entry->unoticeExplicitTextEncoding == 0)   /* Default. */
        {
            entry->unoticeExplicitTextEncoding = ASN_UTF8STRING;
        }
        else if (entry->unoticeExplicitTextEncoding != ASN_UTF8STRING)
        {
            psTraceCrypto("Unsupported unoticeExplicitTextEncoding " \
                "only ASN_UTF8String is supported\n");
            return PS_UNSUPPORTED_FAIL;
        }
        Memset(name, 0, sizeof(name));
        Strcpy(name, unotice_prefix);
        Strcpy(name + unotice_prefix_len, "explicitText");
        rc = handlePolicy(pool, config,
            name,
            entry->unoticeExplicitText,
            entry->unoticeExplicitTextLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    if (entry->unoticeNumbersLen > 0)
    {
        int i = 0;
        int c = 0;
        char value[256] = { 0 };

        if (entry->unoticeNumbersLen > MAX_UNOTICE_NUMBERS)
        {
            psTraceIntCrypto("Too many noticeNumbers. Maximum is %d.\n",
                MAX_UNOTICE_NUMBERS);
            return PS_ARG_FAIL;
        }
        Memset(name, 0, sizeof(name));
        Strcpy(name, unotice_prefix);
        Strcpy(name + unotice_prefix_len, "noticeNumbers");
        c = Sprintf(value + c, "%d", entry->unoticeNumbers[i]);
        for (i = 1; i < entry->unoticeNumbersLen; i++)
        {
            c += Sprintf(value + c, ",");
            c += Sprintf(value + c, "%d", entry->unoticeNumbers[i]);
        }
        rc = handlePolicy(pool, config,
            name,
            value,
            Strlen(value));
        if (rc < 0)
        {
            return rc;
        }
    }

    return PS_SUCCESS;
}

int32 psX509SetConstraintRequireExplicitPolicy(psPool_t *pool,
    psCertConfig_t *config,
    int32_t value)
{
    int32 rc;
    char name[256];
    char strValue[256] = { 0 };
    const char *prefix = "policyConstraints-requireExplicitPolicy";

    if (config == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (value < 0)
    {
        psTraceCrypto("Value must be at least 1\n");
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    Memset(name, 0, sizeof(name));
    Strcpy(name, prefix);
    Sprintf(strValue, "%d", value);
    rc = handlePolicyConstraints(pool, config,
        name,
        strValue,
        Strlen(strValue));

    if (rc < 0)
    {
        return rc;
    }

    return PS_SUCCESS;
}

int32 psX509SetConstraintInhibitPolicyMappings(psPool_t *pool,
    psCertConfig_t *config,
    int32_t value)
{
    int32 rc;
    char name[256];
    char strValue[256] = { 0 };
    const char *prefix = "policyConstraints-inhibitPolicyMappings";

    if (config == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (value < 0)
    {
        psTraceCrypto("Value must be at least 1\n");
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    Memset(name, 0, sizeof(name));
    Strcpy(name, prefix);
    Sprintf(strValue, "%d", value);
    rc = handlePolicyConstraints(pool, config,
        name,
        strValue,
        Strlen(strValue));

    if (rc < 0)
    {
        return rc;
    }

    return PS_SUCCESS;
}

int32 psX509AddPolicyMapping(psPool_t *pool,
    psCertConfig_t *config,
    char *issuerDomainPolicy,
    size_t issuerDomainPolicyLen,
    char *subjectDomainPolicy,
    size_t subjectDomainPolicyLen)
{
    int32 rc;
    char name[256];
    char strValue[256] = { 0 };
    const char *prefix = "policyMappings";

    if (config == NULL || subjectDomainPolicy == NULL ||
        issuerDomainPolicy == NULL || issuerDomainPolicyLen < 1
        || subjectDomainPolicyLen < 1)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    Memset(name, 0, sizeof(name));
    Strcpy(name, prefix);
    Memcpy(strValue, subjectDomainPolicy, subjectDomainPolicyLen);
    Memcpy(strValue + subjectDomainPolicyLen, ":", 1);
    Memcpy(strValue + subjectDomainPolicyLen + 1,
        issuerDomainPolicy, issuerDomainPolicyLen);

    rc = handlePolicyMappings(pool, config,
        name,
        strValue,
        Strlen(strValue));

    if (rc < 0)
    {
        return rc;
    }

    return PS_SUCCESS;
}

int32 psX509AddAuthorityInfoAccess(psPool_t *pool,
    psCertConfig_t *config,
    authorityInfoAccessEntry_t *entry)
{
    int32 rc;
    char name[256];
    const char *prefix = "authorityInfoAccess-";
    size_t prefix_len = Strlen(prefix);

    if (config == NULL || entry == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    if (entry->ocsp != NULL && entry->ocspLen != 0)
    {
        Memset(name, 0, sizeof(name));
        Strcpy(name, prefix);
        Strcpy(name + prefix_len, "ocsp");
        rc = handleAuthorityInfoAccess(pool, config,
            name,
            entry->ocsp,
            entry->ocspLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    if (entry->caIssuers != NULL && entry->caIssuersLen != 0)
    {
        Memset(name, 0, sizeof(name));
        Strcpy(name, prefix);
        Strcpy(name + prefix_len, "caIssuers");
        rc = handleAuthorityInfoAccess(pool, config,
            name,
            entry->caIssuers,
            entry->caIssuersLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    return PS_SUCCESS;
}

/* Combined setter for both subjectAltName and issuerAltName. */
static
int32 setAltName(psPool_t *pool,
    psCertConfig_t *config,
    subjectAltNameEntry_t *entry,
    const char *prefix,
    int32 prefix_len)
{
    int32 rc;
    char name[256];

    if (config == NULL || entry == NULL)
    {
        return PS_ARG_FAIL;
    }

    psAssert(prefix != NULL && prefix_len > 0);

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    if (entry->rfc822Name != NULL)
    {
        Memset(name, 0, sizeof(name));
        Memcpy(name, prefix, prefix_len);
        Strcpy(name + prefix_len, "rfc822Name");
        rc = handleSubAltName(pool, config,
            name,
            entry->rfc822Name,
            entry->rfc822NameLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    if (entry->dNSName != NULL)
    {
        Memset(name, 0, sizeof(name));
        Memcpy(name, prefix, prefix_len);
        Strcpy(name + prefix_len, "dNSName");
        rc = handleSubAltName(pool, config,
            name,
            entry->dNSName,
            entry->dNSNameLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    if (entry->uniformResourceIdentifier != NULL)
    {
        Memset(name, 0, sizeof(name));
        Memcpy(name, prefix, prefix_len);
        Strcpy(name + prefix_len, "uniformResourceIdentifier");
        rc = handleSubAltName(pool, config,
            name,
            entry->uniformResourceIdentifier,
            entry->uniformResourceIdentifierLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    if (entry->iPAddress != NULL)
    {
        Memset(name, 0, sizeof(name));
        Memcpy(name, prefix, prefix_len);
        Strcpy(name + prefix_len, "iPAddress");
        rc = handleSubAltName(pool, config,
            name,
            entry->iPAddress,
            entry->iPAddressLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    if (entry->otherNameOIDDotNotation != NULL)
    {
        Memset(name, 0, sizeof(name));
        Memcpy(name, prefix, prefix_len);
        Strcpy(name + prefix_len, "otherNameOIDDotNotation");
        rc = handleSubAltName(pool, config,
            name,
            entry->otherNameOIDDotNotation,
            entry->otherNameOIDDotNotationLen);
        if (rc < 0)
        {
            return rc;
        }
    }
    else if (entry->otherName != NULL)
    {
        Memset(name, 0, sizeof(name));
        Memcpy(name, prefix, prefix_len);
        Strcpy(name + prefix_len, "otherName");
        rc = handleSubAltName(pool, config,
            name,
            entry->otherName,
            entry->otherNameLen);
        if (rc < 0)
        {
            return rc;
        }
    }

    return PS_SUCCESS;
}

int32 psX509AddSubjectAltName(psPool_t *pool,
    psCertConfig_t *config,
    subjectAltNameEntry_t *entry)
{
    const char *prefix = "subjectAltName-";
    int32 prefix_len = Strlen(prefix);

    return setAltName(pool, config, entry, prefix, prefix_len);
}

int32 psX509AddIssuerAltName(psPool_t *pool,
    psCertConfig_t *config,
    subjectAltNameEntry_t *entry)
{
    const char *prefix = "issuerAltName-";
    int32 prefix_len = Strlen(prefix);

    return setAltName(pool, config, entry, prefix, prefix_len);
}

int32 psX509AddKeyUsageBit(psPool_t *pool,
    psCertConfig_t *config,
    const char *usage)
{
    if (usage == NULL || config == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    if (!Strcmp(usage, "keyCertSign"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_KEY_CERT_SIGN;
    }
    else if (!Strcmp(usage, "keyAgreement"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_KEY_AGREEMENT;
    }
    else if (!Strcmp(usage, "crlSign"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_CRL_SIGN;
    }
    else if (!Strcmp(usage, "digitalSignature"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_DIGITAL_SIGNATURE;
    }
    else if (!Strcmp(usage, "keyEncipherment"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_KEY_ENCIPHERMENT;
    }
    else if (!Strcmp(usage, "dataEncipherment"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_DATA_ENCIPHERMENT;
    }
    else if (!Strcmp(usage, "nonRepudiation"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_NON_REPUDIATION;
    }
    else if (!Strcmp(usage, "encipherOnly"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_ENCIPHER_ONLY;
    }
    else if (!Strcmp(usage, "decipherOnly"))
    {
        config->ext->keyUsageFlags |= KEY_USAGE_DECIPHER_ONLY;
    }
    else
    {
        psTraceCrypto("Illegal key usage bit name");
        return PS_ARG_FAIL;
    }

    return PS_SUCCESS;
}

int32 psX509ClearKeyUsageBits(psPool_t *pool,
    psCertConfig_t *config)
{
    if (config == NULL || config->ext == NULL)
    {
        return PS_ARG_FAIL;
    }

    config->ext->keyUsageFlags = 0;

    return PS_SUCCESS;
}

int32 psX509AddExtendedKeyUsage(psPool_t *pool,
    psCertConfig_t *config,
    const char *usage)
{
    if (usage == NULL || config == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    if (!Strcmp(usage, "serverAuth"))
    {
        config->ext->ekuFlags |= EXT_KEY_USAGE_TLS_SERVER_AUTH;
    }
    else if (!Strcmp(usage, "clientAuth"))
    {
        config->ext->ekuFlags |= EXT_KEY_USAGE_TLS_CLIENT_AUTH;
    }
    else if (!Strcmp(usage, "codeSigning"))
    {
        config->ext->ekuFlags |= EXT_KEY_USAGE_CODE_SIGNING;
    }
    else
    {
        psTraceCrypto("Illegal extended key usage bit name");
        return PS_ARG_FAIL;
    }

    return PS_SUCCESS;
}

int32 psX509SetSubjectKeyId(psPool_t *pool,
    psCertConfig_t *config,
    unsigned char *id,
    size_t len)
{
    if (config == NULL || id == NULL)
    {
        return PS_ARG_FAIL;
    }

    /* Check sanity. Also, we need to be able to cast this
       to uint16_t when assigning to the len field of
       x509extSubjectKeyId_t. */
    if (len > 8192)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    if (config->ext->sk.id)
    {
        psFree(config->ext->sk.id, pool);
    }
    config->ext->sk.id = psMalloc(pool, len);
    if (config->ext->sk.id == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(config->ext->sk.id, 0, len);

    Memcpy(config->ext->sk.id, id, len);
    config->ext->sk.len = (uint16_t) len;

    return PS_SUCCESS;
}

int32 psX509SetBasicConstraintsCA(psPool_t *pool,
    psCertConfig_t *config,
    int caBit)
{
    if (config == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    if (caBit == 1)
    {
        config->ext->bc.cA = CA_TRUE;
    }
    else
    {
        config->ext->bc.cA = CA_FALSE;
    }

    return PS_SUCCESS;
}

int32 psX509SetBasicConstraintsPathLen(psPool_t *pool,
    psCertConfig_t *config,
    int pathLenConstraint)
{
    if (config == NULL || pathLenConstraint < 0)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    config->ext->bc.pathLenConstraint = pathLenConstraint;

    return PS_SUCCESS;
}

int32 psX509SetNetscapeComment(psPool_t *pool,
    psCertConfig_t *config,
    const char *comment,
    size_t commentLen)
{
    x509netscapeComment_t *nsCmt;

    if (config == NULL || comment == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (config->ext == NULL)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }

    if (config->ext->netscapeComment == NULL)
    {
        config->ext->netscapeComment =
            psMalloc(pool, sizeof(x509netscapeComment_t));
        if (config->ext->netscapeComment == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memset(config->ext->netscapeComment, 0,
            sizeof(x509netscapeComment_t));
    }

    nsCmt = config->ext->netscapeComment;
    nsCmt->commentLen = commentLen;
    if (nsCmt->comment == NULL)
    {
        nsCmt->comment = psMalloc(pool, commentLen + 1);
        if (nsCmt->comment == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memset(nsCmt->comment, 0, commentLen + 1);
    }

    Memcpy(config->ext->netscapeComment->comment,
        comment, commentLen);

    return PS_SUCCESS;
}

#define CHALLENGE_PASSWORD_ASN1DER_OVERHEAD 32 /* Estimated overhead. */
extern int32 psX509SetChallengePassword(psPool_t *pool,
        psCertConfig_t *config,
        const char *password,
        psSize_t passwordLen,
        psStringType_t passwordEncoding)
{
    if (config && !config->ext)
    {
        if (x509NewExtensions(&config->ext, pool) < 0)
        {
            return PS_MEM_FAIL;
        }
    }
    if (config && config->ext && config->ext->otherAttributes != NULL)
    {
        /* Already has other attributes => cannot add challenge password. */
        return PS_FAILURE;
    }
    if (config && config->ext)
    {
        const unsigned char challengePassOid[] =
            { 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x07 };
        psDynBuf_t sub;
        psDynBuf_t set;

        config->ext->otherAttributes =
            psMalloc(pool, sizeof(*config->ext->otherAttributes));
        if (!config->ext->otherAttributes)
        {
            return PS_FAILURE;
        }
        (void)psDynBufInit(pool, config->ext->otherAttributes,
                           passwordLen + CHALLENGE_PASSWORD_ASN1DER_OVERHEAD);
        psDynBufBeginSequence(config->ext->otherAttributes, &sub);
        psDynBufAppendAsn1Oid(&sub, challengePassOid, sizeof challengePassOid);
        psDynBufBeginConstructedTag(&sub, &set);
        psDynBufAppendAsn1TagGen(&set, passwordEncoding,
                                 (const unsigned char *)password, passwordLen);
        psDynBufEndConstructedTag(&set, 0x31);
        psDynBufEndSequence(&sub);

        if (config->ext->otherAttributes->err)
        {
            /* Note: memory failure should not occur as we added overhead,
               so this must be an encoding failure. */
            return PS_FAILURE;
        }
        return PS_SUCCESS;
    }
    return PS_FAILURE;
}

#endif /* USE_CERT_GEN */

/******************************************************************************/
