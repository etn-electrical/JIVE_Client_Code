/**
 *      @file    authEnvelopedDataCreate.c
 *
 *
 *      AuthEnvelopedData creation.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/
#include "matrixCmsApi.h"
#include "cryptoImpl.h"

#ifdef USE_CMS

# if defined(USE_MCMS_ATOMIC_AED_CREATE) || defined(USE_MCMS_STREAMING_AED_CREATE)

#  define mcmsPadLenPwr2(LEN, BLOCKSIZE) \
    BLOCKSIZE <= 1 ? (unsigned char) 0 : \
    (unsigned char) (BLOCKSIZE - ((LEN) &(BLOCKSIZE - 1)))


#  ifndef MCMS_EMPTY_AED_AUTH_ATTRIBS
/* Remember these are authAttributes for AED types defined in RFC 5083:

    Section 2.1 "the message-digest attribute SHOULD NOT be included."
 */
static int32 mcmsWriteAuthAttributes(psPool_t *pool, int32 contentType,
    cmsAuthEnvelopedData_t *aek, cmsAttributeSet_t *attribs,
    unsigned char **out, int32 *outLen)
{
    /* Add Some suggested attributes.  Enable user to pass some in
        NOTE: don't forget about the tweak to that one byte between
        what is hashed and what is ouput to DER */
    int32 oidLen;
    unsigned char oid[CM_MAX_OID_LEN];
    cmsAttributeSet_t *attrib = attribs;

    /* Writing the one suggested attribute.  Find the end if user had any */
    while (attrib->data != NULL)
    {
        attrib = attrib->next;
    }
    /* Attrib is a Content-Type with PKCS7_DATA OID */
    mcmsGetPkcsOidFromId(CMS_PKCS9_CONTENT_TYPE, &oid[0], &oidLen);
    attrib->oidLen = oidLen + asn1TLOverhead(oidLen);
    asnWriteOidChars(attrib->oid, oid, oidLen);

    mcmsGetPkcsOidFromId(contentType, &oid[0], &oidLen);
    attrib->dataLen = oidLen + asn1TLOverhead(oidLen);

    if ((attrib->data = psMalloc(pool, attrib->dataLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    asnWriteOidChars(attrib->data, oid, oidLen);

    if (mcmsMoveAttribToDER(pool, attribs, out, outLen) < 0)
    {
        return PS_MEM_FAIL;
    }
    aek->authAttributes = *out;
    aek->authAttributesLen = *outLen;
    return PS_SUCCESS;
}
#  endif

static int32 prepareAuthEnvKeyAgreeWrite(psPool_t *pool,
    const psPubKey_t *privKey, const psX509Cert_t *recipientCert,
    const int32 keyMethod, const int32 encryptMethod,
    const int32 wrapMethod, const int32 keyAgreeScheme,
    cmsAuthEnvelopedData_t *authEncryptKey,
    const unsigned char authEncryptKeyMat_in[MCMS_MAX_KEY_MAT_GEN],
    const int32 flags)
{
    psEccKey_t *eccKey;
    unsigned char secret[MCMS_MAX_ECKA];
    unsigned char wrapKey[32];       /* AES-256 max */
    uint32_t hashLen, wrapLen;
    psSize_t secretLen;
    unsigned char authEncryptKeyMat[MCMS_MAX_KEY_MAT_GEN];

    Memcpy(authEncryptKeyMat, authEncryptKeyMat_in, MCMS_MAX_KEY_MAT_GEN);
    if (wrapMethod == MCMS_AES128_WRAP)
    {
        authEncryptKey->wrapMethod = OID_AES_128_WRAP;
        wrapLen = 16;
    }
    else if (wrapMethod == MCMS_AES192_WRAP)
    {
        authEncryptKey->wrapMethod = OID_AES_192_WRAP;
        wrapLen = 24;
    }
    else if (wrapMethod == MCMS_AES256_WRAP)
    {
        authEncryptKey->wrapMethod = OID_AES_256_WRAP;
        wrapLen = 32;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    if (keyAgreeScheme == MCMS_DH_X963KDF_SHA256)
    {
        authEncryptKey->keyAgreeScheme = OID_DHSINGLEPASS_STDDH_SHA256KDF_SCHEME;
        hashLen = SHA256_HASH_SIZE;
    }
    else if (keyAgreeScheme == MCMS_DH_X963KDF_SHA384)
    {
        authEncryptKey->keyAgreeScheme = OID_DHSINGLEPASS_STDDH_SHA384KDF_SCHEME;
        hashLen = SHA384_HASH_SIZE;
    }
    else if (keyAgreeScheme == MCMS_DH_X963KDF_SHA512)
    {
        authEncryptKey->keyAgreeScheme = OID_DHSINGLEPASS_STDDH_SHA512KDF_SCHEME;
        hashLen = SHA512_HASH_SIZE;
    }
    else if ( keyAgreeScheme == MCMS_ECKA_X963KDF_SHA256)
    {
        authEncryptKey->keyAgreeScheme = OID_ECKA_EG_X963KDF_SHA256;
        hashLen = SHA256_HASH_SIZE;
    }
    else if (keyAgreeScheme == MCMS_ECKA_X963KDF_SHA384)
    {
        authEncryptKey->keyAgreeScheme = OID_ECKA_EG_X963KDF_SHA384;
        hashLen = SHA384_HASH_SIZE;
    }
    else if (keyAgreeScheme == MCMS_ECKA_X963KDF_SHA512)
    {
        authEncryptKey->keyAgreeScheme = OID_ECKA_EG_X963KDF_SHA512;
        hashLen = SHA512_HASH_SIZE;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    if (encryptMethod == MCMS_AES128_GCM)
    {
        authEncryptKey->type = MCMS_AES_GCM_TYPE;
        authEncryptKey->encryptMethod = OID_AES_128_GCM;
        authEncryptKey->keyLen = 16;
    }
    else if (encryptMethod == MCMS_AES192_GCM)
    {
        authEncryptKey->type = MCMS_AES_GCM_TYPE;
        authEncryptKey->encryptMethod = OID_AES_192_GCM;
        authEncryptKey->keyLen = 24;
    }
    else if (encryptMethod == MCMS_AES256_GCM)
    {
        authEncryptKey->type = MCMS_AES_GCM_TYPE;
        authEncryptKey->encryptMethod = OID_AES_256_GCM;
        authEncryptKey->keyLen = 32;

        /* The CMAC modes below use the single AES_CBC_CMAC OID which is stored
            in the authMethod member */
    }
    else if (encryptMethod == MCMS_AES128_CBC_CMAC)
    {
        authEncryptKey->type = MCMS_AES_CBC_CMAC_TYPE;
        authEncryptKey->encryptMethod = OID_AES_128_CBC;
        authEncryptKey->authMethod = OID_AES_CBC_CMAC_128;
        authEncryptKey->keyLen = 16;
    }
    else if (encryptMethod == MCMS_AES192_CBC_CMAC)
    {
        authEncryptKey->type = MCMS_AES_CBC_CMAC_TYPE;
        authEncryptKey->encryptMethod = OID_AES_192_CBC;
        authEncryptKey->authMethod = OID_AES_CBC_CMAC_192;
        authEncryptKey->keyLen = 24;
    }
    else if (encryptMethod == MCMS_AES256_CBC_CMAC)
    {
        authEncryptKey->type = MCMS_AES_CBC_CMAC_TYPE;
        authEncryptKey->encryptMethod = OID_AES_256_CBC;
        authEncryptKey->authMethod = OID_AES_CBC_CMAC_256;
        authEncryptKey->keyLen = 32;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    if (authEncryptKey->type == MCMS_AES_GCM_TYPE)
    {
        authEncryptKey->ivLen = 12;
        authEncryptKey->macLen = MCMS_GCM_TAG_LEN;
    }
    else if (authEncryptKey->type == MCMS_AES_CBC_CMAC_TYPE)
    {
        authEncryptKey->ivLen = 16;
        authEncryptKey->macLen = 16;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    if (authEncryptKey->type == MCMS_AES_GCM_TYPE)
    {
        psAssert(authEncryptKey->keyLen + authEncryptKey->ivLen
            <= MCMS_MAX_KEY_MAT_GEN);

        Memcpy(authEncryptKey->key, authEncryptKeyMat, authEncryptKey->keyLen);
        Memcpy(authEncryptKey->iv, authEncryptKeyMat +
            (authEncryptKey->keyLen * 2), authEncryptKey->ivLen);
        /* psTraceBytes("enc key", authEncryptKey->key, authEncryptKey->keyLen); */
        /* psTraceBytes("iv", authEncryptKey->iv, authEncryptKey->ivLen); */
    }
    else if (authEncryptKey->type == MCMS_AES_CBC_CMAC_TYPE)
    {
        /* Grab the encrypt key and the mac key contiguous here so the key wrap
            can grab them both in one pass */
        psAssert((authEncryptKey->keyLen * 2) + authEncryptKey->ivLen
            <= MCMS_MAX_KEY_MAT_GEN);
        Memcpy(authEncryptKey->key, authEncryptKeyMat, authEncryptKey->keyLen);
        Memcpy(authEncryptKey->macKey,
            authEncryptKeyMat + authEncryptKey->keyLen, authEncryptKey->keyLen);
#  ifndef MCMS_EMPTY_CBC_CMAC_PARAMS
        Memcpy(authEncryptKey->iv,
            authEncryptKeyMat + (authEncryptKey->keyLen * 2),
            authEncryptKey->ivLen);
#  else
        /* Custom spec indicates the IV is 0 for CBC_CMAC mode */
        Memset(authEncryptKey->iv, 0x0, authEncryptKey->ivLen);
#  endif
    }
    else
    {
#  ifdef USE_RFC_6476
        /* RFC 6476 taking over here.  The exchanged key is only the master
            secret that will be used to derive the encryption and authentication
            keys. We will always use the 256-bit version of authEnc (master)

            Section 4. "The default PRF is [PBKDF2], which in turn has a default
            PRF algorithm of HMAC-SHA1.

            Use the salt as defined in RFC 6476 but when it comes to writing out
            the authEnc algorithm ID it says to leave the salt parameter
            empty (guess that is because two different known salt values are
            used) */
        psPkcs5Pbkdf2(authEncryptKeyMat, MCMS_MASTER_SECRET_LEN,
            (unsigned char *) "encryption", 10, 1, authEncryptKey->key,
            authEncryptKey->keyLen);
        psPkcs5Pbkdf2(authEncryptKeyMat, MCMS_MASTER_SECRET_LEN,
            (unsigned char *) "authentication", 14, 1, authEncryptKey->macKey,
            16);

        /* IV can just be pulled from the authEncryptKeyMat raw.  Just
            grab 32 bytes into it so there is no overlap with master */
        Memcpy(authEncryptKey->iv, authEncryptKeyMat + MCMS_MASTER_SECRET_LEN,
            authEncryptKey->ivLen);

        /* psTraceBytes("mac key", authEncryptKey->cmacKey, authEncryptKey->keyLen); */
#  else
        return PS_UNSUPPORTED_FAIL;
#  endif
    }

    if (keyMethod == MCMS_AED_KEY_AGREE_METHOD)
    {
        /* Need a KEK */
        if (recipientCert->pubKeyAlgorithm == OID_ECDSA_KEY_ALG)
        {
            secretLen = MCMS_MAX_ECKA;
            eccKey = (psEccKey_t *) &recipientCert->publicKey.key.ecc;
            /* Will the originator key be static or DHE? */
            if (flags & MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY)
            {
                if (psEccNewKey(pool, &authEncryptKey->eccKey,
                        recipientCert->publicKey.key.ecc.curve) < 0)
                {
                    return PS_MEM_FAIL;
                }
                if (psEccGenKey(pool, authEncryptKey->eccKey,
                        recipientCert->publicKey.key.ecc.curve, NULL) < 0)
                {
                    psTraceCrypto("ECC DHE key generation failed\n");
                    return PS_FAILURE;
                }
                if (psEccGenSharedSecret(pool, authEncryptKey->eccKey, eccKey,
                        secret, &secretLen, NULL) < 0)
                {
                    psTraceCrypto("Couldn't generate shared secret\n");
                    return PS_FAILURE;
                }
            }
            else
            {
                /* Static */
                if (psEccGenSharedSecret(pool, &privKey->key.ecc, eccKey,
                        secret, &secretLen, NULL) < 0)
                {
                    psTraceCrypto("Couldn't generate shared secret\n");
                    return PS_FAILURE;
                }
            }

            psX963KeyDerivation(hashLen, secret, secretLen, wrapKey, wrapLen);

            /* kek member is really the encrypted encryptedKey */
            if (authEncryptKey->type == MCMS_AES_GCM_TYPE)
            {
                psAesWrap(wrapKey, wrapLen, authEncryptKey->key,
                    authEncryptKey->keyLen, authEncryptKey->eKey,
                    &wrapLen);
            }
            else if (authEncryptKey->type == MCMS_AES_CBC_CMAC_TYPE)
            {
                /* Wrap the encryption key and cmac key (same size) */
                psAesWrap(wrapKey, wrapLen, authEncryptKeyMat,
                    authEncryptKey->keyLen * 2, authEncryptKey->eKey,
                    &wrapLen);
            }
            else
            {
                /* Send only the master secret.  Keys are derived */
                psAesWrap(wrapKey, wrapLen, authEncryptKeyMat,
                    MCMS_MASTER_SECRET_LEN, authEncryptKey->eKey,
                    &wrapLen);
            }
            psAssert(wrapLen <= 0xFFFF);
            authEncryptKey->eKeyLen = (uint16_t) wrapLen;
        }
        else
        {
            psTraceCrypto("Only ECDSA supported in KeyAgree\n");
            return PS_UNSUPPORTED_FAIL;
        }
    }
    else
    {
        psTraceCrypto("Only MCMS_AED_KEY_AGREE_METHOD supported\n");
        return PS_UNSUPPORTED_FAIL;
    }

    /* Start the key to make sure there will be no problems with it */
    if (authEncryptKey->type == MCMS_AES_GCM_TYPE)
    {
        /* psTraceBytes("INIT GCM WITH KEY", authEncryptKey->key, authEncryptKey->keyLen); */
        if (psAesInitGCM(&authEncryptKey->ctx.aesgcm, authEncryptKey->key,
                authEncryptKey->keyLen) < 0)
        {
            psTraceCrypto("Couldn't initialize AES_GCM key\n");
            return PS_FAILURE;
        }
    }
    else if (authEncryptKey->type == MCMS_AES_CBC_CMAC_TYPE)
    {
        if (psCmacInit(authEncryptKey->macKey, authEncryptKey->keyLen,
                &authEncryptKey->cmacCtx) < 0)
        {
            return PS_FAILURE;
        }
        if (psAesInitCBC(&authEncryptKey->ctx.aes, authEncryptKey->iv,
                authEncryptKey->key, authEncryptKey->keyLen,
                PS_AES_ENCRYPT) < 0)
        {
            psTraceCrypto("Couldn't initialize AES_GCM key\n");
            return PS_FAILURE;
        }
    }

    return PS_SUCCESS;
}

static void writePad(unsigned char *p, unsigned char padLen)
{
    unsigned char c = padLen;

    while (c-- > 0)
    {
        *p++ = padLen;
    }
}

static int mcmsWriteContentEncAlg(psPool_t *pool,
    cmsAuthEnvelopedData_t *authEncryptKey, unsigned char **out,
    psSize_t *outLen)
{
    unsigned char encryptAlgOid[CM_MAX_OID_LEN];

#  ifdef USE_RFC_6476
    unsigned char authAlgOid[CM_MAX_OID_LEN];
    unsigned char prf[CM_MAX_OID_LEN];
    unsigned char authEnc[CM_MAX_OID_LEN];
    int32 authEncLen, authEncOidLen, prfLen, prfOidLen, symLen;
    int32 encryptAlgOidLen, authAlgOidLen, prfTotLen, symTotLen;
    int32 authAlgTotLen, authEncTotLen;
#  endif
    unsigned char *p, *start;
    psSize_t ivLen, ivSLen = 0, encryptAlgLen, authAlgLen, eaOidLen;


    /* Length calculation, malloc, and write */
    if (authEncryptKey->type == MCMS_AES_CBC_CMAC_TYPE)
    {
#  ifndef MCMS_EMPTY_CBC_CMAC_PARAMS
        /* CBC-CMAC-Param ::= SEQUENCE {
            aes-iV OCTET STRING
            aes-MacLen INTEGER (12 | 13 | 14 | 15 | 16) DEFAULT 16 } */
        ivSLen = authEncryptKey->ivLen + asn1TLOverhead(authEncryptKey->ivLen) +
                 1 + asn1TLOverhead(1);
        ivLen = ivSLen + asn1TLOverhead(ivSLen);
#  else
        /* Landis spec says no parameters which means no IV */
        ivLen = 0;
#  endif

        /* For the AES-CBC-CMAC enc + auth pair a single OID has been defined
            so the ContentEncryptionAlgorithm is just that single OID rather
            than the id-alg-authEnc-256 from RFC 6476.  In this case,
            we've stored that OID in the "authMethod" member */
        mcmsGetSymOidFromId(authEncryptKey->authMethod, &encryptAlgOid[0],
            &eaOidLen);

        authAlgLen = ivLen + eaOidLen + asn1TLOverhead(eaOidLen);
        encryptAlgLen = authAlgLen + asn1TLOverhead(authAlgLen);
    }
    else if (authEncryptKey->type == MCMS_AES_GCM_TYPE)
    {
        /* GCMParameters ::= SEQUENCE {
            aes-nonce        OCTET STRING, -- recommended size is 12 octets
            aes-ICVlen       AES-GCM-ICVlen DEFAULT 12 }

           AES-GCM-ICVlen ::= INTEGER (12 | 13 | 14 | 15 | 16) */
        ivSLen = authEncryptKey->ivLen + asn1TLOverhead(authEncryptKey->ivLen) +
                 1 + asn1TLOverhead(1);
        ivLen = ivSLen + asn1TLOverhead(ivSLen);

        /* For GCM, the ContentEncryptionAlgorithm is simply just the OID */
        mcmsGetSymOidFromId(authEncryptKey->encryptMethod, &encryptAlgOid[0],
            &eaOidLen);

        authAlgLen = ivLen + eaOidLen + asn1TLOverhead(eaOidLen);
        encryptAlgLen = authAlgLen + asn1TLOverhead(authAlgLen);
    }
    else
    {
#  ifdef USE_RFC_6476
        /* Nobody is using this currently, but this is the way a standard
            AED would be written if using a single encryption OID and seperate
            single authentication OID */
        /* Using RFC 6476 to write out the authEnc OID and sub-OIDs

            id-smime OBJECT IDENTIFIER ::= { iso(1) member-body(2)
                us(840) rsadsi(113549) pkcs(1) pkcs9(9) 16 }

            id-alg  OBJECT IDENTIFIER ::= { id-smime 3 }

            id-alg-authEnc-256 OBJECT IDENTIFIER ::= { id-alg 16 }

            The algorithm parameters are as follows:

                AuthEncParams ::= SEQUENCE {
                    prfAlgorithm   [0] AlgorithmIdentifier DEFAULT PBKDF2,
                    encAlgorithm       AlgorithmIdentifier,
                    macAlgorithm       AlgorithmIdentifier
                }
         */

        /* Start with parameters so we know how big the parameters are for
            the top level OID.  Start with hardcoded default PRF per RFC 6476

            found these PBKDF2 params in RFC 5911 (a CMS ASN.1 resource)

            PBKDF2-params ::= SEQUENCE {
                salt CHOICE {
                    specified OCTET STRING,
                    otherSource PBKDF2-SaltSourcesAlgorithmIdentifier },
                iterationCount INTEGER (1..MAX),
                keyLength INTEGER (1..MAX) OPTIONAL,
                prf PBKDF2-PRFsAlgorithmIdentifier DEFAULT defaultPBKDF2
            }

            defaultPBKDF2 PBKDF2-PRFsAlgorithmIdentifier ::=
                { algorithm alg-hMAC-SHA1.&id, parameters NULL:NULL }

            When using the default HMAC-SHA1 "The 'salt' parameter
            MUST be an empty (zero-length) string, and the 'iterationCount'
            parameter MUST be one, since these values aren't used in the PRF
            process.  In their encoded form as used for the PBKDF2-params,
            these two parameters have the value 08 00 02 01 01."

            Do not understand the 8 in the salt portion of the 5 bytes above.
            Going to change that to 4 for an empty OCTET_STRING
         */
        mcmsGetOidPBKDF2(&prf[0], &prfOidLen);
        prfLen = prfOidLen + asn1TLOverhead(prfOidLen) + 5 +
                 asn1TLOverhead(5);                  /* OID oh +5 params w/ SEQ oh */
        prfTotLen = prfLen + asn1TLOverhead(prfLen); /* outer SEQ oh */
        encryptAlgLen = prfTotLen;

        /*      Enc alg
            This ASN.1 assumes parameters are a single IV OCTET STRING.)
         */
        ivLen = authEncryptKey->ivLen + asn1TLOverhead(authEncryptKey->ivLen);
        symLen = ivLen;
        mcmsGetSymOidFromId(authEncryptKey->encryptMethod, &encryptAlgOid[0],
            &encryptAlgOidLen);
        symLen += encryptAlgOidLen + asn1TLOverhead(encryptAlgOidLen); /* OID oh */
        symTotLen = symLen + asn1TLOverhead(symLen);                   /* SEQ oh */
        encryptAlgLen += symTotLen;

        /* Auth alg */
        mcmsGetSymOidFromId(authEncryptKey->authMethod, &authAlgOid[0],
            &authAlgOidLen);
        authAlgLen = authAlgOidLen + asn1TLOverhead(authAlgOidLen);
        authAlgTotLen = authAlgLen + asn1TLOverhead(authAlgLen);
        encryptAlgLen += authAlgTotLen;

        /* Top level OID per RFC 6476 */
        mcmsGetOidAuthEnc(&authEnc[0], &authEncOidLen);
        authEncLen = authEncOidLen + asn1TLOverhead(authEncOidLen); /* OID oh */
        authEncTotLen = authEncLen + asn1TLOverhead(authEncLen +
            +authAlgTotLen + symTotLen + prfTotLen);

        /* SEQ over the entire parameters */
        encryptAlgLen += authEncTotLen + asn1TLOverhead(authEncTotLen);
#  else
        return PS_UNSUPPORTED_FAIL;
#  endif
    }

    start = p = psMalloc(pool, encryptAlgLen);
    if (start == NULL)
    {
        return PS_MEM_FAIL;
    }

    /* CMAC and GCM modes wouldend up looking identical as written because
        the OID parameters are same as defined but this EMPTY_CBC define
        is customer specific so keeping them seperate for now */
    if (authEncryptKey->type == MCMS_AES_CBC_CMAC_TYPE)
    {
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, authAlgLen);
        p += asnWriteOidChars(p, encryptAlgOid, eaOidLen);
#  ifndef MCMS_EMPTY_CBC_CMAC_PARAMS
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, ivSLen);
        *p = ASN_OCTET_STRING; p++;
        p += asnHelpWriteLength(p, authEncryptKey->ivLen);
        Memcpy(p, authEncryptKey->iv, authEncryptKey->ivLen);
        p += authEncryptKey->ivLen;
        *p = ASN_INTEGER; p++;
        p += asnHelpWriteLength(p, 1);
        *p = authEncryptKey->macLen & 0xFF; p++;
#  endif
    }
    else if (authEncryptKey->type == MCMS_AES_GCM_TYPE)
    {
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, authAlgLen);
        p += asnWriteOidChars(p, encryptAlgOid, eaOidLen);
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, ivSLen);
        *p = ASN_OCTET_STRING; p++;
        p += asnHelpWriteLength(p, authEncryptKey->ivLen);
        Memcpy(p, authEncryptKey->iv, authEncryptKey->ivLen);
        p += authEncryptKey->ivLen;
        *p = ASN_INTEGER; p++;
        p += asnHelpWriteLength(p, 1);
        *p = authEncryptKey->macLen & 0xFF; p++;
    }
    else
    {
#  ifdef USE_RFC_6476
        /* RFC 6476 again.  Top level 256-bit master secret authEnc OID */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        /* Length is the parameters which is the other 3 OIDs */
        p += asnHelpWriteLength(p,
            encryptAlgLen - asn1TLOverhead(encryptAlgLen));
        p += asnWriteOidChars(p, authEnc, authEncOidLen);

        /* The SEQUENCE around the parameters */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p,  authAlgTotLen + symTotLen + prfTotLen);

        /* prfAlgorithm */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, prfLen);
        p += asnWriteOidChars(p, prf, prfOidLen);
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, 5);
        /* 04 00 02 01 01 - Empty salt and iteration count 1 */
        *p = 0x4; p++;
        *p = 0x0; p++;
        *p = 0x2; p++;
        *p = 0x1; p++;
        *p = 0x1; p++;

        /* encAlgorithm w/ IV param */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, symLen);
        p += asnWriteOidChars(p, encryptAlgOid, encryptAlgOidLen);
        *p = ASN_OCTET_STRING; p++;
        p += asnHelpWriteLength(p, authEncryptKey->ivLen);
        Memcpy(p, authEncryptKey->iv, authEncryptKey->ivLen);
        p += authEncryptKey->ivLen;

        /* macAlgorithm */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, authAlgLen);
        p += asnWriteOidChars(p, authAlgOid, authAlgOidLen);
#  endif /* RFC_6476 - no need for else case.  will have been caught above */
    }

    /* Confirm length is exactly what we calculated */
    psAssert((int32) (p - start) == encryptAlgLen);

    *out = start;
    *outLen = encryptAlgLen;
    return PS_SUCCESS;
}


#  ifdef USE_MCMS_ATOMIC_AED_CREATE
/*
    Writes this:

    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,

    OriginatorInfo ::= SEQUENCE {
        certs [0] IMPLICIT CertificateSet OPTIONAL,
        crls [1] IMPLICIT RevocationInfoChoices OPTIONAL }
 */
static int32 mcmsWriteOriginatorInfo(psPool_t *pool, const psX509Cert_t *cert,
    unsigned char **out, psSize_t *outLen)
{
    int32 toiLen, coiLen;
    unsigned char *p, *start;

    *outLen = 0;
    *out = NULL;

    if (cert->unparsedBin == NULL)
    {
        psTraceCrypto("Cert must be parsed with CERT_STORE_UNPARSED_BUFFER\n");
        return PS_ARG_FAIL;
    }

    coiLen = cert->binLen + asn1TLOverhead(cert->binLen); /* IMPLICIT SET */
    toiLen = coiLen + asn1TLOverhead(coiLen);             /* IMPLICIT SEQUENCE */

    if ((p = psMalloc(pool, toiLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }

    /* Doing the write */
    start = p;

    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
    p += asnHelpWriteLength(p, coiLen);

    /* CertificateSet ::= SET OF CertificateChoices */
    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
    p += asnHelpWriteLength(p, cert->binLen);
    Memcpy(p, cert->unparsedBin, cert->binLen);
    p += cert->binLen;

    /* sanity */
    coiLen = (int32) (p - start);
    psAssert(coiLen == toiLen);

    *out = start;
    *outLen = coiLen;

    return PS_SUCCESS;
}

/*
    RecipientInfos ::= SET SIZE (1..MAX) OF RecipientInfo

     RecipientInfo ::= CHOICE {
        ktri KeyTransRecipientInfo,
        kari [1] KeyAgreeRecipientInfo,
        kekri [2] KEKRecipientInfo,
        pwri [3] PasswordRecipientinfo,
        ori [4] OtherRecipientInfo }


    KeyAgreeRecipientInfo ::= SEQUENCE {
        version CMSVersion,  -- always set to 3
        originator [0] EXPLICIT OriginatorIdentifierOrKey,
        ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
        keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
        recipientEncryptedKeys RecipientEncryptedKeys }

      OriginatorIdentifierOrKey ::= CHOICE {
        issuerAndSerialNumber IssuerAndSerialNumber,
        subjectKeyIdentifier [0] SubjectKeyIdentifier,
        originatorKey [1] OriginatorPublicKey }

      OriginatorPublicKey ::= SEQUENCE {
        algorithm AlgorithmIdentifier,
        publicKey BIT STRING }

      RecipientEncryptedKeys ::= SEQUENCE OF RecipientEncryptedKey

      RecipientEncryptedKey ::= SEQUENCE {
        rid KeyAgreeRecipientIdentifier,
        encryptedKey EncryptedKey }

      KeyAgreeRecipientIdentifier ::= CHOICE {
        issuerAndSerialNumber IssuerAndSerialNumber,
        rKeyId [0] IMPLICIT RecipientKeyIdentifier }

      RecipientKeyIdentifier ::= SEQUENCE {
        subjectKeyIdentifier SubjectKeyIdentifier,
        date GeneralizedTime OPTIONAL,
        other OtherKeyAttribute OPTIONAL }

      SubjectKeyIdentifier ::= OCTET STRING */
static int32 mcmsWriteKeyAgreeRecipientInfo(psPool_t *pool,
    cmsAuthEnvelopedData_t *aek, const psX509Cert_t *myCert,
    const psX509Cert_t *recipientCert, unsigned char **out, psSize_t *outLen,
    int32 flags)
{
    int32 tLen, cLen, sLen, originatorLen, keyEncryptAlgLen, rId;
    int32 origId;
    psSize_t keyWrapAlgLen, keyWrapOidLen, keyEncOidLen;
    psSize_t recipEncLen, recipSEncLen, recipKeyIdLen, originatorSLen;
    psSize_t recipKeyOctIdLen, origPubKeyIdLen, oidLen = 0;
    psSize_t eccKeyLen;
    unsigned char *p, *start;
    unsigned char keyAgreeId[CM_MAX_OID_LEN];
    unsigned char keyWrapId[CM_MAX_OID_LEN];
    unsigned char origPubKeyId[CM_MAX_OID_LEN];
    psEccKey_t *eccKey;

    *outLen = 0;
    *out = NULL;

    /*  Recipient information using key agreement is represented in the type
        KeyAgreeRecipientInfo.  Each instance of KeyAgreeRecipientInfo will
        transfer the content-encryption key to one or more recipients that
        use the same key agreement algorithm and domain parameters for that
        algorithm. */

    /* Origintator is used to locate the public key. */
    origId = originatorLen = 0;
    if (flags & MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID)
    {
        if (myCert == NULL)
        {
            psTraceCrypto("Must provide orignator cert for identification\n");
            return PS_ARG_FAIL;
        }
        if (myCert->issuer.dnenc == NULL)
        {
            psTraceCrypto("Must use CERT_STORE_DN_BUFFER flag when parsing ");
            psTraceCrypto("originator cert: IssuerAndSerialNumber support\n");
            return PS_ARG_FAIL;
        }
#   ifdef USE_FULL_CERT_PARSE
        /* Subject Key ID */
        if ((&myCert->extensions.sk)->len > 0)
        {
            origId = 3; /* no RFC meaning to this */
            originatorLen = (&myCert->extensions.sk)->len;
        }
#   else
        psTraceCrypto("Warning: Enable USE_FULL_CERT_PARSE for MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID\n");
#   endif
    }
    else if (flags & MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY)
    {
        /* OriginatorPublicKey ::= SEQUENCE {
            algorithm AlgorithmIdentifier,
            publicKey BIT STRING } */
        origId = 2; /* no RFC meaning to this */
        /* Using recipientCert for orignator parameters because that is what
            was used to generate the key pair */
        if (recipientCert->pubKeyAlgorithm != OID_ECDSA_KEY_ALG)
        {
            return PS_UNSUPPORTED_FAIL;
        }
        if (mcmsGetAlgOidFromId(recipientCert->pubKeyAlgorithm,
                &origPubKeyId[0], &origPubKeyIdLen) < 0)
        {
            return PS_UNSUPPORTED_FAIL;
        }
        /* Will have been generated in prepareAuthEnvKeyAgreeWrite */
        eccKey = aek->eccKey;

        eccKeyLen = (eccKey->curve->size * 2) + 2;
        oidLen = origPubKeyIdLen + asn1TLOverhead(origPubKeyIdLen);
        originatorLen = oidLen + asn1TLOverhead(oidLen) + /* SEQ in ALG_ID */
                        eccKeyLen + asn1TLOverhead(eccKeyLen);
    }
    if (originatorLen == 0)
    {
        /* IssuerAndSerialNumber */
        if (myCert == NULL)
        {
            psTraceCrypto("Must provide orignator cert for identification\n");
            return PS_ARG_FAIL;
        }
        if (myCert->issuer.dnenc == NULL)
        {
            psTraceCrypto("Must use CERT_STORE_DN_BUFFER flag when parsing ");
            psTraceCrypto("originator cert: IssuerAndSerialNumber support\n");
            return PS_ARG_FAIL;
        }
        origId = 1;                                                 /* no RFC meaning to this */
        originatorLen = myCert->serialNumberLen + myCert->issuer.dnencLen +
                        asn1TLOverhead(myCert->serialNumberLen);    /* Integer around SN */
    }
    originatorSLen = originatorLen + asn1TLOverhead(originatorLen); /* EXPL */


    /* KeyEncryptionAlg */
    mcmsGetSchemeOidFromId(aek->keyAgreeScheme, &keyAgreeId[0], &keyEncOidLen);
    keyEncryptAlgLen = keyEncOidLen + asn1TLOverhead(keyEncOidLen); /* OID */

    mcmsGetSymOidFromId(aek->wrapMethod, &keyWrapId[0], &keyWrapOidLen);
    keyWrapAlgLen = keyWrapOidLen + asn1TLOverhead(keyWrapOidLen); /* OID */


    /* RecipientEncryptedKey */
    rId = recipKeyIdLen = 0;
    if (flags & MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID)
    {
#   ifdef USE_FULL_CERT_PARSE
        /* Subject Key ID */
        if ((&recipientCert->extensions.sk)->len > 0)
        {
            rId = 3; /* no RFC meaning to this */
            recipKeyOctIdLen = (&recipientCert->extensions.sk)->len;
            recipKeyIdLen = recipKeyOctIdLen +
                            asn1TLOverhead(recipKeyOctIdLen); /* OCT */
        }
#   endif
    }
    if (recipKeyIdLen == 0)
    {
        rId = 1; /* no RFC meaning to this */
        recipKeyIdLen = recipientCert->serialNumberLen +
                        recipientCert->issuer.dnencLen +
                        asn1TLOverhead(recipientCert->serialNumberLen); /* INT around SN */
    }

    recipEncLen = recipKeyIdLen + asn1TLOverhead(recipKeyIdLen) + aek->eKeyLen +
                  asn1TLOverhead(aek->eKeyLen);               /* OCTET */
    recipSEncLen = recipEncLen + asn1TLOverhead(recipEncLen); /* SEQUENCE */

    sLen = originatorSLen + asn1TLOverhead(originatorSLen) +
           keyEncryptAlgLen + asn1TLOverhead(keyEncryptAlgLen + keyWrapAlgLen) +
           keyWrapAlgLen + asn1TLOverhead(keyWrapAlgLen) +
           recipSEncLen + asn1TLOverhead(recipSEncLen) +
           1 + asn1TLOverhead(1);       /* 1 byte version */

    cLen = sLen + asn1TLOverhead(sLen); /* CHOICE wrapper */

    tLen = cLen + asn1TLOverhead(cLen); /* SET wrap */

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }

    /* Doing the write */
    start = p;

    /* RecipientInfos ::= SET SIZE (1..MAX) OF RecipientInfo */
    *p = ASN_SET | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, cLen);

    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1; p++;
    p += asnHelpWriteLength(p, sLen);

    /* version */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = 0x3; p++;

    /* originator */
    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, originatorSLen);
    if (origId == 1)
    {
        /* IssuerAndSn */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, originatorLen);

        Memcpy(p, myCert->issuer.dnenc, myCert->issuer.dnencLen);
        p += myCert->issuer.dnencLen;

        *p = ASN_INTEGER; p++;
        p += asnHelpWriteLength(p, myCert->serialNumberLen);
        Memcpy(p, myCert->serialNumber, myCert->serialNumberLen);
        p += myCert->serialNumberLen;
    }
    else if (origId == 3)
    {
        /* SubjectKeyId */
        *p = (ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE); p++;
        p += asnHelpWriteLength(p, originatorLen);

#   ifdef USE_FULL_CERT_PARSE
        Memcpy(p, (&myCert->extensions.sk)->id, (&myCert->extensions.sk)->len);
        p += (&myCert->extensions.sk)->len;
#   endif
    }
    else
    {
        /* Raw DHE public key */
        *p = (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1); p++;
        p += asnHelpWriteLength(p, originatorLen);

        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, oidLen);
        p += asnWriteOidChars(p, origPubKeyId, origPubKeyIdLen);

        *p = ASN_BIT_STRING; p++;
        p += asnHelpWriteLength(p, eccKeyLen);
        *p = 0x0; p++; eccKeyLen--; /* ignore bits */
        if (psEccX963ExportKey(pool, eccKey, p, &eccKeyLen) < 0)
        {
            psFree(start, pool);
            return PS_FAILURE;
        }
        p += eccKeyLen;
        psEccDeleteKey(&eccKey); /* No longer needed */
    }

    /* keyEncryptionAlgorithm - OID with param of another AlgorithmId */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, keyEncryptAlgLen + keyWrapAlgLen +
        asn1TLOverhead(keyWrapAlgLen));
    p += asnWriteOidChars(p, keyAgreeId, keyEncOidLen);
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, keyWrapAlgLen);
    p += asnWriteOidChars(p, keyWrapId, keyWrapOidLen);

    /* RecipientEncryptedKey */
    /* SEQUENCE OF RecipientEncryptedKey */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, recipSEncLen);
    /* RecipientEncryptedKey ::= SEQUENCE */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, recipEncLen);
    if (rId == 1)
    {
        /* IssuerAndSerialNum */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, recipKeyIdLen);
        Memcpy(p, recipientCert->issuer.dnenc, recipientCert->issuer.dnencLen);
        p += recipientCert->issuer.dnencLen;

        *p = ASN_INTEGER; p++;
        p += asnHelpWriteLength(p, recipientCert->serialNumberLen);
        Memcpy(p, recipientCert->serialNumber, recipientCert->serialNumberLen);
        p += recipientCert->serialNumberLen;
    }
    else
    {
        *p = (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED); p++;
        p += asnHelpWriteLength(p, recipKeyIdLen);

        *p = (ASN_OCTET_STRING); p++;
        p += asnHelpWriteLength(p, recipKeyOctIdLen);

        Memcpy(p, (&recipientCert->extensions.sk)->id,
            (&recipientCert->extensions.sk)->len);
        p += (&recipientCert->extensions.sk)->len;
    }

    *p = ASN_OCTET_STRING; p++;
    p += asnHelpWriteLength(p, aek->eKeyLen);
    Memcpy(p, aek->eKey, aek->eKeyLen);
    p += aek->eKeyLen;

    /* sanity */
    cLen = (int32) (p - start);
    psAssert(cLen == tLen);

    *out = start;
    *outLen = cLen;

    return PS_SUCCESS;
}

static int32 mcmsWriteKeyAgreeRecipientInfos(
        psPool_t *pool,
        cmsAuthEnvelopedData_t authEncryptKeys[MCMS_MAX_RECIPIENTS],
        const psX509Cert_t *myCert,
        const int32 recipients, 
        const psX509Cert_t **recipientCerts,
        unsigned char **out, psSize_t *outLen,
        int32 flags)
{
    psDynBuf_t db, set;
    psParseBuf_t pb, pb2;
    psRes_t rc;
    unsigned char *recipientInfo;
    psSize_t recipientInfoLen;
    size_t outSize;
    int32 i;
    
    if (recipients == 1)
    {
        rc = mcmsWriteKeyAgreeRecipientInfo(
                pool,
                &authEncryptKeys[0],
                myCert,
                recipientCerts[0],
                out,
                outLen,
                flags);
        return rc;
    }

    /* Combine recipient infos if more than one info needed. */

    /* Create dynamic buffer for combining recipientInfos. */
    psDynBufInit(pool, &db, 1024);
    psDynBufBeginConstructedTag(&db, &set);

    for(i = 0; i < recipients; i++)
    {
        if ((rc = mcmsWriteKeyAgreeRecipientInfo(
                     pool,
                     &authEncryptKeys[i],
                     myCert,
                     recipientCerts[i],
                     &recipientInfo,
                     &recipientInfoLen,
                     flags)) < 0)
        {
            psDynBufUninit(&set);
            psDynBufUninit(&db);
            return rc;
        }

        rc = psParseBufFromStaticData(
                &pb,
                recipientInfo,
                recipientInfoLen);
        if (rc == PS_SUCCESS)
        {
            (void)psParseBufReadTagSub(&pb, &pb2, ASN_SET | ASN_CONSTRUCTED);
            psDynBufAppendParseBuf(&set, &pb2);
            psParseBufCancel(&pb2);
        }

        psFree(recipientInfo, pool);
    }
    psDynBufEndConstructedTag(&set, ASN_SET | ASN_CONSTRUCTED);
    *out = psDynBufDetach(&db, &outSize);
    if (*out == NULL)
    {
        rc = PS_MEM_FAIL;
    }
    *outLen = (psSize_t) outSize;

    rc = PS_SUCCESS;
    return rc;
}
    
/*
    Writes this:

    ContentInfo ::= SEQUENCE {
            contentType ContentType,
            content [0] EXPLICIT ANY DEFINED BY contentType }

    ContentType ::= OBJECT IDENTIFIER

    AuthEnvelopedData ::= SEQUENCE {
        version CMSVersion,
        originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
        recipientInfos RecipientInfos,
        authEncryptedContentInfo EncryptedContentInfo,
        authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
        mac MessageAuthenticationCode,
        unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
 */
static
int32 matrixCmsCreateAuthEnvDataInt(
        psPool_t *pool,
        const psX509Cert_t *myCert,
        const psPubKey_t *privKey,
        const uint32 recipients,
        const psX509Cert_t **recipientCerts,
        const int32 keyMethod,
        const int32 encryptMethod,
        const int32 wrapMethod,
        const int32 keyAgreeScheme,
        unsigned char *content,
        const int32 contentLen,
        const int32 contentType,
        unsigned char **out,
        int32 *outLen,
        const int32 flags,
        const unsigned char authEncryptKeyMat_in[MCMS_MAX_KEY_MAT_GEN])
{
    unsigned char *originatorInfo, *authAttributes;
    unsigned char *recipientInfos;
    unsigned char *encryptAlg, *p, *start;
    unsigned char oid[CM_MAX_OID_LEN];
    unsigned char contentOid[CM_MAX_OID_LEN];
    cmsAuthEnvelopedData_t authEncryptKeys[MCMS_MAX_RECIPIENTS];

#   ifndef MCMS_EMPTY_AED_AUTH_ATTRIBS
    cmsAttributeSet_t *authAttribs;
#   endif
    int32 rc;
    psSize_t originatorInfoLen, recipientInfosLen;
    psSize_t authAttributesLen, sLen, oidLen = 0;
    psSize_t encryptAlgLen, ctOidLen;
    psSize_t padLen, cmacLen, tmacLen;
    uint32_t cecLen, tecLen, cLen, cSLen, tLen;
    int32 i;

    if (recipients > MCMS_MAX_RECIPIENTS)
    {
        return PS_FAILURE;
    }
    
    *outLen = 0;
    *out = NULL;
    originatorInfo = recipientInfos = authAttributes = encryptAlg = NULL;
    originatorInfoLen = authAttributesLen = 0; /* optional ones we're writing */

    if (contentType != CMS_PKCS7_DATA && contentType != CMS_PKCS7_SIGNED_DATA
        && contentType != CMS_PKCS9_AUTH_ENVELOPED_DATA &&
        contentType != CMS_PKCS9_COMPRESSED_DATA)
    {
        return PS_UNSUPPORTED_FAIL;
    }
    /* Some initial sanity tests */
    if (keyMethod != MCMS_AED_KEY_AGREE_METHOD)
    {
        return PS_UNSUPPORTED_FAIL;
    }
    else
    {
        if (keyAgreeScheme <= 0)
        {
            psTraceCrypto("Use keyAgreeScheme for MCMS_AED_KEY_AGREE_METHOD\n");
            return PS_UNSUPPORTED_FAIL;
        }
    }
    if (recipients < 1 || recipientCerts[0] == NULL)
    {
        psTraceCrypto("Missing recipientCert(s) for AED creation\n");
        return PS_ARG_FAIL;
    }
    if (!(flags & MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY))
    {
        if (privKey == NULL)
        {
            psTraceCrypto("Missing key material for AED creation\n");
            return PS_ARG_FAIL;
        }
    }
    else
    {
        /* OrignatorIdentifierOrKey is a CHOICE of either IssuerAndSerialNumber,
            SubjectKeyIdentifier, or OriginatorPublicKey */
        if (flags & MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID)
        {
            psTraceCrypto("Can't use MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID if ");
            psTraceCrypto("in MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY ephemeral\n");
        }
    }
    if (!(flags & MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID))
    {
        for(i = 0; i< recipients; i++)
        {
            if (recipientCerts[i]->issuer.dnenc == NULL)
            {
                psTraceCrypto("Recipient cert must be parsed with CERT_STORE_DN_BUFFER\n");
                return PS_ARG_FAIL;
            }
        }
    }
    if (flags & MCMS_FLAGS_AED_INCLUDE_CERT)
    {
        if (myCert == NULL)
        {
            psTraceCrypto("Missing originator cert for AED creation\n");
            return PS_ARG_FAIL;
        }
        if (myCert->unparsedBin == NULL)
        {
            psTraceCrypto("Originator cert must be parsed with CERT_STORE_UNPARSED_BUFFER\n");
            return PS_ARG_FAIL;
        }
        if (myCert->pubKeyAlgorithm != recipientCerts[0]->pubKeyAlgorithm)
        {
            psTraceCrypto("Originator and Recipient don't share pubKeyAlgn");
            return PS_ARG_FAIL;
        }
    }

    Memset(&authEncryptKeys, 0x0, sizeof(authEncryptKeys));
    for(i = 0; i < recipients; i++)
    {
        if (prepareAuthEnvKeyAgreeWrite(
                    pool,
                    privKey,
                    recipientCerts[i],
                    keyMethod,
                    encryptMethod,
                    wrapMethod,
                    keyAgreeScheme,
                    &authEncryptKeys[i],
                    authEncryptKeyMat_in,
                    flags) < 0)
        {
            psTraceCrypto("Error generating AuthEncryptKey\n");
            return PS_PLATFORM_FAIL;
        }
    }

    /*  RFC language is that orginatorInfo "is present only if required by the
        key management algorithm." but didn't see any that require this.
        However, it's the only AED way to get the full originator cert to
        the recipient so include it if the caller wants it */
    if (flags & MCMS_FLAGS_AED_INCLUDE_CERT)
    {
        if ((rc = mcmsWriteOriginatorInfo(pool, myCert, &originatorInfo,
                 &originatorInfoLen)) < 0)
        {
            goto LBL_ERR;
        }
    }

    rc = mcmsWriteKeyAgreeRecipientInfos(
            pool,
            authEncryptKeys,
            myCert,
            recipients,
            recipientCerts,
            &recipientInfos,
            &recipientInfosLen,
            flags);
    if (rc < 0)
    {
        goto LBL_ERR;
    }

#   ifndef MCMS_EMPTY_AED_AUTH_ATTRIBS
    if ((authAttribs = psMalloc(pool, sizeof(cmsAttributeSet_t))) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }
    Memset(authAttribs, 0, sizeof(cmsAttributeSet_t));
    authAttribs->pool = pool;
    /* This call will write a Content Type attributes and assign the fully
        formed signed attributes to authAttributes.  TODO: User could pass
        in attribSet with additional attributes if this was expanded a bit */
    if ((rc = mcmsWriteAuthAttributes(pool, contentType, &authEncryptKeys[0],
             authAttribs, &authAttributes, &authAttributesLen)) < 0)
    {
        goto LBL_ERR;
    }
    mcmsFreeAttributes(authAttribs);
#   endif

    /* EncryptedContentInfo length calc */
    padLen = 0;
    if (authEncryptKeys[0].type == MCMS_AES_CBC_CMAC_TYPE)
    {
        padLen = mcmsPadLenPwr2(contentLen, 16);
        if (padLen == 0)
        {
            padLen = 16;
        }
    }
    mcmsGetPkcsOidFromId(contentType, &contentOid[0], &ctOidLen);

    /* For AES GCM we need to initialize now (to obtain final IV value). */
    authEncryptKeys[0].iv[0]++;
    if (authEncryptKeys[0].type == MCMS_AES_GCM_TYPE)
    {
        rc = psAesReadyGCMRandomIV(
                &authEncryptKeys[0].ctx.aesgcm,
                authEncryptKeys[0].iv,
                authEncryptKeys[0].authAttributes,
                authEncryptKeys[0].authAttributesLen,
                NULL);
        if (rc != PS_SUCCESS)
        {
            goto LBL_ERR;
        }
    }

    /* Set IV to same in all authEncryptKeys structures.
       The authEncryptKeys[0] will actually be used for encryption. */
    for(i = 1; i < recipients; i++)
    {
        Memcpy(authEncryptKeys[i].iv,
               authEncryptKeys[0].iv,
               authEncryptKeys[0].ivLen);
    }

    /* ContentEncryptionAlgorithmIdentifier */
    if ((rc = mcmsWriteContentEncAlg(pool, &authEncryptKeys[0], &encryptAlg,
             &encryptAlgLen)) < 0)
    {
        goto LBL_ERR;
    }

#   ifdef USE_RFC_6476
    /* RFC 6476 section 4.1 #3 "The data is processed as described in [AuthEnv],
        and specifically since the mechanisms used are a union of EncryptedData
        and AuthenticatedData, as per [CMS].  The one exception to this is that
        the EncryptedContentInfo.ContentEncryptionAlgorithmIdentifier data is
        MACed before the encrypted content is MACed. */
    if (authEncryptKeys[0].type == MCMS_AES_CBC_CMAC_TYPE)
    {
        psCmacUpdate(&authEncryptKeys[0].cmacCtx, encryptAlg, encryptAlgLen);
    }
#   endif

    cecLen = ctOidLen + asn1TLOverhead(ctOidLen) + encryptAlgLen +
             contentLen + padLen + asn1TLOverhead(contentLen + padLen);

    tecLen = cecLen + asn1TLOverhead(cecLen);
    /* End EncryptedContentInfo length calc */

    /* MessageAuthenticationCode */
    cmacLen = authEncryptKeys[0].macLen;
    tmacLen = cmacLen + asn1TLOverhead(cmacLen);

    /* Have the AED parts.  Do General Syntax and version manaully */
    cLen = recipientInfosLen + authAttributesLen + tecLen + tmacLen +
           originatorInfoLen + 1 + asn1TLOverhead(1);  /* version */

    cSLen = cLen + asn1TLOverhead(cLen);               /* Content + SEQ */

    /* General syntax */
    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        sLen = 0;
    }
    else
    {
        mcmsGetPkcsOidFromId(CMS_PKCS9_AUTH_ENVELOPED_DATA, &oid[0], &oidLen);
        sLen = oidLen + asn1TLOverhead(oidLen); /* OID wrap */
        sLen += asn1TLOverhead(cSLen);          /* EXPLICIT */
    }

    tLen = sLen + cSLen + asn1TLOverhead(cSLen + sLen);

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }

    /* Doing the write */
    start = p;

    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        /* Already didn't include outer sequence and OID.  Now removing
            CONTEXT_SPECIFIC and length bytes */
        tLen -= asn1TLOverhead(cSLen);
    }
    else
    {
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, cSLen + sLen);

        p += asnWriteOidChars(p, oid, oidLen);

        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
        p += asnHelpWriteLength(p, cSLen);
    }

    /* AuthEnvelopedData */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, cLen);

    /* FUTURE: version different if non X.509 certs or odd attributes */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = 0x0; p++; /*  It MUST be set to 0. */

    Memcpy(p, originatorInfo, originatorInfoLen);
    p += originatorInfoLen;

    Memcpy(p, recipientInfos, recipientInfosLen);
    p += recipientInfosLen;

    /* EncryptedContentInfo */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, cecLen);

    /* ContentType is one of the four we support */
    p += asnWriteOidChars(p, contentOid, ctOidLen);

    /* ContentEncryptionAlgorithmIdentifier */
    Memcpy(p, encryptAlg, encryptAlgLen);
    p += encryptAlgLen;

    /* [0] IMPLICIT EncryptedContent OPTIONAL
        EncryptedContent ::= OCTET STRING */
    *p = (ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE); p++;
    p += asnHelpWriteLength(p, contentLen + padLen);

    if (authEncryptKeys[0].type == MCMS_AES_CBC_CMAC_TYPE)
    {
        Memcpy(p, content, contentLen);
        writePad(p + contentLen, padLen);

        psAesEncryptCBC(&authEncryptKeys[0].ctx.aes, p, p, contentLen + padLen);
        /* CMAC is run over the encrypted data and the authAttributes */
        psCmacUpdate(&authEncryptKeys[0].cmacCtx, p, contentLen + padLen);


        psCmacUpdate(&authEncryptKeys[0].cmacCtx, authEncryptKeys[0].authAttributes,
            authEncryptKeys[0].authAttributesLen);
        p += contentLen + padLen;

    }
    else if (authEncryptKeys[0].type == MCMS_AES_GCM_TYPE)
    {
        /* psTraceBytes("INIT GCM WITH IV2", authEncryptKeys[0].iv, 12); */
        /* psTraceBytes("INIT GCM WITH ATTRIBS2", authEncryptKeys[0].authAttributes, authEncryptKeys[0].authAttributesLen); */

        psAesEncryptGCM(&authEncryptKeys[0].ctx.aesgcm, content, p, contentLen);
        p += contentLen;
    }

#   ifndef MCMS_EMPTY_AED_AUTH_ATTRIBS
    /* signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL, */
    /* Have to tweak that first byte */
    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1; p++;
    Memcpy(p, authAttributes + 1, authAttributesLen - 1);
    p += authAttributesLen - 1;
#   endif

    /* MessageAuthenticationCode */
    *p = ASN_OCTET_STRING; p++;
    p += asnHelpWriteLength(p, cmacLen);
    if (authEncryptKeys[0].type == MCMS_AES_GCM_TYPE)
    {
        psAesGetGCMTag(&authEncryptKeys[0].ctx.aesgcm, authEncryptKeys[0].macLen, p);
    }
    else
    {
        psCmacFinal(&authEncryptKeys[0].cmacCtx, p);
    }
    p += authEncryptKeys[0].macLen;


    /* sanity */
    cLen = (int32) (p - start);
    psAssert(cLen == tLen);

    *out = start;
    *outLen = cLen;
    psFree(originatorInfo, pool);
    psFree(recipientInfos, pool);
    psFree(authAttributes, pool);
    psFree(encryptAlg, pool);

    rc = PS_SUCCESS;
LBL_ERR:
    if (rc != PS_SUCCESS)
    {
        if (originatorInfo)
        {
            psFree(originatorInfo, pool);
        }
        if (recipientInfos)
        {
            psFree(recipientInfos, pool);
        }
        if (authAttributes)
        {
            psFree(authAttributes, pool);
        }
        if (encryptAlg)
        {
            psFree(encryptAlg, pool);
        }
    }
    return rc;
}

int32 matrixCmsCreateAuthEnvData(
        psPool_t *pool,
        const psX509Cert_t *myCert,
        const psPubKey_t *privKey,
        const psX509Cert_t *recipientCert,
        const int32 keyMethod,
        const int32 encryptMethod,
        const int32 wrapMethod,
        const int32 keyAgreeScheme,
        unsigned char *content,
        const int32 contentLen,
        const int32 contentType,
        unsigned char **out,
        int32 *outLen,
        const int32 flags)
{
    psResSize_t res;
    unsigned char authEncryptKeyMat[MCMS_MAX_KEY_MAT_GEN];
    const psX509Cert_t *recipientCerts[1] = { recipientCert };

    /* Random key.  For AES_GCM and AES_CBC_CMAC it is specified that raw
        random data is key material (RFC 5652 section 6.3).  For other "encrypt
     + auth" we need to run this secret through PBKDF2 to generate
        the encryption and authentication keys (RFC 6476) */
    res = psGetPrng(NULL, authEncryptKeyMat, MCMS_MAX_KEY_MAT_GEN, NULL);
    if (res < MCMS_MAX_KEY_MAT_GEN)
    {
        /* Set error code if too little entropy has been gotten. */
        if (res >= 0)
        {
            res = PS_FAILURE;
        }
        return res;
    }

    return matrixCmsCreateAuthEnvDataInt(
            pool,
            myCert,
            privKey,
            1,
            recipientCerts,
            keyMethod,
            encryptMethod,
            wrapMethod,
            keyAgreeScheme,
            content,
            contentLen,
            contentType,
            out,
            outLen,
            flags,
            authEncryptKeyMat);
}

int32 matrixCmsCreateAuthEnvDataExt(
        psPool_t *pool,
        const psX509Cert_t *myCert,
        const psPubKey_t *privKey,
        const uint32 recipients,
        const psX509Cert_t **recipientCerts,
        const int32 keyMethod,
        const int32 encryptMethod,
        const int32 wrapMethod,
        const int32 keyAgreeScheme,
        unsigned char *content,
        const int32 contentLen,
        const int32 contentType,
        unsigned char **out,
        int32 *outLen,
        matrixCmsCreateAuthEnvDataExtInfo_t *ei)
{
    psResSize_t res;
    unsigned char authEncryptKeyMat[MCMS_MAX_KEY_MAT_GEN];
    int32 flags = ei ? ei->flags : 0;
    
    /* Random key.  For AES_GCM and AES_CBC_CMAC it is specified that raw
        random data is key material (RFC 5652 section 6.3).  For other "encrypt
     + auth" we need to run this secret through PBKDF2 to generate
        the encryption and authentication keys (RFC 6476) */
    if ((flags & MCMS_FLAGS_AED_PROVIDE_KEYMAT) == 0)
    {
        res = psGetPrng(NULL, authEncryptKeyMat, MCMS_MAX_KEY_MAT_GEN, NULL);
    }
    else
    {
        /* Take keymat from matrixCmsCreateAuthDataExtInfo.
           Currently user has to provide at least MCMS_MAX_KEY_MAT_GEN bytes,
           regardless of the amount of key material actually used. */
        if (ei->authEncryptKeyMatLen < MCMS_MAX_KEY_MAT_GEN)
        {
            res = PS_FAILURE;
        }
        else
        {
            Memcpy(authEncryptKeyMat,
                   ei->authEncryptKeyMat,
                   MCMS_MAX_KEY_MAT_GEN);
            res = MCMS_MAX_KEY_MAT_GEN;
        }
        /* Remove processed MCMS_FLAGS_AED_PROVIDE_KEYMAT from flags. */
        flags &= ~MCMS_FLAGS_AED_PROVIDE_KEYMAT;
    }
    if (res < MCMS_MAX_KEY_MAT_GEN)
    {
        /* Set error code if too little entropy has been gotten. */
        if (res >= 0)
        {
            res = PS_FAILURE;
        }
        return res;
    }

    return matrixCmsCreateAuthEnvDataInt(
            pool,
            myCert,
            privKey,
            recipients,
            recipientCerts,
            keyMethod,
            encryptMethod,
            wrapMethod,
            keyAgreeScheme,
            content,
            contentLen,
            contentType,
            out,
            outLen,
            flags,
            authEncryptKeyMat);
}

#  endif /* USE_MCMS_ATOMIC_AED_CREATE */


#  ifdef USE_MCMS_STREAMING_AED_CREATE
/******************************************************************************/
/*
    STREAMING
 */
int32 matrixCmsInitCreateAuthEnvData(psPool_t *pool,
    const psX509Cert_t *myCert,
    const psPubKey_t *privKey,
    const psX509Cert_t *recipientCert,
    const int32 keyMethod,
    const int32 encryptMethod,
    const int32 wrapMethod,
    const int32 keyAgreeScheme,
    const int32 contentType,
    unsigned char **out,
    int32 *outLen,
    const int32 flags,
    cmsAuthEnvelopedData_t **aedOut)
{
    /* recipient info */
    int32 origId, rId;
    psSize_t origPubKeyOidLen, originatorLen, origPubKeyIdLen;
    psSize_t keyEncOidLen, keyEncryptAlgLen, keyWrapOidLen;
    psSize_t keyWrapAlgLen, recipKeyIdLen, recipKeyOctIdLen;
    psSize_t recipEncLen, recipSEncLen, originatorSLen, gsOidLen;
    psSize_t triLen, criLen, sriLen;
    psSize_t toiLen, coiLen;        /* originatorInfo */
    unsigned char origPubKeyId[CM_MAX_OID_LEN];
    unsigned char keyAgreeId[CM_MAX_OID_LEN];
    unsigned char keyWrapId[CM_MAX_OID_LEN];
    unsigned char gsOid[CM_MAX_OID_LEN];
    psEccKey_t *eccKey;
    unsigned char *contentEncAlg;
    psSize_t eccKeyLen, contentEncAlgLen;

    /* end recipient info */
    /* authAttributes */
#   ifndef MCMS_EMPTY_AED_AUTH_ATTRIBS
    cmsAttributeSet_t *authAttribs;
#   endif
    unsigned char *authAttributes;
    psSize_t authAttributesLen;
    /* end auth Attributes */
    /* encrypted content */
    unsigned char contentOid[CM_MAX_OID_LEN];
    psSize_t ctOidLen, tecLen, cecLen;
    /* end encrypted content */
    psSize_t cLen, sLen, tLen;
    int32_t rc;
    unsigned char *p, *start;
    cmsAuthEnvelopedData_t *authEncryptKey;

    *outLen = 0;
    *out = NULL;

    authAttributes = contentEncAlg = NULL;
    toiLen = coiLen = authAttributesLen = 0; /* optional ones we're writing */

    if (contentType != CMS_PKCS7_DATA && contentType != CMS_PKCS7_SIGNED_DATA
        && contentType != CMS_PKCS9_AUTH_ENVELOPED_DATA &&
        contentType != CMS_PKCS9_COMPRESSED_DATA)
    {
        return PS_UNSUPPORTED_FAIL;
    }

    /* Some initial sanity tests */
    if (keyMethod != MCMS_AED_KEY_AGREE_METHOD)
    {
        return PS_UNSUPPORTED_FAIL;
    }
    else
    {
        if (keyAgreeScheme <= 0)
        {
            psTraceCrypto("Use keyAgreeScheme for MCMS_AED_KEY_AGREE_METHOD\n");
            return PS_UNSUPPORTED_FAIL;
        }
    }
    if (recipientCert == NULL)
    {
        psTraceCrypto("Missing recipientCert for AED creation\n");
        return PS_ARG_FAIL;
    }
    if (!(flags & MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID))
    {
        if (recipientCert->issuer.dnenc == NULL)
        {
            psTraceCrypto("Recipient cert must be parsed with CERT_STORE_DN_BUFFER\n");
            return PS_ARG_FAIL;
        }
    }
    if (!(flags & MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY))
    {
        if (privKey == NULL)
        {
            psTraceCrypto("Missing key material for AED creation\n");
            return PS_ARG_FAIL;
        }
    }
    else
    {
        if (flags & MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID)
        {
            psTraceCrypto("Can't use MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID if ");
            psTraceCrypto("in MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY ephemeral\n");
            return PS_ARG_FAIL;
        }
    }
    if (flags & MCMS_FLAGS_AED_INCLUDE_CERT)
    {
        if (myCert == NULL)
        {
            psTraceCrypto("Missing originator cert for AED creation\n");
            return PS_ARG_FAIL;
        }
        if (myCert->unparsedBin == NULL)
        {
            psTraceCrypto("Originator cert must be parsed with CERT_STORE_UNPARSED_BUFFER\n");
            return PS_ARG_FAIL;
        }
        if (myCert->pubKeyAlgorithm != recipientCert->pubKeyAlgorithm)
        {
            psTraceCrypto("Originator and Recipient don't share pubKeyAlgn");
            return PS_ARG_FAIL;
        }
    }

    if ((authEncryptKey = psMalloc(pool, sizeof(cmsAuthEnvelopedData_t)))
        == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(authEncryptKey, 0x0, sizeof(cmsAuthEnvelopedData_t));
    authEncryptKey->pool = pool;

    if ((rc = prepareAuthEnvKeyAgreeWrite(pool, privKey, recipientCert,
             keyMethod, encryptMethod, wrapMethod, keyAgreeScheme,
             authEncryptKey, flags)) < 0)
    {
        psTraceCrypto("Error generating AuthEncryptKey\n");
        goto LBL_ERR;
    }

    /*  RFC language is that orginatorInfo "is present only if required by the
        key management algorithm." but didn't see any that require this.
        However, it's the only AED way to get the full originator cert to
        the recipient so include it if the caller wants it */
    if (flags & MCMS_FLAGS_AED_INCLUDE_CERT)
    {
        if (myCert->unparsedBin == NULL)
        {
            psTraceCrypto("Cert must be parsed with CERT_STORE_UNPARSED_BUFFER\n");
            rc = PS_ARG_FAIL;
            goto LBL_ERR;
        }
        coiLen = myCert->binLen + asn1TLOverhead(myCert->binLen); /* IMPLICIT SET */
        toiLen = coiLen + asn1TLOverhead(coiLen);                 /* IMPLICIT SEQUENCE */
        /* toi - TOTAL originatorInfo len */
    }

    /*  Recipient information using key agreement is represented in the type
        KeyAgreeRecipientInfo.  Each instance of KeyAgreeRecipientInfo will
        transfer the content-encryption key to one or more recipients that
        use the same key agreement algorithm and domain parameters for that
        algorithm. */


    /* Origintator is used to locate the public key. */
    origId = originatorLen = 0;
    if (flags & MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID)
    {
#   ifdef USE_FULL_CERT_PARSE
        /* Subject Key ID */
        if ((&myCert->extensions.sk)->len > 0)
        {
            origId = 3; /* no RFC meaning to this */
            originatorLen = (&myCert->extensions.sk)->len;
        }
#   else
        psTraceCrypto("Warning: Enable USE_FULL_CERT_PARSE for MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID\n");
#   endif
    }
    else if (flags & MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY)
    {
        /* OriginatorPublicKey ::= SEQUENCE {
            algorithm AlgorithmIdentifier,
            publicKey BIT STRING } */
        origId = 2; /* no RFC meaning to this */
        /* Using recipientCert for orignator parameters because that is what
            was used to generate the key pair */
        if (recipientCert->pubKeyAlgorithm != OID_ECDSA_KEY_ALG)
        {
            rc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        if (mcmsGetAlgOidFromId(recipientCert->pubKeyAlgorithm,
                &origPubKeyId[0], &origPubKeyIdLen) < 0)
        {
            rc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        /* Will have been generated in prepareAuthEnvKeyAgreeWrite */
        eccKey = authEncryptKey->eccKey;
        /* LANDIS NOTE: probably not portable */
        eccKeyLen = (eccKey->curve->size * 2) + 2;
        origPubKeyOidLen = origPubKeyIdLen + asn1TLOverhead(origPubKeyIdLen);
        originatorLen = origPubKeyOidLen + asn1TLOverhead(origPubKeyOidLen) +
                        eccKeyLen + asn1TLOverhead(eccKeyLen);
    }
    if (originatorLen == 0)
    {
        /* IssuerAndSerialNumber */
        origId = 1;                                                 /* no RFC meaning to this */
        originatorLen = myCert->serialNumberLen + myCert->issuer.dnencLen +
                        asn1TLOverhead(myCert->serialNumberLen);    /* Integer around SN */
    }
    originatorSLen = originatorLen + asn1TLOverhead(originatorLen); /* EXPL */


    /* KeyEncryptionAlg */
    mcmsGetSchemeOidFromId(authEncryptKey->keyAgreeScheme, &keyAgreeId[0],
        &keyEncOidLen);
    keyEncryptAlgLen = keyEncOidLen + asn1TLOverhead(keyEncOidLen); /* OID */

    mcmsGetSymOidFromId(authEncryptKey->wrapMethod, &keyWrapId[0],
        &keyWrapOidLen);
    keyWrapAlgLen = keyWrapOidLen + asn1TLOverhead(keyWrapOidLen); /* OID */


    /* RecipientEncryptedKey */
    rId = recipKeyIdLen = 0;
    if (flags & MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID)
    {
#   ifdef USE_FULL_CERT_PARSE
        /* Subject Key ID */
        if ((&recipientCert->extensions.sk)->len > 0)
        {
            rId = 3; /* no RFC meaning to this */
            recipKeyOctIdLen = (&recipientCert->extensions.sk)->len;
            recipKeyIdLen = recipKeyOctIdLen +
                            asn1TLOverhead(recipKeyOctIdLen); /* OCT */
        }
#   endif
    }
    if (recipKeyIdLen == 0)
    {
        rId = 1; /* no RFC meaning to this */
        recipKeyIdLen = recipientCert->serialNumberLen +
                        recipientCert->issuer.dnencLen +
                        asn1TLOverhead(recipientCert->serialNumberLen); /* INT around SN */
    }

    recipEncLen = recipKeyIdLen + asn1TLOverhead(recipKeyIdLen) +
                  authEncryptKey->eKeyLen + asn1TLOverhead(authEncryptKey->eKeyLen); /* OCTET */
    recipSEncLen = recipEncLen + asn1TLOverhead(recipEncLen);                        /* SEQUENCE */

    sriLen = originatorSLen + asn1TLOverhead(originatorSLen) +
             keyEncryptAlgLen + asn1TLOverhead(keyEncryptAlgLen + keyWrapAlgLen) +
             keyWrapAlgLen + asn1TLOverhead(keyWrapAlgLen) +
             recipSEncLen + asn1TLOverhead(recipSEncLen) +
             1 + asn1TLOverhead(1);           /* 1 byte version */

    criLen = sriLen + asn1TLOverhead(sriLen); /* CHOICE wrapper */

    triLen = criLen + asn1TLOverhead(criLen); /* SET wrap */
    /* TOTAL recipientInfo length */

#   ifndef MCMS_EMPTY_AED_AUTH_ATTRIBS
    /* Must write out authAttributes because those are inputs to the hash */
    if ((authAttribs = psMalloc(pool, sizeof(cmsAttributeSet_t))) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }
    Memset(authAttribs, 0, sizeof(cmsAttributeSet_t));
    authAttribs->pool = pool;
    /* This call will write a Content Type attributes and assign the fully
        formed signed attributes to authAttributes.  TODO: User could pass
        in attribSet with additional attributes if this was expanded a bit */
    if ((rc = mcmsWriteAuthAttributes(pool, contentType, authEncryptKey,
             authAttribs, &authAttributes, &authAttributesLen)) < 0)
    {
        goto LBL_ERR;
    }
    mcmsFreeAttributes(authAttribs);
    /* authAttributes and authAttributesLen now point into authEncryptKey */
#   endif

    /* Take this first opportunity to initalize any hash states now that
        require the authAttributes as a first input (GCM only right now) */
    if (authEncryptKey->type == MCMS_AES_GCM_TYPE)
    {
        /* psTraceBytes("INIT GCM WITH IV", authEncryptKey->iv, 12); */
        /* psTraceBytes("INIT GCM WITH ATTRIBS", authAttributes,        authAttributesLen); */
        uint32_t res = psAesReadyGCMRandomIV(authEncryptKey->ctx.aesgcm, authEncryptKey->iv,
            authAttributes,
            authAttributesLen, NULL);
        if (res != PS_SUCCESS)
        {
            return res;
        }
    }

    mcmsGetPkcsOidFromId(contentType, &contentOid[0], &ctOidLen);

    /* ContentEncryptionAlgorithmIdentifier with IV param */
    if (mcmsWriteContentEncAlg(pool, authEncryptKey, &contentEncAlg,
            &contentEncAlgLen) < 0)
    {
        rc = PS_MEM_FAIL; /* currently only way to fail in here */
        goto LBL_ERR;
    }

#   ifdef USE_RFC_6476
    /* RFC 6476 section 4.1 #3 "The data is processed as described in [AuthEnv],
        and specifically since the mechanisms used are a union of EncryptedData
        and AuthenticatedData, as per [CMS].  The one exception to this is that
        the EncryptedContentInfo.ContentEncryptionAlgorithmIdentifier data is
        MACed before the encrypted content is MACed. */
    if (authEncryptKey->type == MCMS_AES_CBC_CMAC_TYPE)
    {
        psCmacUpdate(&authEncryptKey->cmacCtx, contentEncAlg,
            contentEncAlgLen);
    }
#   endif

    cecLen = ctOidLen + asn1TLOverhead(ctOidLen) + contentEncAlgLen +
             4;                          /* Two indefinite length TL */

    tecLen = cecLen + asn1TLOverhead(1); /* indefinite SEQ */
    /* END ENCRYPTED CONTENT LEN CALC */

    /* Write out the aed type up to the point of the content */
    /*  Do General Syntax and version manaully */
    cLen = triLen + toiLen + tecLen + 1 + asn1TLOverhead(1); /* version */

    /* General syntax */
    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        sLen =  0;
        authEncryptKey->omitContentInfo = 1; /* So Final knows */
    }
    else
    {
        mcmsGetPkcsOidFromId(CMS_PKCS9_AUTH_ENVELOPED_DATA, &gsOid[0], &gsOidLen);
        sLen = gsOidLen + asn1TLOverhead(gsOidLen); /* OID wrap */
        sLen += asn1TLOverhead(1);                  /* indefinite EXPLICIT */
    }

    tLen = sLen + cLen + asn1TLOverhead(1);

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }

    /* Doing the write */
    start = p;

    if (!(flags & MCMS_FLAGS_NO_CONTENT_INFO))
    {
        /* General syntax */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        *p = 0x80; p++;

        p += asnWriteOidChars(p, gsOid, gsOidLen);

        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
        *p = 0x80; p++;
    }
    else
    {
        /* Already didn't include outer sequence and OID.  Now removing
            CONTEXT_SPECIFIC and indefinite length byte */
        tLen -= asn1TLOverhead(1);
    }

    /* AuthEnvelopedData */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    /* FUTURE: version different if non X.509 certs or odd attributes */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = 0x0; p++; /*  It MUST be set to 0. */

    /* Start originator info */
    if (flags & MCMS_FLAGS_AED_INCLUDE_CERT)
    {
        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
        p += asnHelpWriteLength(p, coiLen);

        /* CertificateSet ::= SET OF CertificateChoices */
        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
        p += asnHelpWriteLength(p, myCert->binLen);
        Memcpy(p, myCert->unparsedBin, myCert->binLen);
        p += myCert->binLen;
    }
    /* End originator info */

    /* RecipientInfos ::= SET SIZE (1..MAX) OF RecipientInfo */
    *p = ASN_SET | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, criLen);

    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1; p++;
    p += asnHelpWriteLength(p, sriLen);

    /* version */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = 0x3; p++;

    /* originator */
    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, originatorSLen);
    if (origId == 1)
    {
        /* IssuerAndSn */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, originatorLen);

        Memcpy(p, myCert->issuer.dnenc, myCert->issuer.dnencLen);
        p += myCert->issuer.dnencLen;

        *p = ASN_INTEGER; p++;
        p += asnHelpWriteLength(p, myCert->serialNumberLen);
        Memcpy(p, myCert->serialNumber, myCert->serialNumberLen);
        p += myCert->serialNumberLen;
    }
    else if (origId == 3)
    {
        /* SubjectKeyId */
        *p = (ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE); p++;
        p += asnHelpWriteLength(p, originatorLen);

#   ifdef USE_FULL_CERT_PARSE
        Memcpy(p, (&myCert->extensions.sk)->id, (&myCert->extensions.sk)->len);
        p += (&myCert->extensions.sk)->len;
#   endif
    }
    else
    {
        /* Raw DHE public key */
        *p = (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1); p++;
        p += asnHelpWriteLength(p, originatorLen);

        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, origPubKeyOidLen);
        p += asnWriteOidChars(p, origPubKeyId, origPubKeyIdLen);

        *p = ASN_BIT_STRING; p++;
        p += asnHelpWriteLength(p, eccKeyLen);
        *p = 0x0; p++; eccKeyLen--; /* ignore bits */
        if (psEccX963ExportKey(pool, eccKey, p, &eccKeyLen) < 0)
        {
            psFree(start, pool);
            return PS_PLATFORM_FAIL;
        }
        p += eccKeyLen;
        psEccDeleteKey(&eccKey); /* No longer needed */
    }

    /* keyEncryptionAlgorithm - OID with param of another AlgorithmId */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, keyEncryptAlgLen + keyWrapAlgLen +
        asn1TLOverhead(keyWrapAlgLen));
    p += asnWriteOidChars(p, keyAgreeId, keyEncOidLen);
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, keyWrapAlgLen);
    p += asnWriteOidChars(p, keyWrapId, keyWrapOidLen);

    /* RecipientEncryptedKey */
    /* SEQUENCE OF RecipientEncryptedKey */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, recipSEncLen);
    /* RecipientEncryptedKey ::= SEQUENCE */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, recipEncLen);
    if (rId == 1)
    {
        /* IssuerAndSerialNum */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, recipKeyIdLen);
        Memcpy(p, recipientCert->issuer.dnenc, recipientCert->issuer.dnencLen);
        p += recipientCert->issuer.dnencLen;

        *p = ASN_INTEGER; p++;
        p += asnHelpWriteLength(p, recipientCert->serialNumberLen);
        Memcpy(p, recipientCert->serialNumber, recipientCert->serialNumberLen);
        p += recipientCert->serialNumberLen;
    }
    else
    {
        *p = (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED); p++;
        p += asnHelpWriteLength(p, recipKeyIdLen);

        *p = (ASN_OCTET_STRING); p++;
        p += asnHelpWriteLength(p, recipKeyOctIdLen);

#   ifdef USE_FULL_CERT_PARSE
        Memcpy(p, (&recipientCert->extensions.sk)->id,
            (&recipientCert->extensions.sk)->len);
        p += (&recipientCert->extensions.sk)->len;
#   endif
    }

    *p = ASN_OCTET_STRING; p++;
    p += asnHelpWriteLength(p, authEncryptKey->eKeyLen);
    Memcpy(p, authEncryptKey->eKey, authEncryptKey->eKeyLen);
    p += authEncryptKey->eKeyLen;
    /* End recipient infos */


    /* Start encrypted content write */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    p += asnWriteOidChars(p, contentOid, ctOidLen);

    /* ContentEncryptionAlgorithmIdentifier */
    Memcpy(p, contentEncAlg, contentEncAlgLen);
    p += contentEncAlgLen;
    psFree(contentEncAlg, pool); contentEncAlg = NULL;

    /* [0] IMPLICIT EncryptedContent OPTIONAL
        EncryptedContent ::= OCTET STRING */
    *p = (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED); p++;
    *p = 0x80; p++;
    /* End encrypted content header write */

    /* sanity */
    cLen = (int32) (p - start);
    psAssert(cLen == tLen);

    *out = start;
    *outLen = cLen;
    *aedOut = authEncryptKey;

    rc = PS_SUCCESS;
LBL_ERR:
    if (rc != PS_SUCCESS)
    {
        psFree(authEncryptKey, pool);
        if (contentEncAlg)
        {
            psFree(contentEncAlg, pool);
        }
    }
    return rc;
}

/* Sends back the encrypted OCTET STRING that will append to the "Init" data */
int32 matrixCmsUpdateCreateAuthEnvData(psPool_t *pool,
    cmsAuthEnvelopedData_t *aedCtx,
    unsigned char *dataIn,
    int32 dataInLen,
    unsigned char **out,
    int32 *outLen)
{
    int32 tLen, sLen, leftover, new;
    unsigned char *p, *start, *macStart;

    *out = NULL;
    *outLen = 0;

    if (aedCtx->type == MCMS_AES_CBC_CMAC_TYPE)
    {
        /* Can only encrypt block sizes */
        sLen = dataInLen + aedCtx->leftoverLen;

        if (sLen < 16)
        {
            Memcpy(aedCtx->leftover + aedCtx->leftoverLen, dataIn, dataInLen);
            aedCtx->leftoverLen += dataInLen;
            return PS_SUCCESS;
        }
        leftover = sLen % 16;
        sLen -= leftover;
        tLen = sLen + asn1TLOverhead(sLen);

        if ((p = psMalloc(pool, tLen)) == NULL)
        {
            return PS_MEM_FAIL;
        }
        start = p;

        *p = ASN_OCTET_STRING; p++;
        p += asnHelpWriteLength(p, sLen);
        macStart = p;

        Memcpy(p, aedCtx->leftover, aedCtx->leftoverLen);
        p += aedCtx->leftoverLen;
        new = sLen - aedCtx->leftoverLen;
        Memcpy(p, dataIn, new);
        p += new;

        psAesEncryptCBC(&aedCtx->ctx.aes, macStart, macStart, sLen);
        /* CMAC is run over the encrypted data */
        psCmacUpdate(&aedCtx->cmacCtx, macStart, sLen);


        Memcpy(aedCtx->leftover, dataIn + new, leftover);
        aedCtx->leftoverLen = leftover;
    }
    else if (aedCtx->type == MCMS_AES_GCM_TYPE)
    {
        /* No blocksize constraints */
        tLen = dataInLen + asn1TLOverhead(dataInLen);

        if ((p = psMalloc(pool, tLen)) == NULL)
        {
            return PS_MEM_FAIL;
        }
        start = p;

        *p = ASN_OCTET_STRING; p++;
        p += asnHelpWriteLength(p, dataInLen);

        psAesEncryptGCM(&aedCtx->ctx.aesgcm, dataIn, p, dataInLen);
        p += dataInLen;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL; /* keep compilers happy */
    }

    /* sanity */
    sLen = (int32) (p - start);
    psAssert(sLen == tLen);

    *out = start;
    *outLen = sLen;
    return PS_SUCCESS;
}


int32 matrixCmsFinalCreateAuthEnvData(psPool_t *pool,
    cmsAuthEnvelopedData_t *aedCtx,
    unsigned char **out, int32 *outLen)
{
    int32 tencLen, encLen, pad, tLen, macLen, tmacLen;
    unsigned char *p, *macStart, *start;

    *out = NULL;
    *outLen = 0;

    /* finish encrypted content */
    if (aedCtx->type == MCMS_AES_CBC_CMAC_TYPE)
    {
        encLen = aedCtx->leftoverLen;
        pad = mcmsPadLenPwr2(encLen, 16);
        if (pad == 0)
        {
            pad = 16;
        }
        encLen += pad;
        psAssert(encLen == 16);

        /* 2 of end-of-contents: EncryptedContent and EncryptedContentInfo */
        tencLen = encLen + asn1TLOverhead(encLen) + 4; /* +4 end-of-contents */
    }
    else if (aedCtx->type == MCMS_AES_GCM_TYPE)
    {
        tencLen = 4;                                   /* + 4 end-of-content */
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;                    /* keep compilers happy */
    }

    macLen = aedCtx->macLen;
    tmacLen = macLen + asn1TLOverhead(macLen);

    if (aedCtx->omitContentInfo == 0)
    {
        /* 3 of end-of-contents: AuthEnvelopedData, Content, and overall SEQ */
        tLen = tencLen + tmacLen + aedCtx->authAttributesLen + 6;
    }
    else
    {
        /* 1 end-of-contents: AuthEnvelopedData */
        tLen = tencLen + tmacLen + aedCtx->authAttributesLen + 2;
    }


    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    start = p;

    if (aedCtx->type == MCMS_AES_CBC_CMAC_TYPE)
    {
        *p = ASN_OCTET_STRING; p++;
        p += asnHelpWriteLength(p, encLen);

        macStart = p;
        Memcpy(p, aedCtx->leftover, aedCtx->leftoverLen);
        p += aedCtx->leftoverLen;
        writePad(p, pad);
        p += pad;

        psAesEncryptCBC(&aedCtx->ctx.aes, macStart, macStart, 16);
        psCmacUpdate(&aedCtx->cmacCtx, macStart, 16);
    }
    *p = 0x0; p++;
    *p = 0x0; p++; /* end-of-contents for the EncryptedContent */
    *p = 0x0; p++;
    *p = 0x0; p++; /* end-of-contents for the EncryptedContentInfo */

#   ifndef MCMS_EMPTY_AED_AUTH_ATTRIBS
    /* signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL, */
    /* Have to tweak that first byte */
    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1; p++;
    Memcpy(p, aedCtx->authAttributes + 1, aedCtx->authAttributesLen - 1);
    p += aedCtx->authAttributesLen - 1;
#   endif

    /* Done with authAttributes */
    psFree(aedCtx->authAttributes, pool); aedCtx->authAttributes = NULL;

    /* MAC */
    *p = ASN_OCTET_STRING; p++;
    p += asnHelpWriteLength(p, macLen);
    if (aedCtx->type == MCMS_AES_GCM_TYPE)
    {
        psAesGetGCMTag(&aedCtx->ctx.aesgcm, aedCtx->macLen, p);
    }
    else
    {
        /* Finally CMAC in the authAttributes */
        psCmacUpdate(&aedCtx->cmacCtx, aedCtx->authAttributes,
            aedCtx->authAttributesLen);
        psCmacFinal(&aedCtx->cmacCtx, p);
    }
    p += aedCtx->macLen;
    /* END MAC */

    *p = 0x0; p++;
    *p = 0x0; p++; /* end-of-contents for the AuthEnvelopedData */
    if (aedCtx->omitContentInfo == 0)
    {
        *p = 0x0; p++;
        *p = 0x0; p++; /* end-of-contents for the Content in General Syntax */
        *p = 0x0; p++;
        *p = 0x0; p++; /* end-of-contents for the overall SEQUENCE */
    }

    encLen = (int32) (p - start);
    psAssert(encLen == tLen);

    *out = start;
    *outLen = encLen;
    return PS_SUCCESS;
}

void matrixCmsFreeStreamCreatedAuthEnvData(cmsAuthEnvelopedData_t *aed)
{
    if (aed)
    {
        if (aed->authAttributes)
        {
            psFree(aed->authAttributes, aed->pool);
        }
        psFree(aed, aed->pool);
    }
}
#  endif /* USE_MCMS_STREAMING_AED_CREATE */

# endif  /* ATOMIC or STREAMING */

#endif   /* USE_CMS */
