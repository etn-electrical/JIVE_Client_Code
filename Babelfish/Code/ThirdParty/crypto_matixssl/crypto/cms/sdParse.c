/**
 *      @file    sdParse.c
 *
 *
 *      Signed data parse.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "matrixCmsApi.h"
#include "cryptoImpl.h"

#ifdef USE_CMS

static int32 matrixCmsParseSignerInfos(psPool_t *pool, const unsigned char *buf,
                                       uint32 bufLen, cmsSignedData_t *signedData);


# if defined(USE_MCMS_ATOMIC_SD_PARSE) || defined(USE_MCMS_STREAMING_SD_PARSE)

/* Some code comments are taken directly from RFC 5652 text */

#  ifdef USE_MCMS_STREAMING_SD_PARSE
int32 matrixCmsInitParseSignedData(psPool_t *pool, unsigned char *sdBuf,
    uint32 sdBufLen, cmsSignedData_t **retSignedData, unsigned char **data,
    uint32 *dataLen, int32 flags)
{
    cmsSignedData_t *signedData;
    const unsigned char *p, *end, *tmpLenPtr;
    int32 intOut, rc, prc;
    int32 initialIndef, contentIndef, sdIndef;
    psSize_t paramLen, l16;
    uint32_t len, tmpLen, cdLen;

    if (sdBufLen == 0)
    {
        return PS_LIMIT_FAIL;
    }

    p = sdBuf;
    end = p + sdBufLen;
    prc = PS_PARSE_FAIL;
    *retSignedData = NULL;
    *data = NULL;
    *dataLen = 0;

    if (!(flags & MCMS_FLAGS_NO_CONTENT_INFO))
    {
        /* General Syntax content is going to tell us what it is
            ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */

        if ((initialIndef = getAsnSequence32(&p, (uint32_t) (end - p),
                 &len, 1)) < 0)
        {
            /* The very first length is given special return code if length
                provided is too short */
            if (initialIndef == PS_LIMIT_FAIL)
            {
                return initialIndef;
            }
            psTraceCrypto("Initial parse error for signed data type\n");
            return PS_PARSE_FAIL;
        }
        if ((rc = mcmsParsePkcsOid(&p, (uint32) (end - p), &l16))
            < 0)
        {
            psTraceCrypto("Error parsing OID for signed data type\n");
            return rc;
        }
        /* l16 is OID id */
        if (l16 != CMS_PKCS7_SIGNED_DATA)
        {
            psTraceIntCrypto("Expected signedData type but got %d", intOut);
            return PS_PARSE_FAIL;
        }
        if (end - p < 1)
        {
            return PS_LIMIT_FAIL;
        }

        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Expected EXPLICIT content for contentInfo");
            return PS_PARSE_FAIL;
        }
        p++;

        if ((contentIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
        {
            psTraceCrypto("getAsnLength failure in ContentType parse\n");
            return contentIndef;
        }
    }
    else
    {
        initialIndef = contentIndef = 0;
    }

    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }

    /* OK, we've passed the General Syntax

        SignedData ::= SEQUENCE {
            version CMSVersion,
            digestAlgorithms DigestAlgorithmIdentifiers,
            encapContentInfo EncapsulatedContentInfo,
            certificates [0] IMPLICIT CertificateSet OPTIONAL,
            crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
            signerInfos SignerInfos }

       DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier

       SignerInfos ::= SET OF SignerInfo
     */
    if ((sdIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1)) < 0)
    {
        psTraceCrypto("Initial parse error SignedData\n");
        return sdIndef;
    }
    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }
    /* Set up the structure to hold the info we want to persist */
    if ((signedData = psMalloc(pool, sizeof(cmsSignedData_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(signedData, 0, sizeof(cmsSignedData_t));
    signedData->pool = pool;
    signedData->sdIndef = sdIndef;
    signedData->contentIndef = contentIndef;
    signedData->initialIndef = initialIndef;

    /*  CMSVersion ::= INTEGER { v0(0), v1(1), v2(2), v3(3), v4(4), v5(5) } */
    if ((prc = getAsnInteger(&p, (uint32) (end - p), &signedData->version)) < 0)
    {
        psTraceCrypto("Error getting version for signed data\n");
        goto LBL_ERR;
    }
    /* IF ((certificates is present) AND
            (any certificates with a type of other are present)) OR
            ((crls is present) AND
            (any crls with a type of other are present))
         THEN version MUST be 5
         ELSE
            IF (certificates is present) AND
               (any version 2 attribute certificates are present)
            THEN version MUST be 4
            ELSE
               IF ((certificates is present) AND
                  (any version 1 attribute certificates are present)) OR
                  (any SignerInfo structures are version 3) OR
                  (encapContentInfo eContentType is other than id-data)
               THEN version MUST be 3
               ELSE version MUST be 1 */

    /* DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier */
    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }
    /* NOTE: getAsnSet32 will return LIMIT_FAIL until it has it all so there
        isn't any need to enforce LIMIT_FAIL in the loop below! */
    if ((prc = getAsnSet32(&p, (uint32_t) (end - p), &cdLen, 1)) < 0)
    {
        psTraceCrypto("Initial parse error DigestAlgorithmIdentifiers\n");
        goto LBL_ERR;
    }
    while (cdLen > 0)
    {
        tmpLenPtr = p;
        /* DigestAlgorithmIdentifier ::= AlgorithmIdentifier */
        if (getAsnAlgorithmIdentifier(&p, (int32) (end - p), &intOut,
                &paramLen) < 0)
        {
            psTraceCrypto("Error getting DigestAlgorithmIdentifier OID\n");
            prc = PS_PARSE_FAIL;
            goto LBL_ERR;
        }
        if (paramLen > 0)
        {
            if (end - p < paramLen)
            {
                prc = PS_LIMIT_FAIL;
                goto LBL_ERR;
            }
            p += paramLen;
        }
        /* Do we support this digest? */
        if (intOut != OID_SHA1_ALG && intOut != OID_SHA256_ALG &&
            intOut != OID_SHA384_ALG && intOut != OID_SHA512_ALG)
        {
            psTraceIntCrypto("Unsupported DigestAlgorithm %d\n", intOut);
            prc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        signedData->digestId = intOut; /* Not used again so overwrite is fine */
        cdLen -= (int32) (p - tmpLenPtr);
    }
    /*
        EncapsulatedContentInfo ::= SEQUENCE {
        eContentType ContentType,
        eContent [0] EXPLICIT OCTET STRING OPTIONAL }

       ContentType ::= OBJECT IDENTIFIER */
    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }
    if ((signedData->encapIndef = getAsnSequence32(&p,
             (uint32_t) (end - p), &tmpLen, 1)) < 0)
    {
        psTraceCrypto("Initial parse error EncapsulatedContentInfo\n");
        prc = signedData->encapIndef;
        goto LBL_ERR;
    }
    tmpLenPtr = p;
    /*  The optional omission of the eContent within the
        EncapsulatedContentInfo field makes it possible to construct
        "external signatures".  In the case of external signatures, the
        content being signed is absent from the EncapsulatedContentInfo value
        included in the signed-data content type.  If the eContent value
        within EncapsulatedContentInfo is absent, then the signatureValue is
        calculated and the eContentType is assigned as though the eContent
        value was present.

        In the degenerate case where there are no signers, the
        EncapsulatedContentInfo value being "signed" is irrelevant.  In this
        case, the content type within the EncapsulatedContentInfo value being
        "signed" MUST be id-data (as defined in Section 4), and the content
        field of the EncapsulatedContentInfo value MUST be omitted.
     */
    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }
    if ((prc = mcmsParsePkcsOid(&p, (uint32) (end - p),
             &signedData->eContentType)) < 0)
    {
        psTraceCrypto("Error parsing OID for eContentType\n");
        goto LBL_ERR;
    }

    if (end - p < 1)
    {
        /* This one is necessary because we can't trust tmpLen calc on
            indefinate length encodes because the tmpLen value will be
            whatever data is left and the tmpLen decrement will take us to
            zero and fail the real test to know if content is there or not */
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }
    tmpLen -= (int32) (p - tmpLenPtr);

    if (tmpLen)
    {
        /* eContent exists */
        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Initial parse error for eContent\n");
            prc = PS_PARSE_FAIL;
            goto LBL_ERR;
        }
        p++;
        if ((signedData->eContentIndef = getAsnLength32(&p,
                 (uint32_t) (end - p), &len, 1)) < 0)
        {
            prc = signedData->eContentIndef;
            psTraceCrypto("Couldn't parse encapsulated content info\n");
            goto LBL_ERR;
        }
        if (end - p < 1)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (*p == ASN_OCTET_STRING)
        {
            p++;
            if ((prc = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
            {
                goto LBL_ERR;
            }
            signedData->eContentLen = len;
            *data = (unsigned char *) p;
            *dataLen = (int32) (end - p);
        }
        else if (*p == (ASN_OCTET_STRING | ASN_CONSTRUCTED))
        {
            p++;
            /* Want to get to the first known length of a component
                OCTET STRING */
            if ((signedData->constructedIndef = getAsnLength32(&p,
                     (uint32_t) (end - p), &len, 1)) < 0)
            {
                prc = signedData->constructedIndef;
                goto LBL_ERR;
            }
            if (end - p < 1)
            {
                prc = PS_LIMIT_FAIL;
                goto LBL_ERR;
            }
            /* First pass is to get the length and test integrity */
            if (*p != ASN_OCTET_STRING)
            {
                prc = PS_PARSE_FAIL;
                goto LBL_ERR;
            }
            p++;
            if ((prc = getAsnLength32(&p, (uint32_t) (end - p),
                     &signedData->eContentLen, 1)) < 0)
            {
                goto LBL_ERR;
            }
            *data = (unsigned char *) p;
            *dataLen = (int32) (end - p);
        }
        else
        {
            prc = PS_PARSE_FAIL;
            goto LBL_ERR;
        }

    }
    else
    {
        /* No content */
        *data = (unsigned char *) p;
        *dataLen = (int32) (end - p);
    }
    *retSignedData = signedData;
    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        matrixCmsFreeParsedSignedData(signedData);
    }
    return prc;
}


/* data is passthrough of the signedData.  excess is leftover ASN.1 that needs
    to become the start of the next sdBuf

    MUST BE SAME POOL THAT IS USED FOR INIT

    User must always call matrixCmsFreeSignedData if made it this far */
int32 matrixCmsUpdateParseSignedData(psPool_t *pool,
    cmsSignedData_t *signedData, unsigned char *sdBuf, uint32 sdBufLen,
    unsigned char **data, uint32 *dataLen, unsigned char **excess,
    uint32 *excessLen)
{
    psX509Cert_t *outcert;
    const unsigned char *p, *end, *tmpLenPtr;
    uint32_t len;
    int32 rc, prc, certIndef;

    *data = *excess = NULL;
    *dataLen = *excessLen = 0;

    if (sdBufLen == 0)
    {
        return MCMS_PARTIAL;
    }

    /* data is ALWAYS for returning plaintext "attached content".  Always
        just deal with any expected content as the first phase of updating
        and return MCMS_PARTIAL until we have it all */
NEXT_COMPONENT:
    if (signedData->eContentLen > 0)
    {
        if (sdBufLen <= signedData->eContentLen)
        {
            signedData->eContentLen -= sdBufLen;
            *data = sdBuf;
            *dataLen = sdBufLen;
            return MCMS_PARTIAL;
        }
        else
        {
            /* Got all signed data.  Excess is returned with MCMS_PARTIAL */
            *data = sdBuf;
            *dataLen = signedData->eContentLen;
            signedData->eContentLen = 0;
            *excess = sdBuf + *dataLen;
            *excessLen = sdBufLen - *dataLen;
            return MCMS_PARTIAL;
        }
    }
    else
    {
        /* Are we looking at the next OCTET STRING component? */
        if (*sdBuf == ASN_OCTET_STRING)
        {
            p = sdBuf;
            end = p + sdBufLen;
            p++; /* OCTET_STRING just parsed */
            if ((prc = getAsnLength32(&p, (uint32_t) (end - p),
                     &signedData->eContentLen, 1)) < 0)
            {
                return prc;
            }
            psAssert(signedData->eContentLen > 0);
            sdBufLen -= (uint32_t) (p - sdBuf);
            sdBuf = (unsigned char *) p;
            goto NEXT_COMPONENT;
        }
    }

    /* Now treat Update similar to Init by returning PS_LIMIT_FAIL the
        rest of the way until we have it all */
    p = sdBuf;
    end = p + sdBufLen;
    prc = PS_PARSE_FAIL;

    /* After Data stuff */
    if (signedData->constructedIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            return PS_LIMIT_FAIL;
        }
        if (p[0] != 0x0 || p[1] != 0x0)
        {
            return PS_PARSE_FAIL;
        }
        p += 2;
    }

    if (signedData->eContentIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            return PS_LIMIT_FAIL;
        }
        if (p[0] != 0x0 || p[1] != 0x0)
        {
            return PS_PARSE_FAIL;
        }
        p += 2;
    }

    if (signedData->encapIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            return PS_LIMIT_FAIL;
        }
        if (p[0] != 0x0 || p[1] != 0x0)
        {
            return PS_PARSE_FAIL;
        }
        p += 2;
    }

    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }

    outcert = NULL;
    /* certificates [0] IMPLICIT CertificateSet OPTIONAL, */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
    {
        p++;

        if ((certIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
        {
            psTraceCrypto("Couldn't parse Certificate length\n");
            return certIndef;
        }
        tmpLenPtr = p;
        if (end - p < 1)
        {
            return PS_LIMIT_FAIL;
        }
        /* Need the entire cert */
        if (end - p < len)
        {
            return PS_LIMIT_FAIL;
        }
        /* CertificateSet ::= SET OF CertificateChoices */
        if ((rc = psX509ParseCert(pool, p, len, &outcert, 0)) < 0)
        {
            psX509FreeCert(outcert);
            psTraceCrypto("Couldn't parse X.509 certificate\n");
            return rc;
        }
        signedData->cert = outcert;
        p += rc;

        if (end - p < 2)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }

        if (certIndef == ASN_UNKNOWN_LEN)
        {
            p += 2;
        }
        else
        {
            len -= (int32) (p - tmpLenPtr);
            if (len > 0)
            {
                /* More certs, but we don't support them.  Check if it's an
                    error or just ignore them */
                if (signedData->version == 1)
                {
                    /* Should not be any more certs */
                    prc = PS_PARSE_FAIL;
                    goto LBL_ERR;
                }
                if (end - p < len)
                {
                    prc = PS_LIMIT_FAIL;
                    goto LBL_ERR;
                }
                p += len;
            }
        }
    }

    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }
    /* crls [1] IMPLICIT RevocationInfoChoices OPTIONAL, */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
    {
        p++;
        psTraceCrypto("TODO: CRL unsupported in Signed-Data\n");
        if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Initial CRL parse error\n");
            goto LBL_ERR;
        }
        /* Skipping */
        p += len;
    }

    /* SignerInfos ::= SET OF SignerInfo */
    if ((rc = matrixCmsParseSignerInfos(pool, p, (int32) (end - p), signedData))
        < 0)
    {
        prc = rc;
        goto LBL_ERR;;
    }
    p += rc;

    /* Final indef 0x0 0x0 byte parse */
    if (signedData->sdIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            mcmsFreeSignerInfos(signedData->signers);
            signedData->signers = NULL;
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (p[0] != 0x0 || p[1] != 0x0)
        {
            return PS_PARSE_FAIL;
        }
        p += 2;
    }
    if (signedData->contentIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            mcmsFreeSignerInfos(signedData->signers);
            signedData->signers = NULL;
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (p[0] != 0x0 || p[1] != 0x0)
        {
            return PS_PARSE_FAIL;
        }
        p += 2;
    }
    if (signedData->initialIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            mcmsFreeSignerInfos(signedData->signers);
            signedData->signers = NULL;
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (p[0] != 0x0 || p[1] != 0x0)
        {
            return PS_PARSE_FAIL;
        }
        p += 2;
    }

    /* should be the end */
    psAssert(p == end);
    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        if (outcert)
        {
            psX509FreeCert(outcert);
        }
    }
    return prc;


}

int32 matrixCmsFinalParseSignedData(psPool_t *pool, cmsSignedData_t *signedData,
    const unsigned char *hash, uint32 hashLen, psX509Cert_t *validationCert)
{
    int32 rc;
    cmsSignerInfos_t *signers;
    psPubKey_t *key;
    psX509Cert_t *cert;
    psDigestContext_t ctx;

#   ifdef USE_ECC
    psEccKey_t *eccKey;
    int32 eccRet;
#   endif
    unsigned char hashOut[MAX_HASH_SIZE];
    unsigned char sigOut[MAX_HASH_SIZE];


    if (signedData == NULL || signedData->signers == NULL)
    {
        return PS_ARG_FAIL;
    }

    /* FUTURE: only working with first signer in a potential list of signers */
    signers = signedData->signers;

    /* Where are we getting the cert from?  It doesn't have to be in the
        signedData structure but we'll look there first because it really
        should be.  If the user provided one, we'll confirm it matches */
    cert = NULL;
    if (signers->signerId->version == 1)
    {
        /* DN and serial number method */
        cert = signedData->cert;
        while (cert)
        {
            /* Remember it's the Issuer DN in the ID for some reason */
            if ((Memcmp(cert->issuer.hash, signers->signerId->dn.hash,
                     SHA1_HASH_SIZE) == 0) && (cert->serialNumberLen ==
                                               signers->signerId->snLen) && (Memcmp(cert->serialNumber,
                                                                                 signers->signerId->sn, cert->serialNumberLen) == 0))
            {
                break;
            }
            cert = cert->next;
        }
        /* Did the user provide one? */
        if (validationCert)
        {
            if (cert)
            {
                /* They should match exactly */
                if ((Memcmp(validationCert->subject.hash, cert->subject.hash,
                         SHA1_HASH_SIZE) != 0) || (cert->serialNumberLen !=
                                                   validationCert->serialNumberLen) ||
                    (Memcmp(cert->serialNumber, validationCert->serialNumber,
                         cert->serialNumberLen) != 0))
                {
                    return MCMS_SIG_FAIL_BAD_USER_CERT;
                }
            }
            else
            {
                cert = validationCert;
                /* We don't have one yet. Should match the signerId */
                if ((Memcmp(cert->issuer.hash, signers->signerId->dn.hash,
                         SHA1_HASH_SIZE) != 0) || (cert->serialNumberLen !=
                                                   signers->signerId->snLen) || (Memcmp(cert->serialNumber,
                                                                                     signers->signerId->sn, cert->serialNumberLen) != 0))
                {
                    cert = NULL;
                }
            }
        }
    }
    else
    {
#   ifdef USE_FULL_CERT_PARSE
        cert = signedData->cert;
        while (cert)
        {
            if ((&cert->extensions.sk)->len != 0)
            {
                if (Memcmp((&cert->extensions.sk)->id, signers->signerId->sn,
                        (&cert->extensions.sk)->len) == 0)
                {
                    break;
                }
            }
            cert = cert->next;
        }
        /* Did the user provide one? */
        if (validationCert)
        {
            if (cert)
            {
                /* They should match exactly */
                if (((&cert->extensions.sk)->len !=
                     (&validationCert->extensions.sk)->len)
                    || Memcmp((&validationCert->extensions.sk)->id,
                        (&cert->extensions.sk)->id, (&cert->extensions.sk)->len)
                    != 0)
                {
                    return MCMS_SIG_FAIL_BAD_USER_CERT;
                }
            }
            else
            {
                if ((&validationCert->extensions.sk)->len != 0)
                {
                    cert = validationCert;
                    /* We don't have one yet. Should match the signerId */
                    if (Memcmp((&cert->extensions.sk)->id, signers->signerId->sn,
                            signers->signerId->snLen) != 0)
                    {
                        cert = NULL;
                    }
                }
            }
        }
#   else
        psTraceCrypto("Enable USE_FULL_CERT_PARSE in cryptoConfig.h\n");
        return PS_UNSUPPORTED_FAIL;
#   endif
    }

    /* If we come out of all of that will no cert, we just didn't have it. */
    if (cert == NULL)
    {
        return MCMS_SIG_FAIL_NO_CERT;
    }

    /* Find the hash operators.  Overwrite the signers->digestLen as well
        just in case there were no signedAttrs to assign it then */
    if (signers->digestId == OID_SHA1_ALG)
    {
        signers->digestLen = SHA1_HASH_SIZE;
    }
    else if (signers->digestId == OID_SHA256_ALG)
    {
        signers->digestLen = SHA256_HASH_SIZE;
    }
    else if (signers->digestId == OID_SHA384_ALG)
    {
        signers->digestLen = SHA384_HASH_SIZE;
    }
    else if (signers->digestId == OID_SHA512_ALG)
    {
        signers->digestLen = SHA512_HASH_SIZE;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    /*  The result of the message digest calculation process depends on
        whether the signedAttrs field is present.  When the field is absent,
        the result is just the message digest of the content as described
        above.  When the field is present, however, the result is the message
        digest of the complete DER encoding of the SignedAttrs value
        contained in the signedAttrs field. */
    if (signedData->signers->signedAttrs)
    {
        switch (signers->digestLen)
        {
        case SHA1_HASH_SIZE:
            psSha1PreInit(&ctx.sha1);
            psSha1Init(&ctx.sha1);
            psSha1Update(&ctx.sha1, signedData->signers->signedAttrs,
                signedData->signers->signedAttrsLen);
            psSha1Final(&ctx.sha1, hashOut);
            break;
        case SHA256_HASH_SIZE:
            psSha256PreInit(&ctx.sha256);
            psSha256Init(&ctx.sha256);
            psSha256Update(&ctx.sha256, signedData->signers->signedAttrs,
                signedData->signers->signedAttrsLen);
            psSha256Final(&ctx.sha256, hashOut);
            break;
        case SHA384_HASH_SIZE:
            psSha384PreInit(&ctx.sha384);
            psSha384Init(&ctx.sha384);
            psSha384Update(&ctx.sha384, signedData->signers->signedAttrs,
                signedData->signers->signedAttrsLen);
            psSha384Final(&ctx.sha384, hashOut);
            break;
        case SHA512_HASH_SIZE:
            psSha512PreInit(&ctx.sha512);
            psSha512Init(&ctx.sha512);
            psSha512Update(&ctx.sha512, signedData->signers->signedAttrs,
                signedData->signers->signedAttrsLen);
            psSha512Final(&ctx.sha512, hashOut);
            break;
        default:
            break;
        }
    }
    else
    {
        /* Caller passed it in */
        if (signers->digestLen != hashLen)
        {
            psTraceIntCrypto("User hashLen %d does not match expected\n",
                hashLen);
            return PS_ARG_FAIL;
        }
        Memcpy(hashOut, hash, signers->digestLen);
    }

    /* Find the key type and run the signature verificateion*/
    if (cert->pubKeyAlgorithm == OID_RSA_KEY_ALG)
    {
#   ifdef USE_RSA
        key = &cert->publicKey;
        if ((rc = pubRsaDecryptSignedElement(pool, &key->key.rsa, signers->sig,
                 signers->sigLen, sigOut, signers->digestLen, NULL)) < 0)
        {
            return MCMS_SIG_FAIL_SIGNATURE_FAIL;
        }
        if (Memcmp(hashOut, sigOut, signers->digestLen) != 0)
        {
            return MCMS_SIG_FAIL_SIGNATURE_MISMATCH;
        }
#   else
        return PS_UNSUPPORTED_FAIL;
#   endif
    }
    else if (cert->pubKeyAlgorithm == OID_ECDSA_KEY_ALG)
    {
#   ifdef USE_ECC
        eccKey = &cert->publicKey.key.ecc;
        /* psTraceBytes("EC SIG", signers->sig, signers->sigLen); */
        if ((rc = psEccDsaVerify(pool, eccKey, hashOut, signers->digestLen,
                 signers->sig, signers->sigLen, &eccRet, NULL)) < 0)
        {
            return MCMS_SIG_FAIL_SIGNATURE_FAIL;
        }
        if (eccRet != 1)
        {
            return MCMS_SIG_FAIL_SIGNATURE_MISMATCH;
        }
#   else
        return PS_UNSUPPORTED_FAIL;
#   endif
    }

    /* What about the content hash itself?  That should match as well... if
        provided in the signedAttrs */
    if (signers->digest)
    {
        if (Memcmp(hash, signers->digest, signers->digestLen) != 0)
        {
            return MCMS_SIG_FAIL_CONTENT_HASH_MISMATCH;
        }
    }
    return PS_SUCCESS;
}
#  endif


#  ifdef USE_MCMS_ATOMIC_SD_PARSE
/******************************************************************************/
/*
    Primary Signed-Data Content Type parser.  Starts parsing from the
    General Syntax
 */
int32 matrixCmsParseSignedData(psPool_t *pool, unsigned char *sdBuf,
    uint32 sdBufLen, cmsSignedData_t **retSignedData, int32 flags)
{
    cmsSignedData_t *signedData;
    psX509Cert_t *outcert;
    const unsigned char *p, *end, *tmpLenPtr;
    psSize_t tmpLen, paramLen;
    uint32_t len, cdLen;
    int32 initialIndef, encapIndef, certIndef, contentIndef;
    int32 sdIndef, rc, prc, eContentIndef, intOut;
    int32 parseflags = 0;

    p = sdBuf;
    end = p + sdBufLen;

    prc = PS_PARSE_FAIL;
    *retSignedData = NULL;

    if (!(flags & MCMS_FLAGS_NO_CONTENT_INFO))
    {
        /* General Syntax content is going to tell us what it is
            ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */

        if ((initialIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1))
            < 0)
        {
            /* The very first length is given special return code if length
                provided is too short */
            if (initialIndef == PS_LIMIT_FAIL)
            {
                return MCMS_PARTIAL;
            }
            psTraceCrypto("Initial parse error for signed data type\n");
            return PS_PARSE_FAIL;
        }
        if (mcmsParsePkcsOid(&p, (uint32_t) (end - p), &tmpLen) < 0)
        {
            psTraceCrypto("Error parsing OID for signed data type\n");
            return PS_PARSE_FAIL;
        }
        /* len is OID id */
        if (tmpLen != CMS_PKCS7_SIGNED_DATA)
        {
            psTraceIntCrypto("Expected signedData type but got %d", tmpLen);
            return PS_PARSE_FAIL;
        }

        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Expected EXPLICIT content for contentInfo");
            return PS_PARSE_FAIL;
        }
        p++;

        if ((contentIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("getAsnLength failure in ContentType parse\n");
            return PS_PARSE_FAIL;
        }
    }
    else
    {
        initialIndef = contentIndef = 0;
    }

    /* OK, we've passed the General Syntax

        SignedData ::= SEQUENCE {
            version CMSVersion,
            digestAlgorithms DigestAlgorithmIdentifiers,
            encapContentInfo EncapsulatedContentInfo,
            certificates [0] IMPLICIT CertificateSet OPTIONAL,
            crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
            signerInfos SignerInfos }

       DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier

       SignerInfos ::= SET OF SignerInfo
     */
    if ((sdIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1)) < 0)
    {
        psTraceCrypto("Initial parse error SignedData\n");
        return PS_PARSE_FAIL;
    }

    /* Set up the structure to hold the info we want to persist */
    if ((signedData = psMalloc(pool, sizeof(cmsSignedData_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(signedData, 0, sizeof(cmsSignedData_t));
    signedData->pool = pool;

    /*  CMSVersion ::= INTEGER { v0(0), v1(1), v2(2), v3(3), v4(4), v5(5) } */
    if (getAsnInteger(&p, (uint32) (end - p), &signedData->version) < 0)
    {
        psTraceCrypto("Error getting version for signed data\n");
        goto LBL_ERR;
    }

    /* IF ((certificates is present) AND
            (any certificates with a type of other are present)) OR
            ((crls is present) AND
            (any crls with a type of other are present))
         THEN version MUST be 5
         ELSE
            IF (certificates is present) AND
               (any version 2 attribute certificates are present)
            THEN version MUST be 4
            ELSE
               IF ((certificates is present) AND
                  (any version 1 attribute certificates are present)) OR
                  (any SignerInfo structures are version 3) OR
                  (encapContentInfo eContentType is other than id-data)
               THEN version MUST be 3
               ELSE version MUST be 1 */

    /* DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier */
    if (getAsnSet32(&p, (uint32_t) (end - p), &cdLen, 1) < 0)
    {
        psTraceCrypto("Initial parse error DigestAlgorithmIdentifiers\n");
        goto LBL_ERR;
    }
    while (cdLen > 0)
    {
        tmpLenPtr = p;
        /* DigestAlgorithmIdentifier ::= AlgorithmIdentifier */
        if (getAsnAlgorithmIdentifier(&p, (int32) (end - p), &intOut,
                &paramLen) < 0)
        {
            psTraceCrypto("Error getting DigestAlgorithmIdentifier OID\n");
            goto LBL_ERR;
        }
        p += paramLen;
        /* Do we support this digest? */
        if (intOut != OID_SHA1_ALG && intOut != OID_SHA256_ALG &&
            intOut != OID_SHA384_ALG && intOut != OID_SHA512_ALG)
        {
            psTraceIntCrypto("Unsupported DigestAlgorithm %d\n", intOut);
            prc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        signedData->digestId = intOut; /* Not used again so overwrite is fine */
        cdLen -= (int32) (p - tmpLenPtr);
    }
    /*
        EncapsulatedContentInfo ::= SEQUENCE {
        eContentType ContentType,
        eContent [0] EXPLICIT OCTET STRING OPTIONAL }

       ContentType ::= OBJECT IDENTIFIER */
    if ((encapIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1)) < 0)
    {
        psTraceCrypto("Initial parse error EncapsulatedContentInfo\n");
        goto LBL_ERR;
    }
    tmpLenPtr = p;
    /*  The optional omission of the eContent within the
        EncapsulatedContentInfo field makes it possible to construct
        "external signatures".  In the case of external signatures, the
        content being signed is absent from the EncapsulatedContentInfo value
        included in the signed-data content type.  If the eContent value
        within EncapsulatedContentInfo is absent, then the signatureValue is
        calculated and the eContentType is assigned as though the eContent
        value was present.

        In the degenerate case where there are no signers, the
        EncapsulatedContentInfo value being "signed" is irrelevant.  In this
        case, the content type within the EncapsulatedContentInfo value being
        "signed" MUST be id-data (as defined in Section 4), and the content
        field of the EncapsulatedContentInfo value MUST be omitted.
     */
    if (mcmsParsePkcsOid(&p, (uint32) (end - p), &signedData->eContentType) < 0)
    {
        psTraceCrypto("Error parsing OID for eContentType\n");
        goto LBL_ERR;
    }

    if (encapIndef == ASN_UNKNOWN_LEN &&
            len > 2 &&
            p[0] == 0x00 &&
            p[1] == 0x00)
    {
        goto eContentEmpty;
    }
    len -= (uint32_t) (p - tmpLenPtr);
    if (len)
    {
        /* eContent exists */
        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Initial parse error for eContent\n");
            goto LBL_ERR;
        }
        p++;
        if ((eContentIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Couldn't parse encapsulated content info\n");
            goto LBL_ERR;
        }
        if (*p == ASN_OCTET_STRING)
        {
            p++;
            if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                (uint32_t) (end - p) < len)
            {
                goto LBL_ERR;
            }
            if ((signedData->eContent = psMalloc(pool, len)) == NULL)
            {
                prc = PS_MEM_FAIL;
                goto LBL_ERR;
            }
            Memcpy(signedData->eContent, p, len);
            signedData->eContentLen = len;
            p += len;
        }
        else if (*p == (ASN_OCTET_STRING | ASN_CONSTRUCTED))
        {
            p++;
            if (getAsnConstructedOctetString32(pool, &p, (uint32_t) (end - p),
                    &signedData->eContent, &signedData->eContentLen) < 0)
            {
                goto LBL_ERR;
            }
        }
        else
        {
            goto LBL_ERR;
        }
        if (eContentIndef == ASN_UNKNOWN_LEN)
        {
            p += 2;
        }
    }
eContentEmpty:
    if (encapIndef == ASN_UNKNOWN_LEN)
    {
        p += 2;
    }

    /* certificates [0] IMPLICIT CertificateSet OPTIONAL, */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
    {
        p++;

        if ((certIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Couldn't parse Certificate length\n");
            goto LBL_ERR;
        }
        tmpLenPtr = p;
        if (flags & MCMS_FLAGS_PD_CERT_STORE_ONLY)
        {
            parseflags = CERT_STORE_UNPARSED_BUFFER |
                        CERT_ALLOW_BUNDLE_PARTIAL_PARSE;
        }
        /* CertificateSet ::= SET OF CertificateChoices */
        if ((rc = psX509ParseCert(pool, p, len, &outcert, parseflags)) < 0)
        {
            psX509FreeCert(outcert);
            psTraceCrypto("Couldn't parse X.509 certificate\n");
            prc = rc;
            goto LBL_ERR;
        }
        signedData->cert = outcert;
        p += rc; //len;

        if (certIndef == ASN_UNKNOWN_LEN)
        {
            p += 2;
        }
        else
        {
            len -= (int32) (p - tmpLenPtr);
            if (len > 0)
            {
                /* More certs, but we don't support them.  Check if it's an
                    error or just ignore them */
                if (signedData->version == 1)
                {
                    /* Should not be any more certs */
                    goto LBL_ERR;
                }
                p += len;
            }
        }
    }


    /* crls [1] IMPLICIT RevocationInfoChoices OPTIONAL, */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
    {
        p++;
        psTraceCrypto("TODO: CRL unsupported in Signed-Data\n");
        if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Initial CRL parse error\n");
            goto LBL_ERR;
        }
        /* Skipping */
        p += len;
    }

    /* SignerInfos ::= SET OF SignerInfo */
    if ((rc = matrixCmsParseSignerInfos(pool, p, (int32) (end - p), signedData))
        < 0)
    {
        prc = rc;
        goto LBL_ERR;;
    }
    p += rc;

    if (sdIndef == ASN_UNKNOWN_LEN)
    {
        p += 2;
    }
    if (contentIndef == ASN_UNKNOWN_LEN)
    {
        p += 2;
    }
    if (initialIndef == ASN_UNKNOWN_LEN)
    {
        p += 2;
    }

    /* should be the end */
    psAssert(p == end);
    *retSignedData = signedData;
    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        matrixCmsFreeParsedSignedData(signedData);
    }
    return prc;
}

#   ifdef MATRIX_USE_FILE_SYSTEM
int32 matrixCmsParseSignedDataFile(psPool_t *pool, char *file,
    cmsSignedData_t **signedData)
{
    unsigned char *sdBuf, *DERout;
    unsigned char *start;
    psSizeL_t sdBufLen;
    psRes_t rc;
    psSize_t BASElen, DERlen;

    if (file == NULL)
    {
        psTraceCrypto("No fileName passed to matrixParseSignedDataFile\n");
        return PS_ARG_FAIL;
    }
    if ((rc = psGetFileBuf(pool, file, &sdBuf, &sdBufLen)) < PS_SUCCESS)
    {
        return rc;
    }
    start = NULL;

    BASElen = sdBufLen;
    start = sdBuf;

    /* Base64 decode */
    DERout = psMalloc(pool, BASElen);
    if (DERout == NULL)
    {
        psFree(sdBuf, pool);
        psError("Memory allocation error in matrixParseSignedDataFile\n");
        return PS_MEM_FAIL;
    }
    DERlen = BASElen;
    if ((rc = psBase64decode((unsigned char *) start, BASElen, DERout,
             &DERlen)) != 0)
    {
        psTraceCrypto("Error base64 decode of signed data file\n");
        psFree(DERout, pool);
        psFree(sdBuf, pool);
        return rc;
    }
    psFree(sdBuf, pool);

    if ((rc = matrixCmsParseSignedData(pool, DERout, DERlen, signedData, 0))
        < 0)
    {
        psFree(DERout, pool);
        return rc;
    }

    psFree(DERout, pool);

    return 0;
}
#   endif /* MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/
/*

    Negative error returns:
    PS_ARG_FAIL - Bad function call
    PS_UNSUPPORTED_FAIL - Unsupported algorithm encountered

    MCMS_SIG_FAIL_CONTENT_MISMATCH - either user supplied content didn't match
        any existing content or the SMIME content didn't match eContent
    MCMS_SIG_FAIL_NO_CONTENT - There was no source of content at all
    MCMS_SIG_FAIL_SIGNATURE_MISMATCH - The sig operation worked but no match
    MCMS_SIG_FAIL_CONTENT_HASH_MISMATCH - The signature worked but the hash
        of the content didn't match.
    MCMS_SIG_FAIL_BAD_USER_CERT - User cert didn't match embedded cert
    MCMS_SIG_FAIL_SIGNATURE_FAIL - Internal sig validation function failure

    SUCCESS:
    CM_SIG_PASSED - 0 - The SD checked out
 */
int32 matrixCmsConfirmSignature(psPool_t *pool, cmsSignedData_t *signedData,
    unsigned char *data, int32 dataLen, psX509Cert_t *validationCert)
{
    int32 contentLen;
    psDigestContext_t hash;
    cmsSignerInfos_t *signers;
    psX509Cert_t *cert;
    psPubKey_t *key;

#   ifdef USE_ECC
    psEccKey_t *eccKey;
    int32 eccRet;
#   endif
    unsigned char *content;
    unsigned char hashOut[MAX_HASH_SIZE];
    unsigned char sigOut[MAX_HASH_SIZE];


    if (signedData == NULL || signedData->signers == NULL)
    {
        return PS_ARG_FAIL;
    }

    /* Determine where we are getting the message content from */
    if (data != NULL)
    {
        /* If data exists, we'll give that precedence because the caller
            explicitly passed that in so assume they know what they want */
        content = data;
        contentLen = dataLen;
        /* But check to see if there is a mismatch if more than one source */
        if (signedData->eContent != NULL)
        {
            if (signedData->eContentLen != (uint32) contentLen ||
                (Memcmp(signedData->eContent, content, contentLen) != 0))
            {
                psTraceCrypto("User content didn't match eContent\n");
                return MCMS_SIG_FAIL_CONTENT_MISMATCH;
            }
        }
    }
    else if (signedData->eContent)
    {
        /* Lastly, fall to the eContent contained in the structure itself.
            Will be testing the integrity of the SD */
        content = signedData->eContent;
        contentLen = signedData->eContentLen;
    }
    else
    {
        psTraceCrypto("No content to test in matrixCmsConfirmSignature\n");
        return MCMS_SIG_FAIL_NO_CONTENT;
    }

    /* FUTURE: only working with first signer in a potential list of signers */
    signers = signedData->signers;

    /* Where are we getting the cert from?  It doesn't have to be in the
        signedData structure but we'll look there first because it really
        should be.  If the user provided one, we'll confirm it matches */
    cert = NULL;
    if (signers->signerId->version == 1)
    {
        /* DN and serial number method */
        cert = signedData->cert;
        while (cert)
        {
            /* Remember it's the Issuer DN in the ID for some reason */
            if ((Memcmp(cert->issuer.hash, signers->signerId->dn.hash,
                     SHA1_HASH_SIZE) == 0) && (cert->serialNumberLen ==
                                               signers->signerId->snLen) && (Memcmp(cert->serialNumber,
                                                                                 signers->signerId->sn, cert->serialNumberLen) == 0))
            {
                break;
            }
            cert = cert->next;
        }
        /* Did the user provide one? */
        if (validationCert)
        {
            if (cert)
            {
                /* They should match exactly */
                if ((Memcmp(validationCert->subject.hash, cert->subject.hash,
                         SHA1_HASH_SIZE) != 0) || (cert->serialNumberLen !=
                                                   validationCert->serialNumberLen) ||
                    (Memcmp(cert->serialNumber, validationCert->serialNumber,
                         cert->serialNumberLen) != 0))
                {
                    return MCMS_SIG_FAIL_BAD_USER_CERT;
                }
            }
            else
            {
                cert = validationCert;
                /* We don't have one yet. Should match the signerId */
                if ((Memcmp(cert->issuer.hash, signers->signerId->dn.hash,
                         SHA1_HASH_SIZE) != 0) || (cert->serialNumberLen !=
                                                   signers->signerId->snLen) || (Memcmp(cert->serialNumber,
                                                                                     signers->signerId->sn, cert->serialNumberLen) != 0))
                {
                    cert = NULL;
                }
            }
        }
    }
    else
    {
#   ifdef USE_FULL_CERT_PARSE
        cert = signedData->cert;
        while (cert)
        {
            if ((&cert->extensions.sk)->len != 0)
            {
                if (Memcmp((&cert->extensions.sk)->id, signers->signerId->sn,
                        (&cert->extensions.sk)->len) == 0)
                {
                    break;
                }
            }
            cert = cert->next;
        }
        /* Did the user provide one? */
        if (validationCert)
        {
            if (cert)
            {
                /* They should match exactly */
                if (((&cert->extensions.sk)->len !=
                     (&validationCert->extensions.sk)->len)
                    || Memcmp((&validationCert->extensions.sk)->id,
                        (&cert->extensions.sk)->id, (&cert->extensions.sk)->len)
                    != 0)
                {
                    return MCMS_SIG_FAIL_BAD_USER_CERT;
                }
            }
            else
            {
                if ((&validationCert->extensions.sk)->len != 0)
                {
                    cert = validationCert;
                    /* We don't have one yet. Should match the signerId */
                    if (Memcmp((&cert->extensions.sk)->id, signers->signerId->sn,
                            signers->signerId->snLen) != 0)
                    {
                        cert = NULL;
                    }
                }
            }
        }
#   else
        psTraceCrypto("Enable USE_FULL_CERT_PARSE in cryptoConfig.h\n");
        return PS_UNSUPPORTED_FAIL;
#   endif
    }

    /* If we come out of all of that will no cert, we just didn't have it. */
    if (cert == NULL)
    {
        return MCMS_SIG_FAIL_NO_CERT;
    }

    /* Find the hash operators.  Overwrite the signers->digestLen as well
        just in case there were no signedAttrs to assign it then

        The result of the message digest calculation process depends on
        whether the signedAttrs field is present.  When the field is absent,
        the result is just the message digest of the content as described
        above.  When the field is present, however, the result is the message
        digest of the complete DER encoding of the SignedAttrs value
        contained in the signedAttrs field.     */
    if (signers->digestId == OID_SHA1_ALG)
    {
        psSha1PreInit(&hash.u.sha1);
        psSha1Init(&hash.u.sha1);
        if (signedData->signers->signedAttrs)
        {
            psSha1Update(&hash.u.sha1, signedData->signers->signedAttrs,
                signedData->signers->signedAttrsLen);
        }
        else
        {
            psSha1Update(&hash.u.sha1, content, contentLen);
        }
        psSha1Final(&hash.u.sha1, hashOut);
        signers->digestLen = SHA1_HASH_SIZE;
    }
    else if (signers->digestId == OID_SHA256_ALG)
    {
        psSha256PreInit(&hash.u.sha256);
        psSha256Init(&hash.u.sha256);
        if (signedData->signers->signedAttrs)
        {
            psSha256Update(&hash.u.sha256, signedData->signers->signedAttrs,
                signedData->signers->signedAttrsLen);
        }
        else
        {
            psSha256Update(&hash.u.sha256, content, contentLen);
        }
        psSha256Final(&hash.u.sha256, hashOut);
        signers->digestLen = SHA256_HASH_SIZE;
    }
    else if (signers->digestId == OID_SHA384_ALG)
    {
        psSha384PreInit(&hash.u.sha384);
        psSha384Init(&hash.u.sha384);
        if (signedData->signers->signedAttrs)
        {
            psSha384Update(&hash.u.sha384, signedData->signers->signedAttrs,
                signedData->signers->signedAttrsLen);
        }
        else
        {
            psSha384Update(&hash.u.sha384, content, contentLen);
        }
        psSha384Final(&hash.u.sha384, hashOut);
        signers->digestLen = SHA384_HASH_SIZE;
    }
    else if (signers->digestId == OID_SHA512_ALG)
    {
        psSha512PreInit(&hash.u.sha512);
        psSha512Init(&hash.u.sha512);
        if (signedData->signers->signedAttrs)
        {
            psSha512Update(&hash.u.sha512, signedData->signers->signedAttrs,
                signedData->signers->signedAttrsLen);
        }
        else
        {
            psSha512Update(&hash.u.sha512, content, contentLen);
        }
        psSha512Final(&hash.u.sha512, hashOut);
        signers->digestLen = SHA512_HASH_SIZE;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    /* Find the key type and run the signature verification */
    if (cert->pubKeyAlgorithm == OID_RSA_KEY_ALG)
    {
#   ifdef USE_RSA
        /* pubRsaDecryptSignedElement may overwrite signature =>
           use temporary. */
        unsigned char tmpsig[4096 / 8 + 1];
        int32 rc;

        key = &cert->publicKey;
        if (signers->sigLen > sizeof tmpsig)
        {
            return MCMS_SIG_FAIL_SIGNATURE_FAIL;
        }
        Memcpy(tmpsig, signers->sig, signers->sigLen);

        rc = pubRsaDecryptSignedElement(
                pool, &key->key.rsa, tmpsig,
                signers->sigLen, sigOut, signers->digestLen, NULL);
        if (rc < 0)
        {
            return MCMS_SIG_FAIL_SIGNATURE_FAIL;
        }
        if (memcmpct(hashOut, sigOut, signers->digestLen) != 0)
        {
            return MCMS_SIG_FAIL_SIGNATURE_MISMATCH;
        }
#   else
        return PS_UNSUPPORTED_FAIL;
#   endif
    }
    else if (cert->pubKeyAlgorithm == OID_ECDSA_KEY_ALG)
    {
#   ifdef USE_ECC
        int32 rc;

        eccKey = &cert->publicKey.key.ecc;
        /* psTraceBytes("EC SIG", signers->sig, signers->sigLen); */
        rc = psEccDsaVerify(pool, eccKey, hashOut, signers->digestLen,
                            signers->sig, signers->sigLen, &eccRet, NULL);
        if (rc < 0)
        {
            return MCMS_SIG_FAIL_SIGNATURE_FAIL;
        }
        if (eccRet != 1)
        {
            return MCMS_SIG_FAIL_SIGNATURE_MISMATCH;
        }
#   else
        return PS_UNSUPPORTED_FAIL;
#   endif
    }

    /* What about the content hash itself?  That should match as well... if
        provided in the signedAttrs */
    if (signers->digest)
    {
        switch (signers->digestLen)
        {
        case SHA1_HASH_SIZE:
            psSha1Init(&hash.u.sha1);
            psSha1Update(&hash.u.sha1, content, contentLen);
            psSha1Final(&hash.u.sha1, hashOut);
            break;
        case SHA256_HASH_SIZE:
            psSha256Init(&hash.u.sha256);
            psSha256Update(&hash.u.sha256, content, contentLen);
            psSha256Final(&hash.u.sha256, hashOut);
            break;
        case SHA384_HASH_SIZE:
            psSha384Init(&hash.u.sha384);
            psSha384Update(&hash.u.sha384, content, contentLen);
            psSha384Final(&hash.u.sha384, hashOut);
            break;
        case SHA512_HASH_SIZE:
            psSha512Init(&hash.u.sha512);
            psSha512Update(&hash.u.sha512, content, contentLen);
            psSha512Final(&hash.u.sha512, hashOut);
            break;
        default:
            break;
        }

        if (Memcmp(hashOut, signers->digest, signers->digestLen) != 0)
        {
            return MCMS_SIG_FAIL_CONTENT_HASH_MISMATCH;
        }
    }
    return PS_SUCCESS;
}
#  endif /* USE_MCMS_ATOMIC_SD_PARSE */

/*
    Returns < 0 on error or number of bytes parsed on success.
 */
static int32 matrixCmsParseSignerInfos(psPool_t *pool, const unsigned char *buf,
    uint32 bufLen, cmsSignedData_t *signedData)
{
    cmsSignerInfos_t *signer = NULL, *next;
    cmsSignerId_t *signerId;
    const unsigned char *p, *end, *overallLenPtr, *attribLenPtr;
    int32 content = 0, rc, intOut;
    psSize_t paramLen, oid;
    uint32_t len, attribLen, overallSetLen;

    p = buf;
    end = p + bufLen;

    /* For stream parsing, we are making sure we get all of this */
    if ((rc = getAsnSet32(&p, (int32) (end - p), &overallSetLen, 1)) < 0)
    {
        psTraceCrypto("Initial parse error for SignerInfos\n");
        return rc;
    }

    while (overallSetLen > 0)
    {
        overallLenPtr = p;

        if (signedData->signers == NULL)
        {
            if ((signer = psMalloc(pool, sizeof(cmsSignerInfos_t))) == NULL)
            {
                return PS_MEM_FAIL;
            }
            Memset(signer, 0, sizeof(cmsSignerInfos_t));
            signer->pool = pool;
            signedData->signers = signer;
        }
        else
        {
            if ((next = psMalloc(pool, sizeof(cmsSignerInfos_t))) == NULL)
            {
                return PS_MEM_FAIL;
            }
            Memset(next, 0, sizeof(cmsSignerInfos_t));
            next->pool = pool;
            signer->next = next;
            signer = signer->next;
        }
        /*
            SignerInfo ::= SEQUENCE {
                version CMSVersion,
                sid SignerIdentifier,
                digestAlgorithm DigestAlgorithmIdentifier,
                signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
                signatureAlgorithm SignatureAlgorithmIdentifier,
                signature SignatureValue,
                unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL } */
        if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 1) < 0)
        {
            psTraceCrypto("Initial parse error for SignerInfo\n");
            return PS_PARSE_FAIL;
        }
        /*      CMSVersion is the syntax version number. If the SignerIdentifier is
            the CHOICE issuerAndSerialNumber, then the version MUST be 1.  If
            the SignerIdentifier is subjectKeyIdentifier, then the version
            MUST be 3. */
        if (getAsnInteger(&p, (uint32) (end - p), &intOut) < 0)
        {
            psTraceCrypto("Error getting version for SignerInfo\n");
            return PS_PARSE_FAIL;
        }

        /* SignerIdentifier ::= CHOICE {
            issuerAndSerialNumber IssuerAndSerialNumber,
            subjectKeyIdentifier [0] SubjectKeyIdentifier } */
        if ((signerId = psMalloc(pool, sizeof(cmsSignerId_t))) == NULL)
        {
            return PS_MEM_FAIL;
        }
        Memset(signerId, 0, sizeof(cmsSignerId_t));
        signer->signerId = signerId;
        signerId->version = intOut;
        if (intOut == 1)
        {
            /*
                IssuerAndSerialNumber ::= SEQUENCE {
                issuer Name,
                serialNumber CertificateSerialNumber } */
            if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 0) < 0)
            {
                psTraceCrypto("Initial parse error SignerInfo\n");
                return PS_PARSE_FAIL;
            }
            Memset(&signerId->dn, 0, sizeof(x509DNattributes_t));
            if ((rc = psX509GetDNAttributes(pool, &p, (uint32) (end - p),
                     &signerId->dn, 0)) < 0)
            {
                psTraceCrypto("Couldn't parse issuer DN attributes\n");
                return rc;
            }
            if ((rc = getSerialNum(pool, &p, (uint32) (end - p), &signerId->sn,
                     &signerId->snLen)) < 0)
            {
                psTraceCrypto("IssuerAndSerialNumber serialNum parse error\n");
                return rc;
            }
        }
        else if (intOut == 3)
        {
            if (*p++ != (ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE) ||
                getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                (uint32_t) (end - p) < len)
            {
                psTraceCrypto("Error parsing subjectKeyId extension\n");
                return PS_PARSE_FAIL;
            }
            signerId->snLen = len;
            if ((signerId->sn = psMalloc(pool, len)) == NULL)
            {
                return PS_MEM_FAIL;
            }
            Memcpy(signerId->sn, p, len);
            p += len;
        }
        else
        {
            psTraceIntCrypto("Bad SignerInfo CMSVersion %d\n", intOut);
            return PS_PARSE_FAIL;
        }

        /* DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            The message digest algorithm SHOULD be among those
            listed in the digestAlgorithms field of the associated SignerData.
            Implementations MAY fail to validate signatures that use a digest
            algorithm that is not included in the SignedData digestAlgorithms
            set. */
        if (getAsnAlgorithmIdentifier(&p, (int32) (end - p), &intOut,
                &paramLen) < 0)
        {
            psTraceCrypto("Error getting OID for DigestAlgorithmIdentifier\n");
            return PS_PARSE_FAIL;
        }
        p += paramLen;
        /* Do we support this digest? */
        if (intOut != OID_SHA1_ALG && intOut != OID_SHA256_ALG &&
            intOut != OID_SHA384_ALG && intOut != OID_SHA512_ALG)
        {
            psTraceIntCrypto("Unsupported DigestAlgorithm %d\n", intOut);
            return PS_PARSE_FAIL;
        }
        signer->digestId = intOut;

        /*      signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,

            signedAttrs is a collection of attributes that are signed. */
        if (signedData->eContentType != CMS_PKCS7_DATA)
        {
            /* The field is optional, but it MUST be present if the content
                type of the EncapsulatedContentInfo value being signed is not
                id-data. */
            if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
            {
                psTraceIntCrypto("signedAttrs must exist for %d\n",
                    signedData->eContentType);
                return PS_PARSE_FAIL;
            }
        }
        if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            content = 1;
            attribLenPtr = p;
            /*  If the field is present, it MUST contain, at a minimum, the
                following two attributes:

                A content-type attribute having as its value the content type
                of the EncapsulatedContentInfo value being signed.  Section
                11.1 defines the content-type attribute.  However, the
                content-type attribute MUST NOT be used as part of a
                countersignature unsigned attribute as defined in Section 11.4.

                A message-digest attribute, having as its value the message
                digest of the content.  Section 11.2 defines the message-digest
                attribute. */
            p++;
            if (getAsnLength32(&p, (uint32_t) (end - p), &attribLen, 0) < 0 ||
                (uint32_t) (end - p) < attribLen)
            {
                psTraceCrypto("Initial parse error for signedAttrs\n");
                return PS_FAILURE;
            }
            /* Set aside the entire signedAttrs for signature validation */
            signer->signedAttrsLen = attribLen + (p - attribLenPtr);
            if ((signer->signedAttrs = psMalloc(pool, signer->signedAttrsLen))
                == NULL)
            {
                return PS_MEM_FAIL;
            }
            Memcpy(signer->signedAttrs, attribLenPtr, signer->signedAttrsLen);
            /*  A separate encoding of the signedAttrs field is performed for
                message digest calculation. The IMPLICIT [0] tag in the
                signedAttrs is not used for the DER encoding, rather an
                EXPLICIT SET OF tag is used.  That is, the DER encoding of the
                EXPLICIT SET OF tag, rather than of the IMPLICIT [0] tag, MUST
                be included in the message digest calculation along     with the
                length and content octets of the SignedAttributes value. */
            signer->signedAttrs[0] = ASN_SET | ASN_CONSTRUCTED;

            while (attribLen > 0)
            {
                attribLenPtr = p;

                /* SignedAttributes ::= SET SIZE (1..MAX) OF Attribute */
                if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 1) < 0)
                {
                    psTraceCrypto("Initial parse error for SignedAttributes\n");
                    return PS_PARSE_FAIL;
                }

                /* Attribute ::= SEQUENCE {
                    attrType OBJECT IDENTIFIER,
                    attrValues SET OF AttributeValue } */
                if (mcmsParsePkcsOid(&p, (uint32) (end - p), &oid) < 0)
                {
                    psTraceCrypto("Error parsing OID for attrType\n");
                    return PS_PARSE_FAIL;
                }
                if (getAsnSet32(&p, (uint32_t) (end - p), &len, 0) < 0)
                {
                    psTraceCrypto("Error parsing SET of attrValues\n");
                    return PS_PARSE_FAIL;
                }
                switch (oid)
                {
                case CMS_PKCS9_CONTENT_TYPE:
                    if (cmsParsePkcs9ContentType(&p, (uint32) (end - p),
                            &paramLen) < 0)
                    {
                        return PS_PARSE_FAIL;
                    }
                    /* First required attribute test */
                    if (paramLen == signedData->eContentType)
                    {
                        content = 2;
                    }
                    break;
                case CMS_PKCS9_MESSAGE_DIGEST:
                    if (cmsParsePkcs9MessageDigest(pool, &p,
                            (uint32_t) (end - p), &signer->digest,
                            &signer->digestLen) < 0)
                    {
                        return PS_PARSE_FAIL;
                    }
                    break;
                case CMS_PKCS9_SIGNING_TIME:
                    if (cmsParsePkcs9SignedTime(&p, (uint32_t) (end - p)) < 0)
                    {
                        return PS_PARSE_FAIL;
                    }
                    break;
                case CMS_RFC6211_ALGORITHM_PROTECTION:
                    {
                        psSize32_t rfc6211Len = 0;
                        int32_t l;

                        psTraceCrypto("TODO: handle CMSAlgorithmProtection\n");
                        l = getAsnSequence32(&p,
                                (uint32_t) (end - p),
                                &rfc6211Len,
                                0);
                        if (rfc6211Len < 0 || l < 0)
                        {
                            return PS_PARSE_FAIL;
                        }
                        p += rfc6211Len;
                    }
                    break;
                default:
                    p += len;
                    /* psTraceIntCrypto("NEED PARSER FOR OID %d\n", intOut); */

                }
                attribLen -= (int32) (p - attribLenPtr);
            }
        }

        if (content > 0)
        {
            if (content != 2)
            {
                /* First required attribute */
                psTraceCrypto("signedAttrs present but no content-type");
                return PS_PARSE_FAIL;
            }
            if (signer->digest == NULL)
            {
                /* Second required attribute */
                psTraceCrypto("signedAttrs present but no message-digest\n");
                return PS_PARSE_FAIL;
            }
        }

        /* SignatureAlgorithmIdentifier ::= AlgorithmIdentifier */
        if (getAsnAlgorithmIdentifier(&p, (int32) (end - p), &signer->sigAlg,
                &paramLen) < 0)
        {
            psTraceCrypto("Error getting signature alg for SignerInfo\n");
            return PS_PARSE_FAIL;
        }
        p += paramLen;
        /* SignatureValue ::= OCTET STRING */
        if (cmsGetOctetString(pool, &p, (uint32_t) (end - p), &signer->sig,
                &len) < 0 || len > 0xFFF)
        {
            psTraceCrypto("Error getting signature for SignerInfo\n");
            return PS_PARSE_FAIL;
        }
        signer->sigLen = (uint16_t) len;

        /* unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL */
        if (end > p &&
            *p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
        {
            p++;
            psTraceCrypto("TODO: unsignedAttrs parse unsupported in SignerInfo\n");
            if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                (uint32_t) (end - p) < len)
            {
                psTraceCrypto("Initial parse error unsignedAttrs\n");
                return PS_FAILURE;
            }
            /* Skipping */
            p += len;
        }

        /* SignerInfo set */
        overallSetLen -= (int32) (p - overallLenPtr);
    }

    return (int32) (p - buf);
}


void matrixCmsFreeParsedSignedData(cmsSignedData_t *signedData)
{
    if (signedData == NULL)
    {
        return;
    }
    mcmsFreeSignerInfos(signedData->signers);
    if (signedData->eContent)
    {
        psFree(signedData->eContent, signedData->pool);
    }
    psX509FreeCert(signedData->cert);
    psFree(signedData, signedData->pool);
}

# endif /* ATOMIC || STREAMING */

#endif  /* USE_CMS */
