/**
 *      @file    sdCreate.c
 *
 *
 *      Signed-Data creation.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/
#include "matrixCmsApi.h"
#include "cryptoImpl.h"

/* Estimated amount of ASN.1 tag overhead when constructing SignedData.
   (in addition to content and certificates). */
#define SD_ESTIMATE_BASE_SIZE 1024

#ifdef USE_CMS

# if defined(USE_MCMS_ATOMIC_SD_CREATE) || defined(USE_MCMS_STREAMING_SD_CREATE)

/* Perform the signature and take care of the SignatureAlgorithmIdentifier
    and SignatureValue encoding of the SignerInfo while doing it

    SignatureAlgorithmIdentifier ::= AlgorithmIdentifier
    SignatureValue ::= OCTET STRING
 */
static int32 mcmsSignContentAndEncode(psPool_t *pool, cmsSignerInfos_t *signers,
    psPubKey_t *key, int32 hashSize, const unsigned char *content,
    int32 contentLen)
{
    unsigned char digest[MAX_HASH_SIZE];
    unsigned char oid[CM_MAX_OID_LEN];
    unsigned char *p, *start, *sigLen;
    psDigestContext_t md;
    int32 err, rc, tLen;
    psSize_t oidLen;


    /*  "The result of the message digest calculation process depends on
        whether the signedAttrs field is present.  When the field is absent,
        the result is just the message digest of the content as described
        above.  When the field is present, however, the result is the message
        digest of the complete DER encoding of the SignedAttrs value
        contained in the signedAttrs field." */
    switch (hashSize)
    {
    case SHA1_HASH_SIZE:
        psSha1PreInit(&md.u.sha1);
        psSha1Init(&md.u.sha1);
        if (signers->signedAttrs)
        {
            psSha1Update(&md.u.sha1, signers->signedAttrs,
                signers->signedAttrsLen);
        }
        else
        {
            psSha1Update(&md.u.sha1, content, contentLen);
        }
        psSha1Final(&md.u.sha1, digest);
        break;
    case SHA256_HASH_SIZE:
        psSha256PreInit(&md.u.sha256);
        psSha256Init(&md.u.sha256);
        if (signers->signedAttrs)
        {
            psSha256Update(&md.u.sha256, signers->signedAttrs,
                signers->signedAttrsLen);
        }
        else
        {
            psSha256Update(&md.u.sha256, content, contentLen);
        }
        psSha256Final(&md.u.sha256, digest);
        break;
    case SHA384_HASH_SIZE:
        psSha384PreInit(&md.u.sha384);
        psSha384Init(&md.u.sha384);
        if (signers->signedAttrs)
        {
            psSha384Update(&md.u.sha384, signers->signedAttrs,
                signers->signedAttrsLen);
        }
        else
        {
            psSha384Update(&md.u.sha384, content, contentLen);
        }
        psSha384Final(&md.u.sha384, digest);
        break;
    case SHA512_HASH_SIZE:
        psSha512PreInit(&md.u.sha512);
        psSha512Init(&md.u.sha512);
        if (signers->signedAttrs)
        {
            psSha512Update(&md.u.sha512, signers->signedAttrs,
                signers->signedAttrsLen);
        }
        else
        {
            psSha512Update(&md.u.sha512, content, contentLen);
        }
        psSha512Final(&md.u.sha512, digest);
        break;
    default:
        break;

    }

    tLen = 0;
    if (key->type == PS_RSA)
    {
#  ifdef USE_RSA
        /* All of these RSA-SHA OIDS are the same size... so that's nice */
        mcmsGetAlgOidFromId(OID_SHA1_RSA_SIG, &oid[0], &oidLen);
        tLen = oidLen + asn1TLOverhead(oidLen);
        tLen += asn1TLOverhead(tLen); /* SEQUENCE on algorithmId */

        /* And the key length will get us the rest of the way */
        tLen += key->keysize + asn1TLOverhead(key->keysize); /* OCTET STRING */

        signers->sigLen = tLen;
        if ((signers->sig = psMalloc(pool, tLen)) == NULL)
        {
            return PS_MEM_FAIL;
        }

        p = start = signers->sig;
        switch (signers->digestLen)
        {
        case SHA512_HASH_SIZE:
            mcmsGetAlgOidFromId(OID_SHA512_RSA_SIG, &oid[0], &oidLen);
            signers->sigAlg = OID_SHA512_RSA_SIG;
            break;
        case SHA384_HASH_SIZE:
            mcmsGetAlgOidFromId(OID_SHA384_RSA_SIG, &oid[0], &oidLen);
            signers->sigAlg = OID_SHA384_RSA_SIG;
            break;
        case SHA256_HASH_SIZE:
            mcmsGetAlgOidFromId(OID_SHA256_RSA_SIG, &oid[0], &oidLen);
            signers->sigAlg = OID_SHA256_RSA_SIG;
            break;
        case SHA1_HASH_SIZE:
            mcmsGetAlgOidFromId(OID_SHA1_RSA_SIG, &oid[0], &oidLen);
            signers->sigAlg = OID_SHA1_RSA_SIG;
            break;
        default:;
        }
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, oidLen + asn1TLOverhead(oidLen));
        p += asnWriteOidChars(p, oid, oidLen);

        *p = ASN_OCTET_STRING; p++;
        p += asnHelpWriteLength(p, key->keysize);
        if ((rc = privRsaEncryptSignedElement(pool, &key->key.rsa, digest,
                 signers->digestLen, p, key->keysize, NULL)) < 0)
        {
            psTraceIntCrypto("RSA signtaure operation failed %d\n", rc);
            return rc;
        }
        p += key->keysize;
#  else
        return PS_UNSUPPORTED_FAIL;
#  endif
    }
    else if (key->type == PS_ECC)
    {
        /* Just for size calc.  SHA1 is smaller */
        if (signers->digestLen == SHA1_HASH_SIZE)
        {
            mcmsGetAlgOidFromId(OID_SHA1_ECDSA_SIG, &oid[0], &oidLen);
        }
        else
        {
            mcmsGetAlgOidFromId(OID_SHA256_ECDSA_SIG, &oid[0], &oidLen);
        }
        tLen = oidLen + asn1TLOverhead(oidLen);
        tLen += asn1TLOverhead(tLen); /* SEQUENCE on algorithmId */

        /* Calculating signature size for ECDSA.  Borrowing rc */
        rc = key->keysize + 6;           /* 6 = 2 ASN_SEQ, 4 ASN_BIG */
        if (key->keysize >= 128)
        {
            rc++;                        /* Extra byte for 'long' asn.1 encode */
        }
        tLen += rc + asn1TLOverhead(rc); /* OCTET STRING */

        signers->sigLen = tLen;
        /* Could be a couple 0x0 bytes larger */
        if ((signers->sig = psMalloc(pool, tLen + 2)) == NULL)
        {
            return PS_MEM_FAIL;
        }

        p = start = signers->sig;
        switch (signers->digestLen)
        {
        case SHA512_HASH_SIZE:
            mcmsGetAlgOidFromId(OID_SHA512_ECDSA_SIG, &oid[0], &oidLen);
            signers->sigAlg = OID_SHA512_ECDSA_SIG;
            break;
        case SHA384_HASH_SIZE:
            mcmsGetAlgOidFromId(OID_SHA384_ECDSA_SIG, &oid[0], &oidLen);
            signers->sigAlg = OID_SHA384_ECDSA_SIG;
            break;
        case SHA256_HASH_SIZE:
            mcmsGetAlgOidFromId(OID_SHA256_ECDSA_SIG, &oid[0], &oidLen);
            signers->sigAlg = OID_SHA256_ECDSA_SIG;
            break;
        case SHA1_HASH_SIZE:
            mcmsGetAlgOidFromId(OID_SHA1_ECDSA_SIG, &oid[0], &oidLen);
            signers->sigAlg = OID_SHA1_ECDSA_SIG;
            break;
        default:;
        }
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, oidLen + asn1TLOverhead(oidLen));
        p += asnWriteOidChars(p, oid, oidLen);

        *p = ASN_OCTET_STRING; p++;

        sigLen = p;                     /* may need to update length if 0x0 padding was used */
        p += asnHelpWriteLength(p, rc); /* rc still hasn't been touched */

        /* The magic 2 is the possible 0x0 padding bytes for "positive" ints */
        oidLen = tLen + 2 - ((int32) (p - start));
        if ((err = psEccDsaSign(pool, &key->key.ecc, digest, signers->digestLen,
                 p, &oidLen, 0, NULL)) < 0)
        {
            psTraceIntCrypto("ECDSA signtaure operation failed %d\n", err);
            return err;
        }
        /* oidLen is being reused as the "bytesWritten" output param.  If
            we wrote more than we expected, this is the 0x0 padding byte and
            we re-write the length with the updated value */
        if (oidLen > rc)
        {
            signers->sigLen += (oidLen - rc);   /* Add the overhead */
            tLen += (oidLen - rc);
            asnHelpWriteLength(sigLen, oidLen); /* overwrite old len */
        }
        else if (oidLen < rc)
        {
            /* It is also possible to have a smaller signatures */
            signers->sigLen -= (rc - oidLen);   /* Add the overhead */
            tLen -= (rc - oidLen);
            asnHelpWriteLength(sigLen, oidLen); /* overwrite old len */
        }
        p += oidLen;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    rc = (int32) (p - start);
    psAssert(rc == tLen);
    /* psTraceBytes("Created SIG", start, rc); */
    return PS_SUCCESS;
}

/*
    Reads (and creates the MUST attributes) from  attribSet and populates the
    signedAttrs and signedAttrsLen for easy signing and writing later

    Caller must always call mcmsFreeAttributes regardless of return code
 */
static int32 mcmsWriteSdAttributes(psPool_t *pool, int32 contentType,
    cmsSignerInfos_t *signers, cmsAttributeSet_t *attribSet)
{
    psSize_t oidLen;
    unsigned char oid[CM_MAX_OID_LEN];
    cmsAttributeSet_t *next, *attrib = attribSet;

    if (signers == NULL || signers->digest == NULL || attribSet == NULL)
    {
        return PS_ARG_FAIL;
    }
    /* Writing the two required attributes.  Find the end if user had any */
    while (attrib->data != NULL)
    {
        attrib = attrib->next;
    }
    /* First attrib is a Content-Type with whatever OID user wanted */
    mcmsGetPkcsOidFromId(CMS_PKCS9_CONTENT_TYPE, &oid[0], &oidLen);
    attrib->oidLen = oidLen + asn1TLOverhead(oidLen);
    asnWriteOidChars(attrib->oid, oid, oidLen);

    /* If the SignedData signerInfo includes signedAttributes, then the
        content-type attribute value MUST match the SignedData
        encapContentInfo eContentType value. */
    mcmsGetPkcsOidFromId(contentType, &oid[0], &oidLen);
    attrib->dataLen = oidLen + asn1TLOverhead(oidLen);
    if ((attrib->data = psMalloc(pool, attrib->dataLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    asnWriteOidChars(attrib->data, oid, oidLen);

    /* Second attrib is a message-digest attribute, having as its value the
        message digest of the content.  Create new attribute and write */
    if ((next = psMalloc(pool, sizeof(cmsAttributeSet_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(next, 0, sizeof(cmsAttributeSet_t));
    next->pool = pool;
    attrib->next = next;
    attrib = attrib->next;

    mcmsGetPkcsOidFromId(CMS_PKCS9_MESSAGE_DIGEST, &oid[0], &oidLen);
    attrib->oidLen = oidLen + asn1TLOverhead(oidLen);
    asnWriteOidChars(attrib->oid, oid, oidLen);

    attrib->dataLen = asn1TLOverhead(signers->digestLen) + signers->digestLen;
    if ((attrib->data = psMalloc(pool, attrib->dataLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    asn1WriteOctetString(attrib->data, signers->digest, signers->digestLen);


    /* Move fully formed attributes to signedAttrs */
    if (mcmsMoveAttribToDER(pool, attribSet, &signers->signedAttrs,
            &signers->signedAttrsLen) < 0)
    {
        return PS_MEM_FAIL;
    }
    return PS_SUCCESS;
}

/*
    Writes this:

        SignerInfos ::= SET OF SignerInfo

        SignerInfo ::= SEQUENCE {
            version CMSVersion,
            sid SignerIdentifier,
            digestAlgorithm DigestAlgorithmIdentifier,
            signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
            signatureAlgorithm SignatureAlgorithmIdentifier,
            signature SignatureValue,
            unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }

    Caller must free out when done.
*/
static int32 mcmsWriteSignerInfos(psPool_t *pool, cmsSignerInfos_t *signers,
    psX509Cert_t *cert, unsigned char **out, psSize_t *outLen,
    uint16_t *version, int32 flags)
{
    unsigned char *p, *start;
    unsigned char oid[CM_MAX_OID_LEN];
    int32 signIdType;
    psSize_t cLen, tLen, sLen, versionLen, signIdLen, digestLen, oidLen;

    /* version is a single integer byte */
    versionLen = 1 + asn1TLOverhead(1);

    if (cert->issuer.dnenc == NULL)
    {
        psTraceCrypto("Cert must be parsed with CERT_STORE_DN_BUFFER\n");
        return PS_FAILURE;
    }

    /* If the flag is set, use the subjectKeyId method if it exists */
    signIdLen = signIdType = 0;
    if (flags & MCMS_FLAGS_SD_SUBJECT_KEY_ID)
    {
#  ifdef USE_FULL_CERT_PARSE
        /* Subject Key ID */
        if ((&cert->extensions.sk)->len > 0)
        {
            signIdType = 3; /* the version number */
            signIdLen = (&cert->extensions.sk)->len;
        }
#  else
        psTraceCrypto("Warning: Enable USE_FULL_CERT_PARSE for MCMS_FLAGS_SD_SUBJECT_KEY_ID\n");
#  endif
    }
    if (signIdLen == 0)
    {
        /* IssuerAndSerialNum */
        signIdType = 1; /* the version number */
        signIdLen = cert->serialNumberLen + cert->issuer.dnencLen +
                    asn1TLOverhead(cert->serialNumberLen);
    }

    /* digestAlgorithm is the only part that hasn't been formed yet */
    digestLen = 0;
    switch (signers->digestLen)
    {
    case SHA512_HASH_SIZE:
    case SHA384_HASH_SIZE:
    case SHA256_HASH_SIZE:
        digestLen = 9 + asn1TLOverhead(9);
        break;
    case SHA1_HASH_SIZE:
        digestLen = 5 + asn1TLOverhead(5);
        break;
    default:;
    }
    digestLen += asn1TLOverhead(digestLen); /* SEQUENCE wrap */

    /* content length of all the parts */
    cLen = versionLen + signIdLen + asn1TLOverhead(signIdLen) + digestLen +
           signers->sigLen + signers->signedAttrsLen;

    /* A SET and SEQUENCE wrap the whole thing */
    sLen = cLen + asn1TLOverhead(cLen);
    tLen = sLen + asn1TLOverhead(sLen);

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }

    /* Doing the write */
    start = p;

    /* SignerInfos ::= SET OF SignerInfo */
    *p = ASN_SET | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, sLen);


    /* SignerInfo ::= SEQUENCE { */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, cLen);

    /*  CMSVersion is the syntax version number. If the SignerIdentifier is
            the CHOICE issuerAndSerialNumber, then the version MUST be 1.  If
            the SignerIdentifier is subjectKeyIdentifier, then the version
            MUST be 3. */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = signIdType & 0xFF; p++;

    /*
        SignerIdentifier ::= CHOICE {
            issuerAndSerialNumber IssuerAndSerialNumber,
            subjectKeyIdentifier [0] SubjectKeyIdentifier }

        IssuerAndSerialNumber ::= SEQUENCE {
            issuer Name,
            serialNumber CertificateSerialNumber } */
    if (signIdType == 1)
    {
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, signIdLen);

        Memcpy(p, cert->issuer.dnenc, cert->issuer.dnencLen);
        p += cert->issuer.dnencLen;

        *p = ASN_INTEGER; p++;
        p += asnHelpWriteLength(p, cert->serialNumberLen);
        Memcpy(p, cert->serialNumber, cert->serialNumberLen);
        p += cert->serialNumberLen;
    }
    else
    {
        *p = (ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE); p++;
        p += asnHelpWriteLength(p, signIdLen);

        Memcpy(p, (&cert->extensions.sk)->id, (&cert->extensions.sk)->len);
        p += (&cert->extensions.sk)->len;
    }


    /* digestAlgorithm DigestAlgorithmIdentifier */
    oidLen = 0;
    switch (signers->digestLen)
    {
    case SHA512_HASH_SIZE:
        mcmsGetAlgOidFromId(OID_SHA512_ALG, &oid[0], &oidLen);
        break;
    case SHA384_HASH_SIZE:
        mcmsGetAlgOidFromId(OID_SHA384_ALG, &oid[0], &oidLen);
        break;
    case SHA256_HASH_SIZE:
        mcmsGetAlgOidFromId(OID_SHA256_ALG, &oid[0], &oidLen);
        break;
    case SHA1_HASH_SIZE:
        mcmsGetAlgOidFromId(OID_SHA1_ALG, &oid[0], &oidLen);
        break;
    default:;
    }
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, oidLen + asn1TLOverhead(oidLen));
    p += asnWriteOidChars(p, oid, oidLen);

    /* signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL, */
    /* Have to tweak that first byte */
    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
    Memcpy(p, signers->signedAttrs + 1, signers->signedAttrsLen - 1);
    p += signers->signedAttrsLen - 1;

    /* sig holds both of these
        signatureAlgorithm SignatureAlgorithmIdentifier,
        signature SignatureValue, */
    Memcpy(p, signers->sig, signers->sigLen);
    p += signers->sigLen;

    /* sanity */
    sLen = (int32) (p - start);
    psAssert(sLen == tLen);

    *out = start;
    *outLen = sLen;
    *version = signIdType;
    return PS_SUCCESS;
}

/******************************************************************************/

#  ifdef USE_MCMS_ATOMIC_SD_CREATE
/*
    Writes this:

        DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier

        DigestAlgorithmIdentifier ::= AlgorithmIdentifier */

static int32 mcmsWriteDigestAlgs(psPool_t *pool, cmsSignerInfos_t *signers,
    unsigned char **out, psSize_t *outLen)
{
    unsigned char *p, *start;
    unsigned char oid[CM_MAX_OID_LEN];
    psSize_t oidLen, cLen, sLen, tLen;

    /* Just using the digest that the signer used */
    mcmsGetAlgOidFromId(signers->digestId, &oid[0], &oidLen);

    /* OID */
    cLen = oidLen + asn1TLOverhead(oidLen);
    /* Sequence */
    sLen = cLen + asn1TLOverhead(cLen);
    /* Set */
    tLen = sLen + asn1TLOverhead(sLen);

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }

    /* Doing the write */
    start = p;

    *p = ASN_SET | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, sLen);

    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, cLen);

    p += asnWriteOidChars(p, oid, oidLen);

    /* sanity */
    cLen = (int32) (p - start);
    psAssert(cLen == tLen);

    *out = start;
    *outLen = cLen;

    return PS_SUCCESS;
}


#   ifdef MATRIX_USE_FILE_SYSTEM
int32 matrixCmsCreateSdFromContentFile(psPool_t *pool, char *contentFile,
    char *certFile, char *keyFile, char *password, int32 hashId,
    unsigned char **outputBuf, int32 *outputLen, int32 flags)
{
    psX509Cert_t *cert;
    psPubKey_t key;
    unsigned char *content;
    psSizeL_t contentLen;
    psRes_t rc;

    /* Deal with content first */
    if ((rc = psGetFileBuf(pool, contentFile, &content, &contentLen)) < 0)
    {
        psTraceStrCore("Unable to get conent from %s\n", contentFile);
        return rc;
    }

    /* Cert */
    if ((rc = psX509ParseCertFile(pool, certFile, &cert,
             CERT_STORE_DN_BUFFER | CERT_STORE_UNPARSED_BUFFER))
        < PS_SUCCESS)
    {
        psFree(content, pool);
        return rc;
    }

    /* Pick the private key type based on the cert */
    if (cert->pubKeyAlgorithm == OID_ECDSA_KEY_ALG)
    {
        psEccInitKey(pool, &key.key.ecc, NULL);
        if ((rc = psEccParsePrivFile(pool, keyFile, password, &key.key.ecc)) < 0)
        {
            psX509FreeCert(cert);
            psFree(content, pool);
            return rc;
        }
#    ifdef USE_RSA
    }
    else if (cert->pubKeyAlgorithm == OID_RSA_KEY_ALG)
    {
        psRsaInitKey(pool, &key.key.rsa);
        if ((rc = psPkcs1ParsePrivFile(pool, keyFile, password, &key.key.rsa)) < 0)
        {
            psX509FreeCert(cert);
            psFree(content, pool);
            return rc;
        }
#    endif
    }
    else
    {
        psX509FreeCert(cert);
        psFree(content, pool);
        return PS_UNSUPPORTED_FAIL;
    }
    rc = matrixCmsCreateSignedData(pool, content, contentLen, CMS_PKCS7_DATA,
        cert, &key, hashId, outputBuf, outputLen, flags);

    psX509FreeCert(cert);
    if (cert->pubKeyAlgorithm == OID_ECDSA_KEY_ALG)
    {
        psEccClearKey(&key.key.ecc);
    }
    else
    {
        psRsaClearKey(&key.key.rsa);
    }
    psFree(content, pool);
    return rc;
}
#   endif /* MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/
/*
    Writes this:

        SignedData ::= SEQUENCE {
            version CMSVersion,
            digestAlgorithms DigestAlgorithmIdentifiers,
            encapContentInfo EncapsulatedContentInfo,
            certificates [0] IMPLICIT CertificateSet OPTIONAL,
            crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
            signerInfos SignerInfos }
 */
int32 matrixCmsCreateSignedData(psPool_t *pool, unsigned char *content,
    int32 contentLen, int32 contentType, psX509Cert_t *cert,
    psPubKey_t *key, int32 hashId, unsigned char **outputBuf,
    int32 *outputLen, int32 flags)
{
    psDigestContext_t hash;
    cmsSignerInfos_t *signers;
    cmsAttributeSet_t *attribSet, *attrib;
    unsigned char oid[CM_MAX_OID_LEN];
    unsigned char encoid[CM_MAX_OID_LEN];
    unsigned char *signerInfos, *digestAlg;
    unsigned char *p, *start;
    int32 rc;
    uint32_t cencLen, tencLen, aencLen, sdLen, cLen, tLen;
    psSize_t signerInfosLen, digestAlgLen, version;
    psSize_t gsLen, oidLen, encOidLen, certLen;

    if (content == NULL || cert == NULL)
    {
        return PS_ARG_FAIL;
    }
    if (contentType != CMS_PKCS7_DATA && contentType != CMS_PKCS7_SIGNED_DATA
        && contentType != CMS_PKCS9_AUTH_ENVELOPED_DATA &&
        contentType != CMS_PKCS9_COMPRESSED_DATA)
    {
        return PS_UNSUPPORTED_FAIL;
    }
    if ((flags & MCMS_FLAGS_SD_NODETACH) &&
        (flags & MCMS_FLAGS_SD_CONTENT_PREHASHED))
    {
        psTraceCrypto("Can't have both MCMS_FLAGS_SD_NODETACH and ");
        psTraceCrypto("MCMS_FLAGS_SD_CONTENT_PREHASHED set as flags\n");
        return PS_ARG_FAIL;
    }

    /* Structure setup */
    if ((signers = psMalloc(pool, sizeof(cmsSignerInfos_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(signers, 0, sizeof(cmsSignerInfos_t));
    signers->pool = pool;
    signerInfos = digestAlg = NULL;
    attribSet = NULL;

    /* Start with the work that leads to the signing itself to see if all the
        encoding will be necessary */
    if (hashId == 0)
    {
        signers->digestId = MCMS_SHA1_ALG;
    }
    else
    {
        signers->digestId = hashId;
    }
    if (signers->digestId == MCMS_SHA1_ALG)
    {
        signers->digestLen = SHA1_HASH_SIZE;
    }
    else if (signers->digestId == MCMS_SHA256_ALG)
    {
        signers->digestLen = SHA256_HASH_SIZE;
    }
    else if (signers->digestId == MCMS_SHA384_ALG)
    {
        signers->digestLen = SHA384_HASH_SIZE;
    }
    else if (signers->digestId == MCMS_SHA512_ALG)
    {
        signers->digestLen = SHA512_HASH_SIZE;
    }
    else
    {
        rc = PS_UNSUPPORTED_FAIL;
        goto LBL_ERR;
    }

    if ((signers->digest = psMalloc(pool, signers->digestLen)) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }

    /* If using "external signature" it isn't essential that the entire
        contents be passed in.  Hash is all that's needed to create */
    if (flags &  MCMS_FLAGS_SD_CONTENT_PREHASHED)
    {
        if (signers->digestLen != (uint32) contentLen)
        {
            psTraceCrypto("hashId not consistent with contentLen\n");
            rc = PS_ARG_FAIL;
            goto LBL_ERR;
        }
        Memcpy(signers->digest, content, contentLen);
    }
    else
    {

        switch (signers->digestLen)
        {
        case SHA1_HASH_SIZE:
            psSha1Init(&hash.u.sha1);
            psSha1Update(&hash.u.sha1, content, contentLen);
            psSha1Final(&hash.u.sha1, signers->digest);
            break;
        case SHA256_HASH_SIZE:
            psSha256Init(&hash.u.sha256);
            psSha256Update(&hash.u.sha256, content, contentLen);
            psSha256Final(&hash.u.sha256, signers->digest);
            break;
        case SHA384_HASH_SIZE:
            psSha384Init(&hash.u.sha384);
            psSha384Update(&hash.u.sha384, content, contentLen);
            psSha384Final(&hash.u.sha384, signers->digest);
            break;
        case SHA512_HASH_SIZE:
            psSha512Init(&hash.u.sha512);
            psSha512Update(&hash.u.sha512, content, contentLen);
            psSha512Final(&hash.u.sha512, signers->digest);
            break;
        default:
            break;
        }
    }

    /* Have to sign the attributes too */
    if ((attribSet = psMalloc(pool, sizeof(cmsAttributeSet_t))) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }
    Memset(attribSet, 0, sizeof(cmsAttributeSet_t));
    attribSet->pool = pool;
    /* This call will write the two required attributes and assign the fully
        formed signed attributes to signers.  TODO: User could pass
        in attribSet with additional attributes if this was expanded a bit */
    if ((rc = mcmsWriteSdAttributes(pool, contentType, signers, attribSet))
        < 0)
    {
        goto LBL_ERR;
    }


    /* Have all we need to do the signature.  Take care of that now */
    if ((rc = mcmsSignContentAndEncode(pool, signers, key, signers->digestLen,
             content, contentLen)) < 0)
    {
        goto LBL_ERR;
    }

    /* Signature worked.  Create SignerInfos */
    if ((rc = mcmsWriteSignerInfos(pool, signers, cert, &signerInfos,
             &signerInfosLen, &version, flags)) < 0)
    {
        goto LBL_ERR;
    }

    /* EncapsulatedContentInfo eContent */
    tencLen = cencLen = aencLen = 0;
    if (flags & MCMS_FLAGS_SD_NODETACH)
    {
        /* Octet string */
        tencLen = contentLen + asn1TLOverhead(contentLen);
        aencLen = tencLen;
        /* EXPLICIT OPTIONAL wrap */
        tencLen += asn1TLOverhead(tencLen);
    }

    /* This is just a test that a content-type is present */
    mcmsGetPkcsOidFromId(CMS_PKCS9_CONTENT_TYPE, &encoid[0], &encOidLen);
    attrib = attribSet;
    while (attrib)
    {
        /* The attrib contains the OID and L values.  Just check the end */
        if (attrib->oidLen > encOidLen)
        {
            cencLen = attrib->oidLen - encOidLen;
            if (Memcmp(attrib->oid + cencLen, encoid, encOidLen) == 0)
            {
                tencLen += attrib->dataLen; /* overhead already included */
                break;
            }
            cencLen = 0;
        }
        attrib = attrib->next;
    }
    if (cencLen == 0)
    {
        psTraceCrypto("Content-type never found in signedAttributes\n");
        rc = PS_FAIL;
        goto LBL_ERR; /* can't happen but good for sanity */
    }

    /* A SEQUENCE wraps EncapsulatedContentInfo */
    cencLen = tencLen;
    tencLen = cencLen + asn1TLOverhead(cencLen);

    /* digestAlgorithms DigestAlgorithmIdentifiers, */
    if ((rc = mcmsWriteDigestAlgs(pool, signers, &digestAlg, &digestAlgLen))
        < 0)
    {
        goto LBL_ERR;
    }

    /* Have all the tricky ones.  Version and GeneralSyntax can be done
        manually

        Signed-data len is all the parts we've been making */
    sdLen = 1 + asn1TLOverhead(1); /* version is a single integer byte */
    sdLen += digestAlgLen + tencLen + signerInfosLen;
    certLen = cert->binLen;
    if ((flags & MCMS_FLAGS_SD_CERT_CHAIN) != 0 && cert->next)
    {
        /* Encode certificate chain => multiple tags. */
        psX509Cert_t *ci = cert->next;

        do {
            certLen += ci->binLen;
            ci = ci->next;
        } while(ci);
    }
    sdLen += certLen + asn1TLOverhead(certLen);

    /* Content length is signed-data plus a sequence */
    cLen = sdLen + asn1TLOverhead(sdLen); /* SEQUENCE in content */

    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        gsLen = 0;
    }
    else
    {
        /* general syntax len here is the difference between cLen and tLen */
        mcmsGetPkcsOidFromId(CMS_PKCS7_SIGNED_DATA, &oid[0], &oidLen);
        gsLen = oidLen + asn1TLOverhead(oidLen); /* OID wrap */
        gsLen += asn1TLOverhead(cLen);           /* EXPLICIT */
    }

    /* Total len */
    tLen = gsLen + cLen + asn1TLOverhead(gsLen + cLen); /* SEQUENCE in GS */

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }

    /* Doing the write */
    start = p;


    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        /* Already didn't include outer sequence and OID.  Now removing
            CONTEXT_SPECIFIC and length bytes */
        tLen -= asn1TLOverhead(cLen);
    }
    else
    {
        /*      ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, cLen + gsLen);

        p += asnWriteOidChars(p, oid, oidLen);

        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
        p += asnHelpWriteLength(p, cLen);
    }

    /*  SignedData ::= SEQUENCE {
            version CMSVersion,
            digestAlgorithms DigestAlgorithmIdentifiers,
            encapContentInfo EncapsulatedContentInfo,
            certificates [0] IMPLICIT CertificateSet OPTIONAL,
            crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
            signerInfos SignerInfos } */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, sdLen);

    /* Our use cases will always be version 5 to indicate the certificate is
        attached and it is a version 3 cert */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = 0x5; p++;

    Memcpy(p, digestAlg, digestAlgLen);
    p += digestAlgLen;

    /* EncapsulatedContentInfo */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, cencLen);

    /* This is the OID for the eContentType.  We just happen to know it is
        always the first value in the attributes because that is how
        mcmsWriteSdAttributes creates them */
    Memcpy(p, attrib->data, attrib->dataLen);
    p += attrib->dataLen;

    if (flags & MCMS_FLAGS_SD_NODETACH)
    {
        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, aencLen);

        *p = ASN_OCTET_STRING; p++;
        p += asnHelpWriteLength(p, contentLen);
        Memcpy(p, content, contentLen);
        p += contentLen;
    }
    mcmsFreeAttributes(attribSet);
    attribSet = NULL;

    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
    p += asnHelpWriteLength(p, certLen);
    Memcpy(p, cert->unparsedBin, cert->binLen);
    p += cert->binLen;
    if ((flags & MCMS_FLAGS_SD_CERT_CHAIN) != 0 && cert->next)
    {
        /* Encode certificate chain => multiple tags. */
        psX509Cert_t *ci = cert->next;

        do {
            Memcpy(p, ci->unparsedBin, ci->binLen);
            p += ci->binLen;
            ci = ci->next;
        } while(ci);
    }

    /* FUTURE: CRL would go here */

    Memcpy(p, signerInfos, signerInfosLen);
    p += signerInfosLen;

    /* sanity */
    cLen = (int32) (p - start);
    psAssert(cLen == tLen);


    psFree(digestAlg, pool);
    psFree(signerInfos, pool);

    *outputBuf = start;
    *outputLen = cLen;

    rc = PS_SUCCESS;

LBL_ERR:
    mcmsFreeSignerInfos(signers);
    if (rc != PS_SUCCESS)
    {
        if (attribSet)
        {
            mcmsFreeAttributes(attribSet);
        }
        if (signerInfos)
        {
            psFree(signerInfos, pool);
        }
        if (digestAlg)
        {
            psFree(digestAlg, pool);
        }
    }
    return rc;
}

#  endif /* USE_MCMS_ATOMIC_SD_CREATE */


/******************************************************************************/
#  ifdef USE_MCMS_STREAMING_SD_CREATE
/* Only supporting attached content for the STREAMING mode.  If the data
    is already pre-hashed, the ATOMIC version with a flags value of
    MCMS_FLAGS_SD_CONTENT_PREHASHED can be used

    Nothing for caller to free if function fails */
int32 matrixCmsInitCreateSignedData(psPool_t *pool, psX509Cert_t *cert,
    psPubKey_t *key, int32 hashId, int32 contentType,
    unsigned char **outputBuf, int32 *outputLen, int32 flags,
    cmsSdStream_t **sdCtx)
{
    cmsSdStream_t *ctx;
    cmsSignerInfos_t *signers;
    unsigned char oid[CM_MAX_OID_LEN];
    unsigned char dataOid[CM_MAX_OID_LEN];
    unsigned char hashOid[CM_MAX_OID_LEN];
    unsigned char *p, *start;
    int32 rc;
    psSize_t oidLen, thashLen, chashLen, shashLen;
    psSize_t hashOidLen, dataOidLen, tecLen, tLen;

    if (flags & MCMS_FLAGS_SD_CONTENT_PREHASHED)
    {
        psTraceCrypto("Use matrixCmsCreateSignedData for MCMS_FLAGS_SD_CONTENT_PREHASHED\n");
        return PS_ARG_FAIL;
    }
    if (contentType != CMS_PKCS7_DATA && contentType != CMS_PKCS7_SIGNED_DATA
        && contentType != CMS_PKCS9_AUTH_ENVELOPED_DATA &&
        contentType != CMS_PKCS9_COMPRESSED_DATA)
    {
        return PS_UNSUPPORTED_FAIL;
    }

    /* Structure setup */
    if ((ctx = psMalloc(pool, sizeof(cmsSdStream_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(ctx, 0, sizeof(cmsSdStream_t));
    ctx->pool = pool;
    ctx->contentType = contentType;
    if ((signers = psMalloc(pool, sizeof(cmsSignerInfos_t))) == NULL)
    {
        psFree(ctx, pool);
        return PS_MEM_FAIL;
    }
    Memset(signers, 0, sizeof(cmsSignerInfos_t));
    signers->pool = pool;
    ctx->signers = signers;
    ctx->cert = cert;
    ctx->key = key;
    ctx->flags = flags;

    /* Start with the work that leads to the signing itself to see if all the
        encoding will be necessary */
    if (hashId == 0)
    {
        signers->digestId = MCMS_SHA1_ALG;
    }
    else
    {
        signers->digestId = hashId;
    }
    if (signers->digestId == MCMS_SHA1_ALG)
    {
        signers->digestLen = SHA1_HASH_SIZE;
        ctx->hashLen = SHA1_HASH_SIZE;
        psSha1Init(&ctx->hashCtx.sha1);
    }
    else if (signers->digestId == MCMS_SHA256_ALG)
    {
        signers->digestLen = SHA256_HASH_SIZE;
        ctx->hashLen = SHA256_HASH_SIZE;
        psSha256Init(&ctx->hashCtx.sha256);
    }
    else if (signers->digestId == MCMS_SHA384_ALG)
    {
        signers->digestLen = SHA384_HASH_SIZE;
        ctx->hashLen = SHA384_HASH_SIZE;
        psSha384Init(&ctx->hashCtx.sha384);
    }
    else if (signers->digestId == MCMS_SHA512_ALG)
    {
        signers->digestLen = SHA512_HASH_SIZE;
        ctx->hashLen = SHA512_HASH_SIZE;
        psSha512Init(&ctx->hashCtx.sha512);
    }
    else
    {
        rc = PS_UNSUPPORTED_FAIL;
        goto LBL_ERR;
    }

    if (flags & MCMS_FLAGS_SD_SUBJECT_KEY_ID)
    {
#   ifdef USE_FULL_CERT_PARSE
        /* Subject Key ID */
        if ((&cert->extensions.sk)->len > 0)
        {
            ctx->version = 3; /* the version number */
        }
        else
        {
            ctx->version = 1;
        }
#   else
        psTraceCrypto("Warning: Enable USE_FULL_CERT_PARSE for MCMS_FLAGS_SD_SUBJECT_KEY_ID\n");
#   endif
    }
    else
    {
        ctx->version = 1;
    }

    /* DigestAlgorithmIdentifiers len  */
    mcmsGetAlgOidFromId(signers->digestId, &hashOid[0], &hashOidLen);
    /* OID */
    chashLen = hashOidLen + asn1TLOverhead(hashOidLen);
    /* Sequence */
    shashLen = chashLen + asn1TLOverhead(chashLen);
    /* Set */
    thashLen = shashLen + asn1TLOverhead(shashLen);

    /* Start of EncapsulatedContentInfo */
    mcmsGetPkcsOidFromId(contentType, &dataOid[0], &dataOidLen);
    /* total is indefinite-len, ContentType, and the ASN.1 right up to the
        CONSTRUCTED OCTET */
    tecLen = dataOidLen + asn1TLOverhead(dataOidLen) + asn1TLOverhead(1) +
             asn1TLOverhead(1) + asn1TLOverhead(1);

    /* Indefinite-lengths for overall SEQ, contentType, and SignedData SEQ */
    mcmsGetPkcsOidFromId(CMS_PKCS7_SIGNED_DATA, &oid[0], &oidLen);
    tLen = asn1TLOverhead(1) + asn1TLOverhead(1) + asn1TLOverhead(1) +
           /* Signed data oid and version */
           oidLen + asn1TLOverhead(oidLen) + 1 + asn1TLOverhead(1) +
           /* DigestAlg and start of EncapContent */
           thashLen + tecLen;

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }

    /* Doing the write */
    start = p;

    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        /* Now removing outer sequence, OID, CONTEXT_SPECIFIC and indefinite
            length byte */
        tLen -= (asn1TLOverhead(1) + asn1TLOverhead(1) +
                 oidLen + asn1TLOverhead(oidLen));
    }
    else
    {
        /*      ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        *p = 0x80; p++;

        p += asnWriteOidChars(p, oid, oidLen);

        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
        *p = 0x80; p++;
    }

    /*  SignedData ::= SEQUENCE {
            version CMSVersion,
            digestAlgorithms DigestAlgorithmIdentifiers,
            encapContentInfo EncapsulatedContentInfo,
            certificates [0] IMPLICIT CertificateSet OPTIONAL,
            crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
            signerInfos SignerInfos } */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    /* The SignedData version will always be 5 for our use cases.  That is,
        the certifiate is attached and is a version 3 cert */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = 0x5; p++;

    *p = ASN_SET | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, shashLen);

    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, chashLen);

    p += asnWriteOidChars(p, hashOid, hashOidLen);

    /* Start of encap content */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    p += asnWriteOidChars(p, dataOid, dataOidLen);

    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    *p = (ASN_OCTET_STRING | ASN_CONSTRUCTED); p++;
    *p = 0x80; p++;

    /* sanity */
    thashLen = (int32) (p - start);
    psAssert(thashLen == tLen);

    *outputBuf = start;
    *outputLen = thashLen;

    *sdCtx = ctx;

    rc = PS_SUCCESS;

LBL_ERR:
    if (rc != PS_SUCCESS)
    {
        psFree(signers, pool);
        psFree(ctx, pool);
    }
    return rc;
}

/* Not much to do on Update.  Update the hash and encode data in an
    OCTET STRING */
int32 matrixCmsUpdateCreateSignedData(psPool_t *pool, cmsSdStream_t *sdCtx,
    unsigned char *content, int32 contentLen, unsigned char **outputBuf,
    int32 *outputLen)
{
    unsigned char *p, *start;
    int32 tLen;

    /* Update the hash */
    switch (sdCtx->hashLen)
    {
    case SHA1_HASH_SIZE:
        psSha1Update(&sdCtx->hashCtx.sha1, content, contentLen);
        break;
    case SHA256_HASH_SIZE:
        psSha256Update(&sdCtx->hashCtx.sha256, content, contentLen);
        break;
    case SHA384_HASH_SIZE:
        psSha384Update(&sdCtx->hashCtx.sha384, content, contentLen);
        break;
    case SHA512_HASH_SIZE:
        psSha512Update(&sdCtx->hashCtx.sha512, content, contentLen);
        break;
    default:
        break;
    }

    tLen = contentLen + asn1TLOverhead(contentLen);

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    start = p;

    *p = ASN_OCTET_STRING; p++;
    p += asnHelpWriteLength(p, contentLen);

    Memcpy(p, content, contentLen);
    p += contentLen;

    *outputBuf = start;
    *outputLen = tLen;

    return PS_SUCCESS;
}

int32 matrixCmsFinalCreateSignedData(psPool_t *pool, cmsSdStream_t *sdCtx,
    unsigned char **outputBuf, int32 *outputLen)
{
    cmsSignerInfos_t *signers;
    cmsAttributeSet_t *attribSet;
    unsigned char *p, *start, *signerInfos;
    int32 rc;
    psSize_t tLen, cLen, signerInfosLen;

    attribSet = NULL;
    signerInfos = NULL;
    signers = sdCtx->signers;
    if ((signers->digest = psMalloc(pool, signers->digestLen)) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }
    switch (sdCtx->hashLen)
    {
    case SHA1_HASH_SIZE:
        psSha1Final(&sdCtx->hashCtx.sha1, signers->digest);
        break;
    case SHA256_HASH_SIZE:
        psSha256Final(&sdCtx->hashCtx.sha256, signers->digest);
        break;
    case SHA384_HASH_SIZE:
        psSha384Final(&sdCtx->hashCtx.sha384, signers->digest);
        break;
    case SHA512_HASH_SIZE:
        psSha512Final(&sdCtx->hashCtx.sha512, signers->digest);
        break;
    default:
        break;
    }

    /* Have to sign the attributes too */
    if ((attribSet = psMalloc(pool, sizeof(cmsAttributeSet_t))) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }
    Memset(attribSet, 0, sizeof(cmsAttributeSet_t));
    attribSet->pool = pool;
    /* This call will write the two required attributes and assign the fully
        formed signed attributes to signers.  TODO: User could pass
        in attribSet with additional attributes if this was expanded a bit */
    if ((rc = mcmsWriteSdAttributes(pool, sdCtx->contentType, sdCtx->signers,
             attribSet)) < 0)
    {
        goto LBL_ERR;
    }
    mcmsFreeAttributes(attribSet);
    attribSet = NULL;

    /* Have all we need to do the signature.  Take care of that now */
    if ((rc = mcmsSignContentAndEncode(pool, sdCtx->signers, sdCtx->key,
             sdCtx->hashLen, NULL, 0)) < 0)
    {
        goto LBL_ERR;
    }

    /* Signature worked.  Create SignerInfos */
    if ((rc = mcmsWriteSignerInfos(pool, sdCtx->signers, sdCtx->cert,
             &signerInfos, &signerInfosLen, &tLen, sdCtx->flags)) < 0)
    {
        goto LBL_ERR;
    }

    if (sdCtx->flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        /* End-of-contents:  CONSRUCTED OCTET (3 * 2), Outer wrap (1 * 2) */
        tLen = 8 +
               sdCtx->cert->binLen + asn1TLOverhead(sdCtx->cert->binLen) +
               signerInfosLen;
    }
    else
    {
        /* End-of-contents:  CONSRUCTED OCTET (3 * 2), Outer wrap (3 * 2) */
        tLen = 12 +
               sdCtx->cert->binLen + asn1TLOverhead(sdCtx->cert->binLen) +
               signerInfosLen;
    }

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }
    start = p;

    /* Close CONSTRUCTED OCTET STRING has 3 indefinites */
    *p = 0x0; p++;
    *p = 0x0; p++;
    *p = 0x0; p++;
    *p = 0x0; p++;
    *p = 0x0; p++;
    *p = 0x0; p++;

    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
    p += asnHelpWriteLength(p, sdCtx->cert->binLen);
    Memcpy(p, sdCtx->cert->unparsedBin, sdCtx->cert->binLen);
    p += sdCtx->cert->binLen;

    Memcpy(p, signerInfos, signerInfosLen);
    p += signerInfosLen;
    psFree(signerInfos, pool);

    /* end-of-contents for the indefinite lengths that started it all */
    *p = 0x0; p++;
    *p = 0x0; p++;
    if (!(sdCtx->flags & MCMS_FLAGS_NO_CONTENT_INFO))
    {
        *p = 0x0; p++;
        *p = 0x0; p++;
        *p = 0x0; p++;
        *p = 0x0; p++;
    }

    /* sanity */
    cLen = (int32) (p - start);
    psAssert(cLen == tLen);

    *outputBuf = start;
    *outputLen = cLen;


    rc = PS_SUCCESS;

LBL_ERR:

    if (rc != PS_SUCCESS)
    {
        if (signerInfos)
        {
            psFree(signerInfos, pool);
        }
        if (attribSet)
        {
            mcmsFreeAttributes(attribSet);
        }
    }
    return rc;
}

void matrixCmsFreeStreamCreatedSignedData(cmsSdStream_t *sdCtx)
{
    if (sdCtx->signers)
    {
        mcmsFreeSignerInfos(sdCtx->signers);
    }
    psFree(sdCtx, sdCtx->pool);
}

#  endif /* USE_MCMS_STREAMING_SD_CREATE */

/* Note: Prepare for two parts. */
static
int32 mcmsGetDigest(
        psPool_t *pool,
        int32 digestId,
        const unsigned char *part1,
        size_t part1Len,
        const unsigned char *part2,
        size_t part2Len,
        const unsigned char *finished_digest,
        size_t finished_digest_len,
        unsigned char **out, psSize_t *outLen)
{
    unsigned char *buf;
    psSize_t digestLen;
    unsigned char digesttmp[SHA512_HASH_SIZE];

    *out = NULL;
    *outLen = 0;

    if (digestId == MCMS_SHA1_ALG)
    {
        digestLen = SHA1_HASH_SIZE;
    }
    else if (digestId == MCMS_SHA256_ALG)
    {
        digestLen = SHA256_HASH_SIZE;
    }
    else if (digestId == MCMS_SHA384_ALG)
    {
        digestLen = SHA384_HASH_SIZE;
    }
    else if (digestId == MCMS_SHA512_ALG)
    {
        digestLen = SHA512_HASH_SIZE;
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    buf = psMalloc(pool, digestLen);
    if (!buf)
    {
        return PS_MEM_FAIL;
    }

    if (finished_digest == NULL)
    {
        psDigestContext_t hash;
        finished_digest = digesttmp;

        /* Compute digest. */
        if (digestId == MCMS_SHA1_ALG)
        {
            psSha1PreInit(&hash.u.sha1);
            psSha1Init(&hash.u.sha1);
            psSha1Update(&hash.u.sha1, part1, part1Len);
            psSha1Update(&hash.u.sha1, part2, part2Len);
            psSha1Final(&hash.u.sha1, digesttmp);
        }
        else if (digestId == MCMS_SHA256_ALG)
        {
            psSha256PreInit(&hash.u.sha256);
            psSha256Init(&hash.u.sha256);
            psSha256Update(&hash.u.sha256, part1, part1Len);
            psSha256Update(&hash.u.sha256, part2, part2Len);
            psSha256Final(&hash.u.sha256, digesttmp);
        }
        else if (digestId == MCMS_SHA384_ALG)
        {
            psSha384PreInit(&hash.u.sha384);
            psSha384Init(&hash.u.sha384);
            psSha384Update(&hash.u.sha384, part1, part1Len);
            psSha384Update(&hash.u.sha384, part2, part2Len);
            psSha384Final(&hash.u.sha384, digesttmp);
        }
        else if (digestId == MCMS_SHA512_ALG)
        {
            psSha512PreInit(&hash.u.sha512);
            psSha512Init(&hash.u.sha512);
            psSha512Update(&hash.u.sha512, part1, part1Len);
            psSha512Update(&hash.u.sha512, part2, part2Len);
            psSha512Final(&hash.u.sha512, digesttmp);
        }
        else
        {
            return PS_UNSUPPORTED_FAIL;
        }
    }
    else if (digestLen != finished_digest_len)
    {
        psFree(buf, pool);
        return PS_ARG_FAIL;
    }

    Memcpy(buf, finished_digest, digestLen);
    *out = buf;
    *outLen = digestLen;
    return PS_SUCCESS;
}

static
int32 matrixCmsCreateSignedDataExtInt(
        psPool_t *pool,
        const unsigned char *content,
        int32 contentLen,
        int32 contentType,
        int32 count,
        psX509Cert_t * const *certs,
        psPubKey_t * const *keys,
        const int32 * const hashIds,
        psDynBuf_t *db,
        struct matrixCmsCreateSignedDataExtInfo *ei_p)
{
    int32 flags = ei_p ? ei_p->flags : 0;
    cmsSignerInfos_t *signers[MCMS_MAX_SIGNERS] = { NULL, /* ... */ };
    cmsAttributeSet_t *attribSets[MCMS_MAX_SIGNERS] = { NULL, /* ... */ };
    unsigned char *signerInfos[MCMS_MAX_SIGNERS] = { NULL, /* ... */ };
    unsigned char *digestAlgs[MCMS_MAX_SIGNERS] = { NULL, /* ... */ };
    int32 rc;
    int32 rct;
    psSize_t signerInfosLen[MCMS_MAX_SIGNERS] = {0};
    psSize_t digestAlgLens[MCMS_MAX_SIGNERS] = {0};
    psSize_t version;
    psDynBuf_t signed_data;
    psDynBuf_t encapsulated_content_info;
    psDynBuf_t certs_encoded;
    psDynBuf_t digests_encoded;
    psDynBuf_t signerinfos_encoded;
    int32 i;
    int32 l;

    if (count > MCMS_MAX_SIGNERS)
    {
        return PS_ARG_FAIL;
    }

    if (content == NULL)
    {
        return PS_ARG_FAIL;
    }
    if (contentType != CMS_PKCS7_DATA && contentType != CMS_PKCS7_SIGNED_DATA
        && contentType != CMS_PKCS9_AUTH_ENVELOPED_DATA &&
        contentType != CMS_PKCS9_COMPRESSED_DATA)
    {
        return PS_UNSUPPORTED_FAIL;
    }
    if ((flags & MCMS_FLAGS_SD_NODETACH) &&
        (flags & MCMS_FLAGS_SD_CONTENT_PREHASHED))
    {
        psTraceCrypto("Can't have both MCMS_FLAGS_SD_NODETACH and ");
        psTraceCrypto("MCMS_FLAGS_SD_CONTENT_PREHASHED set as flags\n");
        return PS_ARG_FAIL;
    }

    /* Allocate and structure setup parts of SignedData's contents. */
    for(i = 0; i < count; i++)
    {
        if ((signers[i] = psMalloc(pool, sizeof(cmsSignerInfos_t))) == NULL)
        {
            rc = PS_MEM_FAIL;
            goto LBL_ERR;
        }
        Memset(signers[i], 0, sizeof(cmsSignerInfos_t));
        signers[i]->pool = pool;
        signerInfos[i] = NULL;
        digestAlgs[i] = NULL;
        attribSets[i] = NULL;

        if (hashIds[i] == 0)
        {
            signers[i]->digestId = MCMS_SHA1_ALG;
        }
        else
        {
            signers[i]->digestId = hashIds[i];
        }

        rc = mcmsGetDigest(
                pool,
                signers[i]->digestId,
                content,
                contentLen,
                NULL,
                0,
                (flags & MCMS_FLAGS_SD_CONTENT_PREHASHED) != 0 ? content : NULL,
                contentLen,
                &(signers[i]->digest),
                &(signers[i]->digestLen));

        if (rc != PS_SUCCESS)
        {
            /* Error detected while creating digest. */
            goto LBL_ERR;
        }

        /* Have to sign the attributes too */
        if ((attribSets[i] = psMalloc(pool, sizeof(cmsAttributeSet_t))) == NULL)
        {
            rc = PS_MEM_FAIL;
            goto LBL_ERR;
        }
        Memset(attribSets[i], 0, sizeof(cmsAttributeSet_t));
        attribSets[i]->pool = pool;
        /* This call will write the two required attributes and assign the fully
           formed signed attributes to signer.  TODO: User could pass
           in attribSet with additional attributes if this was expanded a bit */
        if ((rc = mcmsWriteSdAttributes(pool, contentType, signers[i],
                                        attribSets[i]))
            < 0)
        {
            goto LBL_ERR;
        }

        if (keys == NULL || keys[i] == NULL)
        {
            /* If there is no key, skip content signing. */
            continue;
        }


        /* Have all we need to do the signature.  Take care of that now */
        if ((rc = mcmsSignContentAndEncode(
                     pool,
                     signers[i],
                     keys[i],
                     signers[i]->digestLen,
                     content,
                     contentLen)) < 0)
        {
            goto LBL_ERR;
        }

        /* Signature worked.  Create SignerInfos */
        if ((rc = mcmsWriteSignerInfos(
                     pool,
                     signers[i],
                     certs[i],
                     &signerInfos[i],
                     &signerInfosLen[i],
                     &version,
                     flags)) < 0)
        {
            goto LBL_ERR;
        }

        /* digestAlgorithms DigestAlgorithmIdentifiers, */
        if ((rc = mcmsWriteDigestAlgs(
                     pool,
                     signers[i],
                     &digestAlgs[i],
                     &digestAlgLens[i]))
            < 0)
        {
            goto LBL_ERR;
        }
    }

    /* All structures successfully created, now encode output. */
    rc = PS_SUCCESS; /* Assume success, unless error found during encoding. */
    psDynBufBeginSequence(db, &signed_data);
    /* Encoding {version CMSVersion}
       Our use cases will always be version 5 to indicate the certificate is
       attached and it is a version 3 cert, except when count is 0 */
    if (count > 0)
    {
        psDynBufAppendAsn1IntegerSmall(&signed_data, 0x05);
    }
    else
    {
        /* Use PKCS #7 to transport CRLs and/or certificates. */
        psDynBufAppendAsn1IntegerSmall(&signed_data, 0x01);
    }
    /* Encoding {digestAlgorithms DigestAlgorithmIdentifiers} */
    psDynBufBeginConstructedTag(&signed_data, &digests_encoded);
    for(i = 0; i < count; i++)
    {
        /* Each digest info contains also "SET of" element as wrapper.
           Remove SET, and output only the content of the SET element. */
        psParseBuf_t pb, pb2;

        if (keys == NULL || keys[i] == NULL)
        {
            continue; /* No signing key >= skip this digest id. */
        }

        /* Remove duplicates: Omit digestAlg if already exists in the set. */
        for(l = 0; l < i; l++)
        {
            if (digestAlgLens[i] == digestAlgLens[l] &&
                Memcmp(digestAlgs[i], digestAlgs[l], digestAlgLens[i]) == 0)
            {
                goto skip_digestAlg;
            }
        }

        rct = psParseBufFromStaticData(&pb, digestAlgs[i], digestAlgLens[i]);
        if (rct == PS_SUCCESS)
        {
            (void)psParseBufReadTagSub(&pb, &pb2, ASN_SET | ASN_CONSTRUCTED);
            psDynBufAppendParseBuf(&digests_encoded, &pb2);
            psParseBufCancel(&pb2);
        }
        else
        {
            rc = PS_FAILURE;
        }
        psParseBufCancel(&pb);
    skip_digestAlg:
        ;
    }
    psDynBufEndConstructedTag(&digests_encoded, ASN_SET | ASN_CONSTRUCTED);

    /* Encoding {encapContentInfo EncapsulatedContentInfo} */
    psDynBufBeginSequence(&signed_data, &encapsulated_content_info);
    /* OID for content info. */
    if (count > 0)
    {
        /* When count > 0 we use the first attribSet. */
        psDynBufAppendOctets(&encapsulated_content_info,
                             attribSets[0]->data, attribSets[0]->dataLen);
    }
    else
    {
        psSize_t oidLen = 0;
        unsigned char oid[CM_MAX_OID_LEN];

        /* Encode contentType as attribute. */
        mcmsGetPkcsOidFromId(contentType, &oid[0], &oidLen);
        psDynBufAppendAsn1Oid(&encapsulated_content_info, oid, oidLen);
    }

    if (flags & MCMS_FLAGS_SD_NODETACH)
    {
        psDynBuf_t contenttag;

        psDynBufBeginConstructedTag(&encapsulated_content_info, &contenttag);
        psDynBufAppendAsn1OctetString(&contenttag, content, contentLen);
        psDynBufEndConstructedTag(
                &contenttag,
                ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED);
    }

    psDynBufEndSequence(&encapsulated_content_info);

    psDynBufBeginConstructedTag(&signed_data, &certs_encoded);
    for(i = 0; i < count; i++)
    {
        psX509Cert_t *ci = certs[i];
        while(ci)
        {
            psDynBufAppendOctets(
                    &certs_encoded,
                    ci->unparsedBin,
                    ci->binLen);
            if ((flags & MCMS_FLAGS_SD_CERT_CHAIN) != 0)
            {
                ci = ci->next;
            }
            else
            {
                ci = NULL;
            }
        }
    }
    psDynBufEndConstructedTag(
            &certs_encoded,
            ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0);

    /* CRL (CertificateList) will go here. */
    if ((flags & MCMS_FLAGS_SD_HAS_CRL) != 0 &&
        ei_p->tbsCertListBin &&
        ei_p->tbsCertListLen > 0)
    {
        /* crls [1] IMPLICIT RevocationInfoChoices OPTIONAL */
        psDynBuf_t revocationInfoChoicesImpl;

        psDynBufBeginConstructedTag(&signed_data, &revocationInfoChoicesImpl);
        psDynBufAppendOctets(
                &revocationInfoChoicesImpl,
                ei_p->tbsCertListBin,
                ei_p->tbsCertListLen);
        psDynBufEndConstructedTag(
                &revocationInfoChoicesImpl,
                ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1);
    }

    /* Add signer infos, as many as requested. */
    psDynBufBeginConstructedTag(&signed_data, &signerinfos_encoded);
    for(i = 0; i < count; i++)
    {
        /* Each signer info contains also "SET of" element as wrapper.
           Remove SET, and output only the content of the SET element. */
        psParseBuf_t pb, pb2;

        if (keys == NULL || keys[i] == NULL)
        {
            continue; /* No signing key >= no need to produce signer info. */
        }

        rct = psParseBufFromStaticData(&pb, signerInfos[i], signerInfosLen[i]);
        if (rct == PS_SUCCESS)
        {
            (void) psParseBufReadTagSub(&pb, &pb2, ASN_SET | ASN_CONSTRUCTED);
            psDynBufAppendParseBuf(&signerinfos_encoded, &pb2);
            psParseBufCancel(&pb2);
        }
        else
        {
            rc = PS_FAILURE;
        }
        psParseBufCancel(&pb);
    }
    psDynBufEndConstructedTag(&signerinfos_encoded, ASN_SET | ASN_CONSTRUCTED);

    /* End of SIGNED_DATA encoding. */
    psDynBufEndSequence(&signed_data);

LBL_ERR:
    for(i = 0; i < count; i++)
    {
        if (signers[i])
        {
            mcmsFreeSignerInfos(signers[i]);
        }
        if (attribSets[i])
        {
            mcmsFreeAttributes(attribSets[i]);
        }
        if (signerInfos[i])
        {
            psFree(signerInfos[i], pool);
        }
        if (digestAlgs[i])
        {
            psFree(digestAlgs[i], pool);
        }
    }
    return rc;
}

int32 matrixCmsCreateSignedDataExt(
        psPool_t *pool,
        const unsigned char *content,
        int32 contentLen,
        int32 contentType,
        int32 count,
        psX509Cert_t * const *certs,
        psPubKey_t * const *keys,
        const int32 * const hashIds,
        unsigned char **outputBuf,
        int32 *outputLen,
        struct matrixCmsCreateSignedDataExtInfo *ei_p)
{
    int rc;
    psDynBuf_t buf;
    size_t new_len;
    unsigned char *new_buf;
    size_t size_estimate;
    int32 i;

    if (count > MCMS_MAX_SIGNERS)
    {
        return PS_ARG_FAIL;
    }

    /* Estimate size of output.
       The more accurate estimate the less memory is wasted.
       If estimate is too small, reallocations are needed. */
    size_estimate = SD_ESTIMATE_BASE_SIZE;
    if (ei_p->flags & MCMS_FLAGS_SD_NODETACH)
    {
        size_estimate += contentLen;
    }

    for(i = 0; i < count; i++)
    {
        size_estimate += certs[i] ? certs[i]->binLen : 0;
    }

    /* Encode actual Signed Data. */
    psDynBufInit(pool, &buf, size_estimate);
    rc = matrixCmsCreateSignedDataExtInt(
            pool,
            content,
            contentLen,
            contentType,
            count,
            certs,
            keys,
            hashIds,
            &buf,
            ei_p);

    new_buf = psDynBufDetach(&buf, &new_len);
    if (!new_buf)
    {
        return PS_MEM_FAIL;
    }


    /* If user requested content info, then wrap signed data with
       content info. */
    if ((ei_p->flags & MCMS_FLAGS_NO_CONTENT_INFO) == 0)
    {
        psDynBuf_t buf2;
        unsigned char oid[CM_MAX_OID_LEN];
        psSize_t oidLen;

        /* Start with
           ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */
        mcmsGetPkcsOidFromId(CMS_PKCS7_SIGNED_DATA, &oid[0], &oidLen);
        psDynBufInit(pool, &buf, size_estimate);
        psDynBufBeginSequence(&buf, &buf2);
        psDynBufAppendAsn1TagGen(&buf2, ASN_OID, oid, oidLen);
        /* The actual content [SignedData] is found in new_buf[0...new_len-1] */
        psDynBufAppendAsn1TagGen(
                &buf2,
                ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0,
                new_buf, new_len);
        psFree(new_buf, pool);
        psDynBufEndSequence(&buf2);
        new_buf = psDynBufDetach(&buf, &new_len);
    }

    if (new_buf)
    {
        *outputBuf = new_buf;
        *outputLen = new_len;
    }
    else
    {
        rc = PS_MEM_FAIL;
    }
    return rc;
}

# endif  /* ATOMIC || STREAM */
#endif   /* USE_CMS */

