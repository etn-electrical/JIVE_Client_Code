/**
 *      @file    cmsTest.c
 *
 *
 *      MatrixCMS self-test.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/
#ifndef _DEFAULT_SOURCE
# define _DEFAULT_SOURCE
#endif

#include "../matrixCmsApi.h"
#include "psUtil.h"
#include "osdep_stdio.h"

#ifdef MATRIX_USE_FILE_SYSTEM

static char cmsTestDir[] = "./";
static char keyDir[] = "../../../testkeys/";

# define TEST_STREAM 1
# define TEST_ATOMIC 0

/******************************************************************************/
static int32 compressTest(void);
static int32 signedDataTest(int32 keysize);
static int32 authEnvDataTest(int32 keysize);

int32 parseAed(char *sd, psPubKey_t *privKey, psX509Cert_t *cert,
               int32 lflags, unsigned char *origMsg, int32 origMsgLen);
int32 parseSdNestedAed(char *sd, psX509Cert_t *cert, unsigned char *myContent,
                       int32 myContentLen, int32 flags, psX509Cert_t *aedCert,
                       char *aedPrivKeyFile, int32 aedFlags);
static int32 parseMozillaCertBundle(void);
static
int32 parseSdFile(const char *sdFileName,
        const char *certFilename,
        const char *keyFilename);
#ifdef USE_MCMS_STREAMING_AED_PARSE
int32 simpleAedParseTest(const char *aedFileName, int expect_final_fail);
#endif

int32 main(int argc, char **argv)
{
    int32 seed;
#ifdef USE_MCMS_STREAMING_AED_PARSE
    int32 rc;
#endif

    psCoreOpen(PSCORE_CONFIG);

    psCryptoOpen(PSCRYPTO_CONFIG);

    seed = (int32) psGetEpochTime();
    srandom(seed);

#ifdef USE_MCMS_STREAMING_AED_PARSE
    Printf("Start AED stream parse test 1...\n");
    rc = simpleAedParseTest("testmaterial/authenv_ext.data.bin", 0);
    if (rc < 0)
    {
        Printf("FAILED:  AED stream parse test 1\n");
        return rc;
    }
    else
    {
        Printf("SUCCESS:  AED stream parse test 1\n");
    }
    Printf("Start AED stream parse test 2: corrupted data...\n");
    /* authenv_ext.data.corrupted.bin: same as authenv_ext.data.bin,
       expect that last ciphertext byte has been corrupted. */
    rc = simpleAedParseTest("testmaterial/authenv_ext.data.corrupted.bin", 1);
    if (rc != MCMS_AED_KEY_AGREED_BUT_AUTH_FAILED)
    {
        Printf("FAILED:  AED stream parse test 2: corrupted data\n");
        return PS_FAILURE;
    }
    else
    {
        Printf("SUCCESS:  AED stream parse test 2: corrupted data\n");
    }
#endif
    Printf("Start Mozilla cert bundle parse test...\n");
    if (parseMozillaCertBundle() < 0)
    {
        Printf("FAILED: parseMozillaCertBundle\n");
    }
    else
    {
        Printf("SUCCESS: parseMozillaCertBundle\n");
    }
    Printf("Start simple SignedData parse test...\n");
    if (parseSdFile("signed-data-rsa1024-md4.der",
                    "RSA/1024_RSA_MD4.pem",
                    "RSA/1024_RSA_KEY.pem") < 0)
    {
        Printf("FAILED: simpleSdParseTest\n");
    }
    else
    {
        Printf("SUCCESS: simpleSdParseTest\n");
    }

    Printf("Start compressTest...\n");
    if (compressTest() < 0)
    {
        Printf("FAILED:  compressTest\n");
    }
    else
    {
        Printf("SUCCESS:  compressTest\n");
    }

# ifdef USE_SECP192R1
    Printf("Start signedDataTest 192...\n");
    if (signedDataTest(192) < 0)
    {
        Printf("FAILED:  signedDataTest 192\n");
    }
    else
    {
        Printf("SUCCESS:  signedDataTest 192\n");
    }
# else
    Printf("SKIPPED signedDataTest 192... Algorithm not supported\n");
# endif

# ifdef USE_SECP224R1
    Printf("Start signedDataTest 224...\n");
    if (signedDataTest(224) < 0)
    {
        Printf("FAILED:  signedDataTest 224\n");
    }
    else
    {
        Printf("SUCCESS:  signedDataTest 224\n");
    }
# else
    Printf("SKIPPED signedDataTest 224... Algorithm not supported\n");
# endif

# ifdef USE_SECP256R1
    Printf("Start signedDataTest 256...\n");
    if (signedDataTest(256) < 0)
    {
        Printf("FAILED:  signedDataTest 256\n");
    }
    else
    {
        Printf("SUCCESS:  signedDataTest 256\n");
    }
# else
    Printf("SKIPPED signedDataTest 256... Algorithm not supported\n");
# endif

# ifdef USE_SECP384R1
    Printf("Start signedDataTest 384...\n");
    if (signedDataTest(384) < 0)
    {
        Printf("FAILED:  signedDataTest 384\n");
    }
    else
    {
        Printf("SUCCESS:  signedDataTest 384\n");
    }
# else
    Printf("SKIPPED signedDataTest 384... Algorithm not supported\n");
# endif

# ifdef USE_SECP521R1
    Printf("Start signedDataTest 521...\n");
    if (signedDataTest(521) < 0)
    {
        Printf("FAILED:  signedDataTest 521\n");
    }
    else
    {
        Printf("SUCCESS:  signedDataTest 521\n");
    }
# else
    Printf("SKIPPED signedDataTest 521... Algorithm not supported\n");
# endif

# ifdef USE_SECP192R1
    Printf("Start authEnvDataTest 192...\n");
    if (authEnvDataTest(192) < 0)
    {
        Printf("FAILED:  authEnvDataTest 192\n");
    }
    else
    {
        Printf("SUCCESS:  authEnvDataTest 192\n");
    }
# else
    Printf("SKIPPED authEnvDataTest 192... Algorithm not supported\n");
# endif

# ifdef USE_SECP224R1
    Printf("Start authEnvDataTest 224...\n");
    if (authEnvDataTest(224) < 0)
    {
        Printf("FAILED:  authEnvDataTest 224\n");
    }
    else
    {
        Printf("SUCCESS:  authEnvDataTest 224\n");
    }
# else
    Printf("SKIPPED authEnvDataTest 224... Algorithm not supported\n");
# endif

# ifdef USE_SECP256R1
    Printf("Start authEnvDataTest 256...\n");
    if (authEnvDataTest(256) < 0)
    {
        Printf("FAILED:  authEnvDataTest 256\n");
    }
    else
    {
        Printf("SUCCESS:  authEnvDataTest 256\n");
    }
# else
    Printf("SKIPPED authEnvDataTest 256... Algorithm not supported\n");
# endif

# ifdef USE_SECP384R1
    Printf("Start authEnvDataTest 384...\n");
    if (authEnvDataTest(384) < 0)
    {
        Printf("FAILED:  authEnvDataTest 384\n");
    }
    else
    {
        Printf("SUCCESS:  authEnvDataTest 384\n");
    }
# else
    Printf("SKIPPED authEnvDataTest 384... Algorithm not supported\n");
# endif

# ifdef USE_SECP521R1
    Printf("Start authEnvDataTest 521...\n");
    if (authEnvDataTest(521) < 0)
    {
        Printf("FAILED:  authEnvDataTest 521\n");
    }
    else
    {
        Printf("SUCCESS:  authEnvDataTest 521\n");
    }
# else
    Printf("SKIPPED authEnvDataTest 521... Algorithm not supported\n");
# endif


    psCloseMalloc();
    return 0;
}

#ifdef USE_MCMS_STREAMING_AED_PARSE
#include "testmaterial/EC_256_EC.h"
#include "testmaterial/EC_256_EC_KEY.h"
int32 simpleAedParseTest(const char *aedFileName,
        int expect_final_fail)
{
    unsigned char *dat, *content, *remainder;
    int32 contentLen, remainderLen = 0, flags;
    cmsEncryptedEnvelope_t *ee;
    psPubKey_t privKey;
    psX509Cert_t *cert;
    int32 rc;
    psSizeL_t datLen;

    Memset(&privKey, 0, sizeof(privKey));

    rc = psX509ParseCert(NULL,
            EC_256_EC,
            EC_256_EC_len,
            &cert,
            CERT_STORE_DN_BUFFER | CERT_STORE_DN_BUFFER);
    if (rc < 0)
    {
        Printf("Error parsing recipient cert file %d\n", rc);
        return rc;
    }
    rc = psParseUnknownPrivKeyMem(
            NULL, EC_256_EC_KEY,
            EC_256_EC_KEY_len, NULL, &privKey);
    if (rc < 0)
    {
        Printf("Error parsing privkey file %d\n", rc);
        return rc;
    }
    privKey.type = PS_ECC;
    privKey.keysize = psEccSize(&privKey.key.ecc);

    if ((rc = psGetFileBuf(NULL, aedFileName, &dat, &datLen)) < 0)
    {
        Printf("Error getting message from file %d\n", rc);
        return rc;
    }
    flags = 0;
    rc = matrixCmsInitParseAuthEnvData(NULL, dat, datLen, &ee,
            &content, &contentLen, flags);
    if (rc != PS_SUCCESS)
    {
        Printf("AED Init stream parse issue: %d\n", rc);
        return rc;
    }
    rc = matrixCmsPostInitParseAuthEnvData(NULL, ee, cert, &privKey);
    if (rc != PS_SUCCESS)
    {
        Printf("matrixCmsPostInitParseAuthEnvData failed: %d\n", rc);
        return rc;
    }
    rc = matrixCmsUpdateParseAuthEnvData(NULL, content, contentLen, ee,
            &content, &contentLen, contentLen,
            &remainder, &remainderLen);
    if (rc != PS_SUCCESS)
    {
        Printf("matrixCmsUpdateAuthEnvData failed: %d\n", rc);
        return rc;
    }
    rc = matrixCmsFinalParseAuthEnvData(NULL, remainder, remainderLen, ee);
    if (rc != PS_SUCCESS)
    {
        if (!expect_final_fail)
        {
            Printf("matrixCmsFinalParseAuthEnvData failed: %d\n", rc);
        }
        return rc;
    }

    return PS_SUCCESS;
}
#endif /* USE_MCMS_STREAMING_AED_PARSE */

# if defined(USE_MCMS_STREAMING_CD_PARSE) || defined(USE_MCMS_STREAMING_SD_PARSE) || defined(USE_MCMS_STREAMING_AED_PARSE)
static long random_at_most(long max)
{
    unsigned long
    /* max <= RAND_MAX < ULONG_MAX, so this is okay. */
        num_bins = (unsigned long) max + 1,
        num_rand = (unsigned long) RAND_MAX + 1,
        bin_size = num_rand / num_bins,
        defect   = num_rand % bin_size;

    long x;

    /* This is carefully written not to overflow */
    while (num_rand - defect <= (unsigned long) (x = random()))
    {
        ;
    }

    /* Truncated division is intentional */
    return x / bin_size;
}
# endif

static void writeFile(char *outFile, unsigned char *out, int32 outLen)
{
    FILE *fd;

    fd = Fopen(outFile, "wb");
    Fwrite(out, sizeof(char), outLen, fd);
    Fclose(fd);
}

static void fullPath(psPool_t *pool, char *file, char **ret, int testOrKey)
{
    char *full;
    int dirLen;

    if (testOrKey == 1)
    {
        dirLen = (int) Strlen(cmsTestDir);

        full = psMalloc(pool, Strlen(file) + dirLen + 1);
        Memset(full, 0, Strlen(file) + dirLen + 1);

        Memcpy(full, cmsTestDir, dirLen);
        Memcpy(full + dirLen, file, Strlen(file));
    }
    else
    {
        dirLen = (int) Strlen(keyDir);

        full = psMalloc(pool, Strlen(file) + dirLen + 1);
        Memset(full, 0, Strlen(file) + dirLen + 1);

        Memcpy(full, keyDir, dirLen);
        Memcpy(full + dirLen, file, Strlen(file));
    }
    *ret = full;
}

static int nextSdIndex = 1;
static void nextSdFile(char **output)
{
    char next[16];
    char id[4];

    if (nextSdIndex > 999)
    {
        fullPath(NULL, "overflow", output, 1);
        return;
    }
    Snprintf(id, 4, "%d", nextSdIndex++);
    Memset(next, 0, 16);
    Memcpy(next, "mcmsSd", 6);
    if (Strlen(id) == 1)
    {
        Memcpy(next + 6, id, 1);
        Memcpy(next + 6 + 1, ".der", 4);
    }
    else if (Strlen(id) == 2)
    {
        Memcpy(next + 6, id, 2);
        Memcpy(next + 6 + 2, ".der", 4);
    }
    else
    {
        Memcpy(next + 6, id, 3);
        Memcpy(next + 6 + 3, ".der", 4);
    }

    fullPath(NULL, next, output, 1);
}

# ifdef USE_MCMS_STREAMING_SD_CREATE
static int nextSdStreamIndex = 1;
static void nextSdStreamFile(char **output)
{
    char next[20];
    char id[4];

    if (nextSdStreamIndex > 999)
    {
        fullPath(NULL, "overflow", output, 1);
        return;
    }
    Snprintf(id, 4, "%d", nextSdStreamIndex++);
    Memset(next, 0, 20);
    Memcpy(next, "mcmsSdStream", 12);
    if (Strlen(id) == 1)
    {
        Memcpy(next + 12, id, 1);
        Memcpy(next + 12 + 1, ".der", 4);
    }
    else if (Strlen(id) == 2)
    {
        Memcpy(next + 12, id, 2);
        Memcpy(next + 12 + 2, ".der", 4);
    }
    else
    {
        Memcpy(next + 12, id, 3);
        Memcpy(next + 12 + 3, ".der", 4);
    }

    fullPath(NULL, next, output, 1);
}
# endif

static int nextAedIndex = 1;
static void nextAedFile(char **output)
{
    char next[16];
    char id[4];

    if (nextAedIndex > 999)
    {
        fullPath(NULL, "overflow", output, 1);
        return;
    }
    Snprintf(id, 4, "%d", nextAedIndex++);
    Memset(next, 0, 16);
    Memcpy(next, "mcmsAed", 7);
    if (Strlen(id) == 1)
    {
        Memcpy(next + 7, id, 1);
        Memcpy(next + 7 + 1, ".der", 4);
    }
    else if (Strlen(id) == 2)
    {
        Memcpy(next + 7, id, 2);
        Memcpy(next + 7 + 2, ".der", 4);
    }
    else
    {
        Memcpy(next + 7, id, 3);
        Memcpy(next + 7 + 3, ".der", 4);
    }

    fullPath(NULL, next, output, 1);
}

# ifdef USE_MCMS_STREAMING_AED_CREATE
static int nextAedStreamIndex = 1;
static void nextAedStreamFile(char **output)
{
    char next[20];
    char id[4];

    if (nextAedStreamIndex > 999)
    {
        fullPath(NULL, "overflow", output, 1);
        return;
    }
    Snprintf(id, 4, "%d", nextAedStreamIndex++);
    Memset(next, 0, 20);
    Memcpy(next, "mcmsAedStream", 13);
    if (Strlen(id) == 1)
    {
        Memcpy(next + 13, id, 1);
        Memcpy(next + 13 + 1, ".der", 4);
    }
    else if (Strlen(id) == 2)
    {
        Memcpy(next + 13, id, 2);
        Memcpy(next + 13 + 2, ".der", 4);
    }
    else
    {
        Memcpy(next + 13, id, 3);
        Memcpy(next + 13 + 3, ".der", 4);
    }

    fullPath(NULL, next, output, 1);
}
# endif

# define ZLIB_OVERHEAD   256
# define ATOMIC_CD_OH 1024


# if defined(USE_MCMS_ATOMIC_CD_CREATE) || \
    defined(USE_MCMS_STREAMING_CD_CREATE) || \
    defined(USE_MCMS_ATOMIC_CD_PARSE) || \
    defined(USE_MCMS_STREAMING_CD_PARSE)
static int32 zlibDeflate(unsigned char *myContent, int32 myContentLen,
    unsigned char **dest, int32 *destSize)
{
    int32 compSize;
    unsigned char *out;
    z_stream zlibCtx;

    compSize = myContentLen + ZLIB_OVERHEAD;
    if ((out = psMalloc(MATRIX_NO_POOL, compSize))  == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(&zlibCtx, 0x0, sizeof(z_stream));
    zlibCtx.next_in = myContent;
    zlibCtx.avail_in = myContentLen;
    zlibCtx.next_out = out;
    zlibCtx.avail_out = compSize;

    if (deflateInit(&zlibCtx, Z_DEFAULT_COMPRESSION) != 0)
    {
        Printf("Zlib deflate init failure\n");
        psFree(out, MATRIX_NO_POOL);
        return -1;
    }
    if (deflate(&zlibCtx, Z_SYNC_FLUSH) != 0)
    {
        Printf("Zlib deflate failure\n");
        psFree(out, MATRIX_NO_POOL);
        return -1;
    }
    *dest = out;
    *destSize = (int32) zlibCtx.total_out;
    deflateEnd(&zlibCtx);
    return 0;
}

static int32 zlibInflate(unsigned char *myContent, int32 myContentLen,
    unsigned char **dest, int32 *destSize)
{
    int32 compSize;
    unsigned char *out;
    z_stream zlibCtx;

    /* How to allocate the right amount of room for the inflated data? */
    /* size run first */
    *dest = NULL;
    if ((out = psMalloc(MATRIX_NO_POOL, 1024))  == NULL)
    {
        return PS_MEM_FAIL;
    }

    Memset(&zlibCtx, 0x0, sizeof(z_stream));
    zlibCtx.next_in = myContent;
    zlibCtx.avail_in = myContentLen;
    zlibCtx.next_out = out;
    zlibCtx.avail_out = 1024;

    if (inflateInit(&zlibCtx) != 0)
    {
        Printf("Zlib inflate init failure\n");
        psFree(out, MATRIX_NO_POOL);
        return -1;
    }
    while (zlibCtx.total_in < myContentLen)
    {
        if (inflate(&zlibCtx, Z_SYNC_FLUSH) != 0)
        {
            Printf("Zlib inflate failure\n");
            psFree(out, MATRIX_NO_POOL);
            return -1;
        }
        zlibCtx.next_out = out;
        zlibCtx.avail_out = 1024;
    }
    inflateEnd(&zlibCtx);
    compSize = (int32) zlibCtx.total_out;
    psFree(out, MATRIX_NO_POOL);


    /* real run */
    if ((out = psMalloc(MATRIX_NO_POOL, compSize))  == NULL)
    {
        return PS_MEM_FAIL;
    }

    Memset(&zlibCtx, 0x0, sizeof(z_stream));
    zlibCtx.next_in = myContent;
    zlibCtx.avail_in = myContentLen;
    zlibCtx.next_out = out;
    zlibCtx.avail_out = compSize;

    if (inflateInit(&zlibCtx) != 0)
    {
        Printf("Zlib inflate init failure\n");
        psFree(out, MATRIX_NO_POOL);
        return -1;
    }
    if (inflate(&zlibCtx, Z_SYNC_FLUSH) != 0)
    {
        Printf("Zlib inflate failure\n");
        psFree(out, MATRIX_NO_POOL);
        return -1;
    }
    *dest = out;
    *destSize = (int32) zlibCtx.total_out;
    inflateEnd(&zlibCtx);
    return 0;
}

#  define STREAM_CD_PARSE_REPEAT 1
static int32 parseCd(psPool_t *pool, unsigned char *compressedData,
    int32 compressedDataLen, unsigned char *myContent,
    int32 myContentLen, int32 flags)
{
    cmsCompressedData_t *cds;

#  ifdef USE_MCMS_STREAMING_CD_PARSE
    unsigned char *fullCompressedBuf, *compressedOut, *ctPtr;
    unsigned char *remainder;
    unsigned char initTest[128];
    int32 i, fullCompressedBufLen, compressedOutLen;
    int32 repeat, ctLen, totLen, remainderLen;
#  endif
    unsigned char *dest;
    int32 rc, destSize;

#  ifdef USE_MCMS_STREAMING_CD_PARSE
    rc = PS_LIMIT_FAIL;
    i = 0;
    while (rc == PS_LIMIT_FAIL || rc == MCMS_PARTIAL)
    {
        if (i == 127)
        {
            Printf("initTest too small for parseCd\n");
            return PS_LIMIT_FAIL;
        }
        /* Move each test into a dedicated initTest array so make sure the
            data ends when we say it does and the parser isn't skipping
            a length test where it would find the correct expected data if
            we were passing in the correct buffer with a truncated length */
        Memset(initTest, 0x0, 128);
        Memcpy(initTest, compressedData, i);
        rc = matrixCmsInitParseCompressedData(pool, initTest, i, &cds,
            &compressedOut, &compressedOutLen, flags);
        if (rc != PS_LIMIT_FAIL && rc != PS_SUCCESS)
        {
            Printf("Streaming CD issue:  %d %d\n", i, rc);
        }
        i++;
    }
    psAssert(compressedOutLen == 0); /* did one byte incr so no output */

    /* There is no stream zlib implemenation here so even for the stream
        tests we are appending all the parts into one buffer for the zlib
        verification */
    /* If this is a stream encoded indefinate length CD there will be
        a value in indefLen to indicate how many trailing 0x0 there are
        in the CD stream */
    if (cds->indefLen > 0)
    {
        /* We don't really know how large the data will be so we'll allocate
            on our test case knowledge instead */
        fullCompressedBuf = psMalloc(pool, compressedDataLen);
        totLen = -1; /* flag to denote our unknown length state */
    }
    else
    {
        /* In the streaming parse API, the destination doesn't need to be fully
           allocated (that's the whole point) but we're going to allocate it here
           just to have stoarge so the rest of the test is easy.  The length
           is held in cds->compressedDataLen */
        fullCompressedBuf = psMalloc(pool, cds->compressedDataLen);
        totLen = cds->compressedDataLen;
    }

    /* Start over with random lengths */
    matrixCmsFreeCompressedData(cds);

    repeat = 0;
REPEAT_CD_STREAM_PARSE:
    /* Now that the per-byte Init test is done, we randomize the lengths to
        test the streaming API set */
    rc = PS_LIMIT_FAIL;
    while (rc == PS_LIMIT_FAIL)
    {
        i = (int32) random_at_most(compressedDataLen);
        rc = matrixCmsInitParseCompressedData(pool, compressedData, i, &cds,
            &compressedOut, &compressedOutLen, flags);
    }
    psAssert(rc == PS_SUCCESS);

    /* i is still sitting at how much of the fileBuf has been processed
        from the Init.  Set us back to the start of the compressed data
        so we can do all the updates in one loop */
    ctPtr = compressedData + i - compressedOutLen;
    ctLen = compressedDataLen - i + compressedOutLen;

    if (compressedOutLen > 0 && ctPtr != compressedOut)
    {
        Printf("problem in CD init parse\n");
    }

    fullCompressedBufLen = 0;
    rc = MCMS_PARTIAL;
    while (rc == MCMS_PARTIAL)
    {
        if (ctLen == 0)
        {
            Printf("Error in ctLen\n");
        }
        i = (int32) random_at_most(ctLen);

        rc = matrixCmsUpdateParseCompressedData(cds, ctPtr, i,
            &compressedOut, &compressedOutLen, &remainder, &remainderLen);
        if (rc == PS_SUCCESS || rc == MCMS_PARTIAL)
        {
            if (rc == PS_SUCCESS)
            {
                psAssert(remainderLen == 0);
            }
            /* Printf("         Got back %d and %d\n", compressedOutLen, remainderLen); */
            Memcpy(fullCompressedBuf + fullCompressedBufLen, compressedOut,
                compressedOutLen);
            fullCompressedBufLen += compressedOutLen;

            ctPtr += i - remainderLen;
            ctLen -= i - remainderLen;
            if (remainderLen > 0)
            {
                psAssert(ctPtr == remainder);
            }
        }
        else
        {
            Printf("Error case in matrixCmsUpdateParseCompressedData %d\n",
                rc);
        }
    }

    if (totLen > 0)
    {
        psAssert(fullCompressedBufLen == totLen);
    }
    if ((rc = zlibInflate(fullCompressedBuf, fullCompressedBufLen, &dest,
             &destSize)) < 0)
    {
        Printf("zlibInflate fail %d\n", rc);
        psFree(fullCompressedBuf, pool);
        matrixCmsFreeCompressedData(cds);
        return rc;
    }

    matrixCmsFreeCompressedData(cds);

    rc = PS_SUCCESS;
    if (destSize != myContentLen || Memcmp(myContent, dest, destSize) != 0)
    {
        Printf("Stream parse compressed data didn't match!!!\n");
        psFree(fullCompressedBuf, pool);
        psFree(dest, MATRIX_NO_POOL);
        return PS_FAILURE;
    }

    psFree(dest, MATRIX_NO_POOL);

    if (++repeat < STREAM_CD_PARSE_REPEAT)
    {
        goto REPEAT_CD_STREAM_PARSE;
    }
    psFree(fullCompressedBuf, pool);
#  endif /* end stream parse */


#  ifdef  USE_MCMS_ATOMIC_CD_PARSE
    /* And validate */
    if ((rc = matrixCmsParseCompressedData(pool, compressedData,
             compressedDataLen, &cds, flags)) < 0)
    {
        Printf("matrixCmsParseCompressedData error %d\n", rc);
        return rc;
    }

    if ((rc = zlibInflate(cds->compressedData, cds->compressedDataLen, &dest,
             &destSize)) < 0)
    {
        Printf("zlibInflate fail %d\n", rc);
        matrixCmsFreeCompressedData(cds);
        return rc;
    }

    matrixCmsFreeCompressedData(cds);

    rc = PS_SUCCESS;
    if (destSize != myContentLen || Memcmp(myContent, dest, destSize) != 0)
    {
        Printf("Create then Extract compress data didn't match!!!\n");
        rc = PS_FAILURE;
    }

    psFree(dest, MATRIX_NO_POOL);

#  endif /* end atomic parse */

    return rc;
}

#  ifdef USE_MCMS_STREAMING_CD_CREATE
int32 testStreamCompressed(char *outFile, char *content, int32 flags)
{
    unsigned char rand[4];
    int32 chunkLen;
    unsigned char *myContent, *compressedData, *dest, *p, *overallCms;
    psPool_t *createPool, *parsePool;
    int32 rc, compressedDataLen, destSize, maxSize, oi;
    psSizeL_t myContentLen;

    if ((rc = psGetFileBuf(MATRIX_NO_POOL, content, &myContent,
             &myContentLen)) < 0)
    {
        Printf("Error getting data content from file %d\n", rc);
        return rc;
    }

    if ((rc = zlibDeflate(myContent, myContentLen, &dest, &destSize)) < 0)
    {
        Printf("Error in zlibDefalte %d\n", rc);
        psFree(myContent, MATRIX_NO_POOL);
        return rc;
    }

#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    createPool = psOpenPool("createCompressed", (destSize * 2) +
        ATOMIC_CD_OH + sizeof(psPool_t), 0, NULL, NULL);
    if (createPool == NULL)
    {
        psFree(myContent, MATRIX_NO_POOL);
        return PS_MEM_FAIL;
    }
#   else
    createPool = NULL;
#   endif

    maxSize = destSize;

    /* Just appending the stream to one big buffer for this test */
    overallCms = psMalloc(MATRIX_NO_POOL, destSize + 1024);
    if (overallCms == NULL)
    {
        psFree(myContent, MATRIX_NO_POOL);
        psFree(dest, MATRIX_NO_POOL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(createPool);
#   endif
        return PS_MEM_FAIL;
    }
    oi = 0;

    if (matrixCmsInitCreateCompressedData(createPool, &compressedData,
            &compressedDataLen, flags) < 0)
    {
        psFree(myContent, MATRIX_NO_POOL);
        psFree(overallCms, MATRIX_NO_POOL);
        psFree(dest, MATRIX_NO_POOL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(createPool);
#   endif
        return PS_MEM_FAIL;
    }

    Memcpy(overallCms, compressedData, compressedDataLen);
    oi += compressedDataLen;
    psFree(compressedData, createPool);

    p = dest;
    while (destSize > 0)
    {
        psGetEntropy(rand, 4, NULL);
        chunkLen = rand[0] + rand[1];
        if (chunkLen >= destSize)
        {
            chunkLen = destSize;
        }
        if (matrixCmsUpdateCreateCompressedData(createPool, p,
                chunkLen, &compressedData, &compressedDataLen) < 0)
        {
            psFree(myContent, MATRIX_NO_POOL);
            psFree(overallCms, MATRIX_NO_POOL);
            psFree(dest, MATRIX_NO_POOL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
            psClosePool(createPool);
#   endif
            return PS_MEM_FAIL;
        }
        Memcpy(overallCms + oi, compressedData, compressedDataLen);
        oi += compressedDataLen;
        psFree(compressedData, createPool);
        destSize -= chunkLen;
        p += chunkLen;
    }
    psFree(dest, MATRIX_NO_POOL);

    if (matrixCmsFinalCreateCompressedData(createPool, &compressedData,
            &compressedDataLen, flags) < 0)
    {
        psFree(myContent, MATRIX_NO_POOL);
        psFree(overallCms, MATRIX_NO_POOL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(createPool);
#   endif
        return PS_MEM_FAIL;
    }
    Memcpy(overallCms + oi, compressedData, compressedDataLen);
    oi += compressedDataLen;
    psFree(compressedData, createPool);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(createPool);
#   endif

    writeFile(outFile, overallCms, oi);
    psFree(overallCms, MATRIX_NO_POOL);

    /* Read it back out and parse */
    if ((rc = psGetFileBuf(MATRIX_NO_POOL, outFile, &compressedData,
             &compressedDataLen)) < 0)
    {
        Printf("Error getting data content from file %d\n", rc);
        psFree(myContent, MATRIX_NO_POOL);
        return rc;
    }

    /* And validate */
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    parsePool = psOpenPool("createCompressed", +sizeof(psPool_t) +
        oi + ATOMIC_CD_OH, 0, NULL, NULL);
    if (parsePool == NULL)
    {
        psFree(myContent, MATRIX_NO_POOL);
        psFree(overallCms, MATRIX_NO_POOL);
        return PS_MEM_FAIL;
    }
#   else
    parsePool = NULL;
#   endif

    /* Parse */
    if ((rc = parseCd(parsePool, compressedData, compressedDataLen, myContent,
             myContentLen, flags)) < 0)
    {
        Printf("matrixCmsParseCompressedData error %d\n", rc);
        psFree(compressedData, parsePool);
        psFree(myContent, MATRIX_NO_POOL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(parsePool);
#   endif
        return rc;
    }
    psFree(myContent, MATRIX_NO_POOL);
    psFree(compressedData, MATRIX_NO_POOL);

#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(parsePool);
#   endif


    return rc;
}
#  endif

#  ifdef USE_MCMS_ATOMIC_CD_CREATE
int32 testAtomicCompressed(char *outFile, char *content, int32 flags)
{
    int32 rc, destSize, compressedCmsDataLen;
    psSizeL_t myContentLen, compressedDataLen;
    unsigned char *myContent, *compressedData, *dest;
    psPool_t *createPool, *parsePool;

    if ((rc = psGetFileBuf(MATRIX_NO_POOL, content, &myContent,
             &myContentLen)) < 0)
    {
        Printf("Error getting data content from file %d\n", rc);
        return rc;
    }

    if ((rc = zlibDeflate(myContent, myContentLen, &dest, &destSize)) < 0)
    {
        Printf("Error in zlibDefalte %d\n", rc);
        psFree(myContent, MATRIX_NO_POOL);
        return rc;
    }

#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    createPool = psOpenPool("createCompressed", (destSize * 2) +
        ATOMIC_CD_OH + sizeof(psPool_t), 0, NULL, NULL);
    if (createPool == NULL)
    {
        psFree(myContent, MATRIX_NO_POOL);
        psFree(dest, MATRIX_NO_POOL);
        return PS_MEM_FAIL;
    }
#   else
    createPool = NULL;
#   endif

    if ((rc = matrixCmsCreateCompressedData(createPool, dest,
             destSize, &compressedData, &compressedCmsDataLen, flags))  < 0)
    {
        Printf("matrixCmsCreateCompressedData error %d\n", rc);
        psFree(dest, MATRIX_NO_POOL);
        psFree(myContent, MATRIX_NO_POOL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(createPool);
#   endif
        return rc;
    }
    psFree(dest, MATRIX_NO_POOL);

    writeFile(outFile, compressedData, compressedCmsDataLen);
    psFree(compressedData, createPool);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(createPool);
#   endif

    /* Read it back out and parse */
    if ((rc = psGetFileBuf(MATRIX_NO_POOL, outFile, &compressedData,
             &compressedDataLen)) < 0)
    {
        Printf("Error getting data content from file %d\n", rc);
        psFree(myContent, MATRIX_NO_POOL);
        return rc;
    }
    psAssert(compressedDataLen == (psSizeL_t)compressedCmsDataLen);

#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    parsePool = psOpenPool("parseCompressed", +sizeof(psPool_t) +
        compressedDataLen + ATOMIC_CD_OH, 0, NULL, NULL);
    if (parsePool == NULL)
    {
        psFree(compressedData, MATRIX_NO_POOL);
        psFree(myContent, MATRIX_NO_POOL);
        return PS_MEM_FAIL;
    }
#   else
    parsePool = NULL;
#   endif

    /* Parse */
    if ((rc = parseCd(parsePool, compressedData, compressedDataLen, myContent,
             myContentLen, flags)) < 0)
    {
        Printf("matrixCmsParseCompressedData error %d\n", rc);
        psFree(compressedData, MATRIX_NO_POOL);
        psFree(myContent, MATRIX_NO_POOL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(parsePool);
#   endif
        return rc;
    }
    psFree(compressedData, MATRIX_NO_POOL);
    psFree(myContent, MATRIX_NO_POOL);

#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(parsePool);
#   endif

    return rc;
}
#  endif

# endif /* ANY COMPRESSED_DATA */

static int32 compressTest(void)
{
    char *inputSmall, *inputMedium, *inputLarge;
# if defined USE_MCMS_ATOMIC_CD_CREATE || defined USE_MCMS_STREAMING_CD_CREATE
    char *output;
# endif
    int32 flags, rc = 0;

    fullPath(NULL, "messageSmall.txt", &inputSmall, 1);
    fullPath(NULL, "messageLarge.txt", &inputLarge, 1);
    fullPath(NULL, "messageMedium.txt", &inputMedium, 1);

    flags = 0; /* one pass with ContentInfo, one without */
TOGGLE_CONTENT_INFO:

# ifdef USE_MCMS_ATOMIC_CD_CREATE
    fullPath(NULL, "mcmsCDatomicSmall.der", &output, 1);
    if ((rc = testAtomicCompressed(output, inputSmall, flags)) < 0)
    {
        Printf("Failed compressTest mcmsCDatomicSmall.der %d\n", rc);
        psFree(output, NULL);
        goto LBL_ERR;
    }
    psFree(output, NULL);

    fullPath(NULL, "mcmsCDatomicMed.der", &output, 1);
    if ((rc = testAtomicCompressed(output, inputMedium, flags)) < 0)
    {
        Printf("Failed compressTest mcmsCDatomicMed.der %d\n", rc);
        psFree(output, NULL);
        goto LBL_ERR;
    }
    psFree(output, NULL);

    fullPath(NULL, "mcmsCDatomicLarge.der", &output, 1);
    if ((rc = testAtomicCompressed(output, inputLarge, flags)) < 0)
    {
        Printf("Failed compressTest mcmsCDatomicLarge.der %d\n", rc);
        psFree(output, NULL);
        goto LBL_ERR;
    }
    psFree(output, NULL);
# endif

# ifdef USE_MCMS_STREAMING_CD_CREATE
    fullPath(NULL, "mcmsCDstreamSmall.der", &output, 1);
    if ((rc = testStreamCompressed(output, inputSmall, flags)) < 0)
    {
        Printf("Failed compressTest mcmsCDstreamSmall.der %d\n", rc);
        psFree(output, NULL);
        goto LBL_ERR;
    }
    psFree(output, NULL);

    fullPath(NULL, "mcmsCDstreamMed.der", &output, 1);
    if ((rc = testStreamCompressed(output, inputMedium, flags)) < 0)
    {
        Printf("Failed compressTest mcmsCDstreamMed.der %d\n", rc);
        psFree(output, NULL);
        goto LBL_ERR;
    }
    psFree(output, NULL);

    fullPath(NULL, "mcmsCDstreamLarge.der", &output, 1);
    if ((rc = testStreamCompressed(output, inputLarge, flags)) < 0)
    {
        Printf("Failed compressTest mcmsCDstreamLarge.der %d\n", rc);
        psFree(output, NULL);
        goto LBL_ERR;
    }
    psFree(output, NULL);
# endif

    if (flags == 0)
    {
        flags = MCMS_FLAGS_NO_CONTENT_INFO;
        goto TOGGLE_CONTENT_INFO;
    }

# if defined USE_MCMS_ATOMIC_CD_CREATE || defined USE_MCMS_STREAMING_CD_CREATE
LBL_ERR:
#endif
    psFree(inputSmall, NULL);
    psFree(inputMedium, NULL);
    psFree(inputLarge, NULL);
    return rc;
}


# define STREAM_SD_PARSE_REPEAT 10
/******************************************************************************/
/*
    Signed Data
 */
int32 parseSd(char *sd, psX509Cert_t *cert, unsigned char *myContent,
              int32 myContentLen, int32 flags);

/* If the final priv key parameter is provided and the SD parses to reveal
    the contents are an AED, that will parsed as well.  The inner parse
    will ONLY run in the USE_MCMS_ATOMIC_SD_PARSE case.  */
int32 parseSdNestedAed(char *sd, psX509Cert_t *cert, unsigned char *myContent,
    int32 myContentLen, int32 flags, psX509Cert_t *aedCert,
    char *aedPrivKeyFile, int32 aedFlags)
{
    psSizeL_t fileBufLen;
    psRes_t rc;
    unsigned char *fileBuf;
    psPool_t *pool;
    cmsSignedData_t *signedData;

# ifdef USE_MCMS_STREAMING_SD_PARSE
    unsigned char initTest[512];
    unsigned char myHash[MAX_HASH_SIZE];
    unsigned char *ctPtr;
    int32 repeat, ctLen, myHashLen, hashDone, i;
    uint32 contentLen, remainderLen;
    unsigned char *content, *remainder;
    psDigestContext_t hash;
# endif

    /* nested aed variables */
    unsigned char *aedOut;
    int32 aedOutLen;
    cmsEncryptedEnvelope_t *aedStructOut;
    psX509Cert_t *aedRcvCert;
    psPubKey_t aedPriv;

    Memset(&aedPriv, 0, sizeof(psPubKey_t));
    rc = PS_SUCCESS;
    if (psGetFileBuf(NULL, sd, &fileBuf, &fileBufLen) < 0)
    {
        return PS_ARG_FAIL;
    }

    /* Large memory overhead.  Didn't tune  */
# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    pool = psOpenPool("cmsSdParse", 1024 * 1024, 0, NULL, NULL);
# else
    pool = NULL;
# endif

# ifdef USE_MCMS_STREAMING_SD_PARSE
    rc = PS_LIMIT_FAIL;
    for (i = 0; i < fileBufLen; i++)
    {
        if (i > 511)
        {
            Printf("Must increase initTest size for parseSd\n");
            return PS_PARSE_FAIL;
        }
        if (rc == PS_SUCCESS)
        {
            break;
        }
        Memset(initTest, 0x0, 512);
        Memcpy(initTest, fileBuf, i);
        rc = matrixCmsInitParseSignedData(pool, initTest, i,
            &signedData, &content, &contentLen, flags);
        if (rc != PS_LIMIT_FAIL && rc != PS_SUCCESS)
        {
            Printf("SD stream init issue: %d %d\n", i, rc);
        }
    }
    /* Byte by byte so no contents expected.  Except for detached content where
        we need to go one byte beyond to double check */
    psAssert(contentLen == 0 || contentLen == 1);

    /* Start over with random lengths */
    matrixCmsFreeParsedSignedData(signedData);

    repeat = 0;
REPEAT_SD_STREAM_PARSE:
    /* Now that the per-byte Init test is done, we randomize the lengths to
        test the streaming API set */
    rc = PS_LIMIT_FAIL;
    while (rc == PS_LIMIT_FAIL)
    {
        i = (int32) random_at_most(fileBufLen);
        rc = matrixCmsInitParseSignedData(pool, fileBuf, i, &signedData,
            &content, &contentLen, flags);
    }
    psAssert(rc == PS_SUCCESS);
    if (rc != PS_SUCCESS)
    {
        /* step through this assert error!  REMOVE WHEN DONE */
        matrixCmsFreeParsedSignedData(signedData);
        rc = matrixCmsInitParseSignedData(pool, fileBuf, i, &signedData,
            &content, &contentLen, flags);
    }

    /* Start the hash of the expected content */
    switch (signedData->digestId)
    {
    case OID_SHA256_ALG:
        psSha256Init(&hash.u.sha256);
        myHashLen = SHA256_HASH_SIZE;
        break;
    case OID_SHA384_ALG:
        psSha384Init(&hash.u.sha384);
        myHashLen = SHA384_HASH_SIZE;
        break;
    case OID_SHA512_ALG:
        psSha512Init(&hash.u.sha512);
        myHashLen = SHA512_HASH_SIZE;
        break;
    default:;
    }

    hashDone = 0;
    if (signedData->eContentLen == 0)
    {
        /* This is a detached mode.  Hash the content that we're testing */
        switch (signedData->digestId)
        {
        case OID_SHA256_ALG:
            psSha256Update(&hash.u.sha256, myContent, myContentLen);
            psSha256Final(&hash.u.sha256, myHash);
            hashDone = 1;
            break;
        case OID_SHA384_ALG:
            psSha384Update(&hash.u.sha384, myContent, myContentLen);
            psSha384Final(&hash.u.sha384, myHash);
            hashDone = 1;
            break;
        case OID_SHA512_ALG:
            psSha512Update(&hash.u.sha512, myContent, myContentLen);
            psSha512Final(&hash.u.sha512, myHash);
            hashDone = 1;
            break;
        default:;
        }

    }

    /* i is still sitting at how much of the fileBuf has been processed
        from the Init.  Set us back to the start of the data
        so we can do all the updates in one loop */
    ctPtr = fileBuf + i - contentLen;
    ctLen = fileBufLen - i + contentLen;

    rc = MCMS_PARTIAL;
    while (rc == MCMS_PARTIAL)
    {
        if (ctLen == 0)
        {
            Printf("Error in ctLen\n");
        }
        i = (int32) random_at_most(ctLen);

        rc = matrixCmsUpdateParseSignedData(pool, signedData, ctPtr,
            i, &content, &contentLen, &remainder, &remainderLen);

        if (rc == PS_SUCCESS || rc == MCMS_PARTIAL)
        {
            if (rc == PS_SUCCESS)
            {
                psAssert(remainderLen == 0);
            }
            /* Update the hash */
            if (contentLen > 0)
            {
                if (hashDone == 1)
                {
                    Printf("not cool\n");
                }
                psAssert(hashDone == 0);
                switch (signedData->digestId)
                {
                case OID_SHA256_ALG:
                    psSha256Update(&hash.u.sha256, content, contentLen);
                    break;
                case OID_SHA384_ALG:
                    psSha384Update(&hash.u.sha384, content, contentLen);
                    break;
                case OID_SHA512_ALG:
                    psSha512Update(&hash.u.sha512, content, contentLen);
                    break;
                default:;
                }
            }

            ctPtr += i - remainderLen;
            ctLen -= i - remainderLen;
            if (remainderLen > 0)
            {
                psAssert(ctPtr == remainder);
            }
        }
        else if (rc == PS_LIMIT_FAIL)
        {
            psAssert(contentLen == 0);
            /* Didn't have enough for the after-content ASN.1 */
            rc = MCMS_PARTIAL; /* Just keep loop moving */
        }
        else
        {
            Printf("Error case in matrixCmsUpdateParseSignedData %d\n",
                rc);
        }
    }

    if (hashDone == 0)
    {
        switch (signedData->digestId)
        {
        case OID_SHA256_ALG:
            psSha256Final(&hash.u.sha256, myHash);
            break;
        case OID_SHA384_ALG:
            psSha384Final(&hash.u.sha384, myHash);
            break;
        case OID_SHA512_ALG:
            psSha512Final(&hash.u.sha512, myHash);
            break;
        default:;
        }
    }

    if ((rc = matrixCmsFinalParseSignedData(pool, signedData, myHash,
             myHashLen, cert)) < 0)
    {
        Printf("ERRROR confirming signature %d\n", rc);
    }

    matrixCmsFreeParsedSignedData(signedData);

    if (++repeat < STREAM_SD_PARSE_REPEAT)
    {
        goto REPEAT_SD_STREAM_PARSE;
    }

# endif /* STREAMING */


# ifdef USE_MCMS_ATOMIC_SD_PARSE

    if ((rc = matrixCmsParseSignedData(pool, fileBuf, fileBufLen,
             &signedData, flags)) < 0)
    {
        Printf("Error parsing signed data file %d\n", rc);
        psFree(fileBuf, NULL);
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(pool);
#  endif
        return -1;
    }

    /* This is for the tests where they embed an AED in a signedData.
        We called this parseSd so it can run through all the streaming and
        atomic parsing tests of the outer CMS and now will call parseAed so it
        can do the same for these embedded types.  Call the native atomic API
        first so we     can extract the contents though */
    if (aedPrivKeyFile != NULL)
    {

        if (psEccParsePrivFile(pool, aedPrivKeyFile,  NULL, &aedPriv.key.ecc)
            < 0)
        {
            matrixCmsFreeParsedSignedData(signedData);
            Printf("Error parsing nested AED priv key\n");
            psFree(fileBuf, NULL);
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
            psClosePool(pool);
#  endif
            return -1;
        }
        aedPriv.type = PS_ECC;
        aedPriv.keysize = psEccSize(&aedPriv.key.ecc);

        aedOut = NULL;
        if (aedCert == NULL)
        {
            /* Just have to assume the signedData cert was the same one used
                for the AED */
            aedRcvCert = signedData->cert;
        }
        else
        {
            aedRcvCert = aedCert;
        }
        if ((rc = matrixCmsParseAuthEnvData(pool, signedData->eContent,
                 signedData->eContentLen, aedRcvCert, &aedPriv, aedFlags,
                 &aedOut, &aedOutLen, &aedStructOut)) < 0)
        {
            matrixCmsFreeParsedSignedData(signedData);
            psClearPubKey(&aedPriv);
            Printf("Error atomic parsing nested AED %d\n", rc);
            psFree(fileBuf, NULL);
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
            psClosePool(pool);
#  endif
            return -1;
        }
        matrixCmsFreeParsedAuthEnvData(aedStructOut);
        psAssert(aedOut);
        /* parseAed wants file input so write it to temp */
        writeFile("./aed.bin", signedData->eContent, signedData->eContentLen);
        if ((rc = parseAed("./aed.bin", &aedPriv, aedRcvCert, aedFlags, aedOut,
                 aedOutLen)) < 0)
        {
            matrixCmsFreeParsedSignedData(signedData);
            psClearPubKey(&aedPriv);
            psFree(aedOut, pool);
            Printf("Error parsing nested AED %d\n", rc);
            psFree(fileBuf, NULL);
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
            psClosePool(pool);
#  endif
            return -1;
        }
        psFree(aedOut, pool);
        psClearPubKey(&aedPriv);
    }

    if ((rc = matrixCmsConfirmSignature(pool, signedData, myContent,
             myContentLen, cert)) < 0)
    {
        Printf("Error confirming signature %d\n", rc);
    }

    matrixCmsFreeParsedSignedData(signedData);
# endif /* ATOMIC */

    psFree(fileBuf, NULL);

# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
# endif
    return rc;
}

int32 parseSd(char *sd, psX509Cert_t *cert, unsigned char *myContent,
    int32 myContentLen, int32 flags)
{
    /* Empty final 3 params will bypass any nested content parse */
    return parseSdNestedAed(sd, cert, myContent, myContentLen, flags, NULL,
        NULL, 0);

}

# ifdef USE_MCMS_STREAMING_SD_CREATE
static int32 createSdFromBufStream(char *outFile, unsigned char *messageData,
    int32 messageDataLen, int32 contentType, psX509Cert_t *myCert,
    psPubKey_t *privKey, int32 hash, int32 flags)
{
    psPool_t *pool;
    cmsSdStream_t *sdCtx;
    unsigned char *outputBuf, *masterBuf;
    unsigned char rand[4];
    unsigned char *p;
    int32 rc, outputLen, masterId, chunkLen;

#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
    pool = psOpenPool("createSdFromBuf", (messageDataLen * 2) + 2048 + 1024,
        0, NULL, NULL);
#  else
    pool = NULL;
#  endif

    masterBuf = psMalloc(pool, messageDataLen + 12000);
    masterId = 0;
    if ((rc = matrixCmsInitCreateSignedData(pool, myCert, privKey, hash,
             contentType, &outputBuf,    &outputLen, flags, &sdCtx)) < 0)
    {
        Printf("matrixCmsInitCreateSd failed in createSdFromBufStream\n");
        psFree(masterBuf, pool);
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(pool);
#  endif
        return rc;
    }
    Memcpy(masterBuf, outputBuf, outputLen);
    masterId += outputLen;
    psFree(outputBuf, pool);

    /* Chop up messageData to feed to Update */
    p = messageData;
    while (messageDataLen > 0)
    {
        psGetEntropy(rand, 4, NULL);
        chunkLen = rand[0] + rand[1] + rand[2];
        if (chunkLen >= messageDataLen)
        {
            chunkLen = messageDataLen;
        }
        rc = matrixCmsUpdateCreateSignedData(pool, sdCtx, p, chunkLen,
            &outputBuf, &outputLen);
        Memcpy(masterBuf + masterId, outputBuf, outputLen);
        masterId += outputLen;
        psFree(outputBuf, pool);
        messageDataLen -= chunkLen;
        p += chunkLen;
    }

    matrixCmsFinalCreateSignedData(pool, sdCtx, &outputBuf, &outputLen);
    Memcpy(masterBuf + masterId, outputBuf, outputLen);
    masterId += outputLen;
    psFree(outputBuf, pool);

    matrixCmsFreeStreamCreatedSignedData(sdCtx);

    writeFile(outFile, masterBuf, masterId);
    psFree(masterBuf, pool);

#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
#  endif
    return 0;
}

static int32 runSDstream(unsigned char *messageData, int32 messageDataLen,
    psX509Cert_t *cert, psPubKey_t *privkey, int32 flags)
{
    int32 rc;
    char *output;

    nextSdStreamFile(&output);
    rc = createSdFromBufStream(output, messageData, messageDataLen,
        CMS_PKCS7_DATA, cert, privkey, MCMS_SHA256_ALG, flags);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextSdStreamFile(&output);
    rc = createSdFromBufStream(output, messageData, messageDataLen,
        CMS_PKCS9_AUTH_ENVELOPED_DATA, cert, privkey, MCMS_SHA384_ALG, flags);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextSdStreamFile(&output);
    rc = createSdFromBufStream(output, messageData, messageDataLen,
        CMS_PKCS9_COMPRESSED_DATA, cert, privkey, MCMS_SHA384_ALG, flags);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }
    return 0;
}
# endif /* STREAMING SD */


# ifdef USE_MCMS_ATOMIC_SD_CREATE
static int32 createSdFromBufPrehashed(char *outFile, unsigned char *messageData,
    int32 messageDataLen, int32 contentType, psX509Cert_t *myCert,
    psPubKey_t *privKey, int32 hash, int32 flags)
{
    psPool_t *pool;
    psDigestContext_t md;
    unsigned char *outputBuf;
    unsigned char prehashed[MAX_HASH_SIZE];
    int32 outputLen, hashSize, rc;

    hashSize = 0;
    if (hash == MCMS_SHA256_ALG)
    {
        psSha256Init(&md.u.sha256);
        psSha256Update(&md.u.sha256, messageData, messageDataLen);
        psSha256Final(&md.u.sha256, prehashed);
        hashSize = SHA256_HASH_SIZE;
    }
    else if (hash == MCMS_SHA384_ALG)
    {
        psSha384Init(&md.u.sha384);
        psSha384Update(&md.u.sha384, messageData, messageDataLen);
        psSha384Final(&md.u.sha384, prehashed);
        hashSize = SHA384_HASH_SIZE;
    }
    else if (hash == MCMS_SHA512_ALG)
    {
        psSha512Init(&md.u.sha512);
        psSha512Update(&md.u.sha512, messageData, messageDataLen);
        psSha512Final(&md.u.sha512, prehashed);
        hashSize = SHA512_HASH_SIZE;
    }
    else
    {
        psSha1Init(&md.u.sha1);
        psSha1Update(&md.u.sha1, messageData, messageDataLen);
        psSha1Final(&md.u.sha1, prehashed);
        hashSize = SHA1_HASH_SIZE;
    }

    /* Large memory overhead is for ECDSA signature operation */
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
    pool = psOpenPool("createSdFromBuf", 14336 + sizeof(psPool_t), 0, NULL,
        NULL);
#  else
    pool = NULL;
#  endif

    if ((rc = matrixCmsCreateSignedData(pool, prehashed, hashSize, contentType,
             myCert, privKey, hash, &outputBuf, &outputLen, flags)) < 0)
    {
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(pool);
#  endif
        Printf("matrixCmsCreateSd failed in createSdFromBufPrehashed %d\n", rc);
        return rc;
    }

    writeFile(outFile, outputBuf, outputLen);

    psFree(outputBuf, pool); outputBuf = NULL;
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
#  endif
    return 0;
}


static int32 createSdFromBuf(char *outFile, unsigned char *messageData,
    int32 messageDataLen, int32 contentType, psX509Cert_t *myCert,
    psPubKey_t *privKey, int32 hash, int32 flags)
{
    psPool_t *pool;
    unsigned char *outputBuf;
    int32 outputLen, rc;

#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
    pool = psOpenPool("createSdFromBuf", (messageDataLen * 2) +
        1024 + sizeof(psPool_t), 0, NULL, NULL);
#  else
    pool = NULL;
#  endif

    if ((rc = matrixCmsCreateSignedData(pool, messageData, messageDataLen,
             contentType, myCert, privKey, hash, &outputBuf, &outputLen, flags))
        < 0)
    {
        Printf("matrixCmsCreateSd failed in createSdFromBuf %d\n", rc);
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(pool);
#  endif
        return rc;
    }

    writeFile(outFile, outputBuf, outputLen);
    psFree(outputBuf, pool); outputBuf = NULL;

#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
#  endif
    return 0;
}

static int32 runSDprehashed(unsigned char *messageData, int32 messageDataLen,
    psX509Cert_t *cert, psPubKey_t *privkey, int32 flags)
{
    int32 rc;
    char *output;

    nextSdFile(&output);
    rc = createSdFromBufPrehashed(output, messageData, messageDataLen,
        CMS_PKCS9_AUTH_ENVELOPED_DATA, cert, privkey, MCMS_SHA256_ALG,
        flags | MCMS_FLAGS_SD_CONTENT_PREHASHED);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextSdFile(&output);
    rc = createSdFromBufPrehashed(output, messageData, messageDataLen,
        CMS_PKCS7_DATA, cert, privkey, MCMS_SHA384_ALG,
        flags | MCMS_FLAGS_SD_CONTENT_PREHASHED);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextSdFile(&output);
    rc = createSdFromBufPrehashed(output, messageData, messageDataLen,
        CMS_PKCS7_SIGNED_DATA, cert, privkey, MCMS_SHA512_ALG,
        flags | MCMS_FLAGS_SD_CONTENT_PREHASHED);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }
    return 0;
}

static int32 runSD(unsigned char *messageData, int32 messageDataLen,
    psX509Cert_t *cert, psPubKey_t *privkey, int32 flags)
{
    int32 rc;
    char *output;

    nextSdFile(&output);
    rc = createSdFromBuf(output, messageData, messageDataLen, CMS_PKCS7_DATA,
        cert, privkey, MCMS_SHA256_ALG, flags);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextSdFile(&output);
    rc = createSdFromBuf(output, messageData, messageDataLen,
        CMS_PKCS7_SIGNED_DATA, cert, privkey, MCMS_SHA384_ALG, flags);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextSdFile(&output);
    rc = createSdFromBuf(output, messageData, messageDataLen,
        CMS_PKCS9_AUTH_ENVELOPED_DATA, cert, privkey, MCMS_SHA512_ALG, flags);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseSd(output, cert, messageData, messageDataLen, flags);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    return 0;
}
# endif /* ATOMIC SD */

static int32 parseMozillaCertBundle(void)
    /*const char *sdFilename,
        const char *certFilename,
        const char *keyFilename)*/
{
    char *in;
    unsigned char *inData;
    psSizeL_t inDataLen;
    int32 rc;
    cmsSignedData_t *sd;

    char *sdFilename = "signed_mozilla_cacert.der";
    int32 flags = 0;

    fullPath(NULL, (char*)sdFilename, &in, 1);

    if ((rc = psGetFileBuf(NULL, in, &inData, &inDataLen)) < 0)
    {
        Printf("Error getting message from file %d\n", rc);
        goto LBL_ERR;
    }

    /* Check that the data is actually something we can't parse without
       extra flags */
    rc = matrixCmsParseSignedData(NULL, inData, inDataLen, &sd, flags);
    if (rc >= 0)
    {
        Printf("matrixCmsParseSignedData didn't fail even though "
                "it was expected to: %d\n", rc);
        goto LBL_ERR;
    }

    /* Set the nessessary flags and parse it regardless. */
    flags = MCMS_FLAGS_PD_CERT_STORE_ONLY;
    rc = matrixCmsParseSignedData(NULL, inData, inDataLen, &sd, flags);
    if (rc < 0)
    {
        Printf("matrixCmsParseSignedData failed: %d\n", rc);
        goto LBL_ERR;
    }

    return PS_SUCCESS;
LBL_ERR:
    Printf("Failed\n");
    return PS_FAILURE;
}

static int32 parseSdFile(const char *sdFilename,
        const char *certFilename,
        const char *keyFilename)
{
    char *in;
    char *cert;
    char *priv;
    unsigned char *inData;
    psSizeL_t inDataLen;
    psX509Cert_t *myCert;
    psPubKey_t myPrivKey;
    int32 rc;
    cmsSignedData_t *sd;

    fullPath(NULL, (char*)sdFilename, &in, 1);
    fullPath(NULL, (char*)keyFilename, &priv, 0);
    fullPath(NULL, (char*)certFilename, &cert, 0);

    if ((rc = psGetFileBuf(NULL, in, &inData, &inDataLen)) < 0)
    {
        Printf("Error getting message from file %d\n", rc);
        goto LBL_ERR;
    }

    if ((rc = psX509ParseCertFile(NULL, cert, &myCert,
             CERT_STORE_UNPARSED_BUFFER | CERT_STORE_DN_BUFFER)) < 0)
    {
        Printf("Error parsing cert file %d\n", rc);
        goto LBL_ERR;
    }

    if ((rc = psPkcs1ParsePrivFile(NULL, priv, NULL, &myPrivKey.key.rsa))
            < 0)
    {
        Printf("Error parsing cert file %d\n", rc);
        goto LBL_ERR;
    }
    myPrivKey.type = PS_RSA;
    myPrivKey.keysize = psRsaSize(&myPrivKey.key.rsa);

    rc = matrixCmsParseSignedData(NULL, inData, inDataLen, &sd, 0);
    if (rc < 0)
    {
        Printf("matrixCmsParseSignedData failed: %d\n", rc);
        goto LBL_ERR;
    }

    rc = matrixCmsConfirmSignature(NULL, sd, NULL, 0, myCert);
    if (rc < 0)
    {
        Printf("matrixCmsConfirmSignature failed: %d\n", rc);
    }
    return PS_SUCCESS;

LBL_ERR:
    Printf("Failed\n");
    return PS_FAILURE;
}

static int32 signedDataTest(int32 keysize)
{
    psX509Cert_t *myCert;
    psPubKey_t privKey;
    char *cert, *privkey;
    char *message;
    unsigned char *messageData;
    psSizeL_t messageDataLen;
    int32 rc, flags, ncflags;

    flags = 0;
    myCert = NULL;
    cert = privkey = message = NULL;
    messageData = NULL;

    Memset(&privKey, 0, sizeof(psPubKey_t));

    if (keysize == 224)
    {
        fullPath(NULL, "EC/224_EC.pem", &cert, 0);
        fullPath(NULL, "EC/224_EC_KEY.pem", &privkey, 0);
    }
    else if (keysize == 256)
    {
        fullPath(NULL, "EC/256_EC.pem", &cert, 0);
        fullPath(NULL, "EC/256_EC_KEY.pem", &privkey, 0);
    }
    else if (keysize == 384)
    {
        fullPath(NULL, "EC/384_EC.pem", &cert, 0);
        fullPath(NULL, "EC/384_EC_KEY.pem", &privkey, 0);
    }
    else if (keysize == 521)
    {
        fullPath(NULL, "EC/521_EC.pem", &cert, 0);
        fullPath(NULL, "EC/521_EC_KEY.pem", &privkey, 0);
    }
    else
    {
        fullPath(NULL, "EC/192_EC.pem", &cert, 0);
        fullPath(NULL, "EC/192_EC_KEY.pem", &privkey, 0);
    }

    /* Select test message to use: */
    /* fullPath(NULL, "messageLarge.txt", &message, 1); */
    fullPath(NULL, "messageMedium.txt", &message, 1);

    if ((rc = psGetFileBuf(NULL, message, &messageData, &messageDataLen)) < 0)
    {
        Printf("Error getting message from file %d\n", rc);
        goto LBL_ERR;
    }

    if ((rc = psX509ParseCertFile(NULL, cert, &myCert,
             CERT_STORE_UNPARSED_BUFFER | CERT_STORE_DN_BUFFER)) < 0)
    {
        Printf("Error parsing cert file %d\n", rc);
        goto LBL_ERR;
    }

    if (myCert->pubKeyAlgorithm == OID_RSA_KEY_ALG)
    {
# ifdef USE_RSA
        if ((rc = psPkcs1ParsePrivFile(NULL, privkey, NULL, &privKey.key.rsa))
            < 0)
        {
            Printf("Error parsing cert file %d\n", rc);
            goto LBL_ERR;
        }
        privKey.type = PS_RSA;
        privKey.keysize = psRsaSize(&privKey.key.rsa);
# else
        Printf("RSA not enabled\n");
        goto LBL_ERR;
# endif
    }
    else
    {
        if ((rc = psEccParsePrivFile(NULL, privkey, NULL, &privKey.key.ecc))
            < 0)
        {
            Printf("Error parsing cert file %d\n", rc);
            goto LBL_ERR;
        }
        privKey.type = PS_ECC;
        privKey.keysize = psEccSize(&privKey.key.ecc);
    }

    ncflags = 0; /* One pass with ContentInfo and one without */
TOGGLE_CONTENT_INFO:

# ifdef USE_MCMS_ATOMIC_SD_CREATE
    flags = MCMS_FLAGS_SD_NODETACH | ncflags;
    if ((rc = runSD(messageData, messageDataLen, myCert, &privKey, flags)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_SD_NODETACH | MCMS_FLAGS_SD_SUBJECT_KEY_ID | ncflags;
    if ((rc = runSD(messageData, messageDataLen, myCert, &privKey, flags)) < 0)
    {
        goto LBL_ERR;
    }

    flags = ncflags;
    if ((rc = runSD(messageData, messageDataLen, myCert, &privKey, flags)) < 0)
    {
        goto LBL_ERR;
    }
    if ((rc = runSDprehashed(messageData, messageDataLen, myCert, &privKey,
             flags)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_SD_SUBJECT_KEY_ID | ncflags;
    if ((rc = runSD(messageData, messageDataLen, myCert, &privKey, flags)) < 0)
    {
        goto LBL_ERR;
    }
    if ((rc = runSDprehashed(messageData, messageDataLen, myCert, &privKey,
             flags)) < 0)
    {
        goto LBL_ERR;
    }

# endif

# ifdef USE_MCMS_STREAMING_SD_CREATE
    /* Content is always attached so don't need NODETACH */
    flags = 0 | ncflags;
    if ((rc = runSDstream(messageData, messageDataLen, myCert, &privKey,
             flags)) < 0)
    {
        goto LBL_ERR;
    }

    flags =  MCMS_FLAGS_SD_SUBJECT_KEY_ID | ncflags;
    if ((rc = runSDstream(messageData, messageDataLen, myCert, &privKey,
             flags)) < 0)
    {
        goto LBL_ERR;
    }
# endif

    if (ncflags == 0)
    {
        ncflags = MCMS_FLAGS_NO_CONTENT_INFO;
        goto TOGGLE_CONTENT_INFO;
    }

LBL_ERR:
    if (messageData)
    {
        psFree(messageData, NULL);
    }
    if (message)
    {
        psFree(message, NULL);
    }
    if (cert)
    {
        psFree(cert, NULL);
    }
    if (privkey)
    {
        psFree(privkey, NULL);
    }
    if (myCert)
    {
        psX509FreeCert(myCert);
    }
    psClearPubKey(&privKey);
    return rc;
}

# if defined(USE_MCMS_ATOMIC_AED_CREATE) \
    || defined(USE_MCMS_STREAMING_AED_CREATE) \
    || defined(USE_MCMS_ATOMIC_AED_PARSE) \
    || defined(USE_MCMS_STREAMING_AED_PARSE)

#  define REPEAT_STREAM_PARSE_CNT 10
/******************************************************************************/
/*
    Authenticated-Enveloped Data parse tester.  If stream parsing is enabled
    run through several random parses.
 */
int32 parseAed(char *sd, psPubKey_t *privKey, psX509Cert_t *cert,
    int32 lflags, unsigned char *origMsg, int32 origMsgLen)
{
    int32 rc, contentLen, flags;
    psSizeL_t fileBufLen;
    unsigned char *content, *fileBuf;
    cmsEncryptedEnvelope_t *ee;
    psPool_t *pool;

#  ifdef USE_MCMS_STREAMING_AED_PARSE
    int32 ptIdx, i, repeat, insitu, remainderLen, ctLen;
    unsigned char *ctPtr, *remainder;
    unsigned char initTest[2048];
#  endif

    if (lflags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        flags = MCMS_FLAGS_NO_CONTENT_INFO;
    }
    else
    {
        flags = 0;
    }

    if ((rc = psGetFileBuf(NULL, sd, &fileBuf, &fileBufLen)) < 0)
    {
        return rc;
    }

    /* The 12K addition to the memory pool is for the ECDSA
        key generation operation in matrixCmsConfirmEncryptedEnvelope.

        The (3 * fileBufLen) is for the worst case scenario of an atomic
        parse into a dedicated buffer of a stream generated AED.  The atomic
        parse packs all the     component parts of the stream ciphertext into one
        allocated buffer.  So then if a user is atomic parsing into a dedicated
        buffer there will be 3 buffers of the content data */
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
    pool = psOpenPool("cmsAedParse", (3 * fileBufLen) + (12 * 1024) +
        sizeof(psPool_t), 0, NULL, NULL);
    if (pool == NULL)
    {
        psFree(fileBuf, NULL);
        return PS_MEM_FAIL;
    }
#  else
    pool = NULL;
#  endif

    /* Do both stream parse and atomic parse if enabled */

#  ifdef USE_MCMS_STREAMING_AED_PARSE

    rc = PS_LIMIT_FAIL;
    /* Feeding a single byte at a time to test the ability to correctly
        return PS_LIMIT_FAIL at every Init location. Move it to a dedicated
        initTest array to ensure we are not missing a length test and moving
        into the "good" data beyond the length we supplied */
    for (i = 0; i < fileBufLen; i++)
    {
        if (rc == PS_SUCCESS)
        {
            break;
        }
        if (i == 493)
        {
            /* Printf("debug catcher\n"); */
        }
        if (i == 2047 )
        {
            Printf("Need to increase initTest in parseAed\n");
            return PS_FAILURE;
        }
        Memset(initTest, 0x0, 2048);
        Memcpy(initTest, fileBuf, i);
        rc = matrixCmsInitParseAuthEnvData(pool, initTest, i, &ee,
            &content, &contentLen, flags);
        if (rc != PS_SUCCESS && rc != PS_LIMIT_FAIL)
        {
            Printf("AED Init stream parse issue: %d %d\n", i, rc);
        }
    }
    /* fed a byte at a time until success so there should be no additional
        content when complete */
    if (contentLen != 0)
    {
        /* Printf("To catch\n"); */
    }
    psAssert(contentLen == 0);

    /* Going to start over with random lengths so free the context now */
    matrixCmsFreeParsedAuthEnvData(ee);

    repeat = 0;
REPEAT_STREAM_PARSE:
    /* Now that the per-byte Init test is done, we randomize the lengths to
        test the streaming API set */
    rc = PS_LIMIT_FAIL;
    while (rc == PS_LIMIT_FAIL)
    {
        i = (int32) random_at_most(fileBufLen);
        rc = matrixCmsInitParseAuthEnvData(pool, fileBuf, i, &ee,
            &content, &contentLen, flags);
    }
    if (rc != PS_SUCCESS)
    {
        /* Printf("catch\n"); */
    }
    psAssert(rc == PS_SUCCESS);

    /* User would look in ee to find the recipient info to decide which cert
        and     privKey to pass here */
    matrixCmsPostInitParseAuthEnvData(pool, ee, cert, privKey);

    /* Send any 'content' remaining from the Init call to Update immediately */
    rc = matrixCmsUpdateParseAuthEnvData(pool, content, contentLen, ee,
        &content, &contentLen, contentLen, &remainder, &remainderLen);

    if (rc == MCMS_UNKNOWN)
    {
        /* We can cheat the logic needed here because we actually know how
            large our expected data is */
        if (contentLen != origMsgLen)
        {
            rc = MCMS_PARTIAL;
        }
        else
        {
            Printf("Did entire processing in initial Update!\n");
        }
    }

    ptIdx = 0;
    if (Memcmp(origMsg + ptIdx, content, contentLen) != 0)
    {
        Printf("STREAM OPENED ENVELOPE DOES NOT MATCH ORIGNAL. FIRST UPDATE\n");
        psTraceBytes("orig", origMsg + ptIdx, contentLen);
        psTraceBytes("decrypted", content, contentLen);
        return -1;
    }
    ptIdx += contentLen;

    /* i is still sitting at how much of the fileBuf has been processed
        from the Init and first Update.  Account for the remainder that
        still must be passed to the next Update */
    ctPtr = fileBuf + i - remainderLen;
    ctLen = fileBufLen - i + remainderLen;

    if (remainderLen > 0 && ctPtr != remainder)
    {
        psAssert(0);
    }

    while (rc == MCMS_PARTIAL)
    {
        i = (int32) random_at_most(ctLen);
        /* Run odd random numbers through an in-situ Update call and run
            even random numbers to a dedicated decrypt outbuf */
        if (i % 2)
        {
            content = ctPtr;
            insitu = 1;
        }
        else
        {
            if ((content = psMalloc(pool, i)) == NULL)
            {
                Printf("Memory allocation error in Update loop\n");
                return PS_MEM_FAIL;
            }
            insitu = 0;
        }
        rc = matrixCmsUpdateParseAuthEnvData(pool, ctPtr, i, ee,
            &content, &contentLen, i, &remainder, &remainderLen);
        if (rc == MCMS_UNKNOWN)
        {
            psAssert(remainderLen == 0);
            /* case where fell exactly on end of component and had no
                way of knowing if it's padded or not.  This case requires
                an application specific handler and we know in
                this test case the exact size we are waiting for so
                we can determine the case and set return value correctly
                for processing to continue */
            if (ptIdx + contentLen > origMsgLen)
            {
                contentLen -= content[contentLen - 1];
                psAssert(ptIdx + contentLen == origMsgLen);
            }
            /* Always set rc to PARTIAL to make sure Update gets called
                again because this case always means there is more data
                to read... even if it's just the final four 0x0 bytes */
            rc = MCMS_PARTIAL;
        }
        if (rc == MCMS_PARTIAL || rc == PS_SUCCESS)
        {
            if (Memcmp(origMsg + ptIdx, content, contentLen) != 0)
            {
                Printf("STREAM OPENED ENVELOPE DOES NOT MATCH ORIGNAL!\n");
                psTraceBytes("orig", origMsg + ptIdx, contentLen);
                psTraceBytes("decrypted", content, contentLen);
                return -1;
            }
            ptIdx += contentLen;
            /* Can't just use "contentLen" to incr and decr because of the
                final padding bytes in the CMAC case will create a condition
                where "i != contentLen + remainderLen" */
            ctPtr += i - remainderLen;
            ctLen -= i - remainderLen;
        }
        else if (rc == PS_LIMIT_FAIL)
        {
            /* The random i was too small for a single block decrypt.  Reset
                and try again */
            rc = MCMS_PARTIAL;
        }
        else
        {
            Printf("Failure case in UpdateParseAuthEnvData %d\n", rc);
        }
        if (insitu == 0)
        {
            psFree(content, pool);
        }
    }
    if (ptIdx != origMsgLen)
    {
        psAssert(0);
    }

    /* Final.  Feeding a single byte at a time to test the ability to correctly
        return PS_LIMIT_FAIL at every Final location. */
    rc = PS_LIMIT_FAIL;
    for (i = 0; i < fileBufLen; i++)
    {
        if (rc == PS_SUCCESS)
        {
            break;
        }
        if (i == 2047 )
        {
            Printf("Need to increase initTest in parseAed\n");
            return PS_FAILURE;
        }
        Memset(initTest, 0x0, 2048);
        Memcpy(initTest, ctPtr, i);
        rc = matrixCmsFinalParseAuthEnvData(pool, initTest, i, ee);
        if (rc != PS_SUCCESS && rc != PS_LIMIT_FAIL)
        {
            Printf("AED Final stream parse issue: %d %d\n", i, rc);
        }
    }

    matrixCmsFreeParsedAuthEnvData(ee);

    /* This test run was doing in-situ decrypt so need to close and reopen */
    psFree(fileBuf, NULL);
    if ((rc = psGetFileBuf(NULL, sd, &fileBuf, &fileBufLen)) < 0)
    {
        return rc;
    }

    /* random stream parses */
    if (repeat++ < REPEAT_STREAM_PARSE_CNT)
    {
        goto REPEAT_STREAM_PARSE;
    }

#  endif /* !USE_MCMS_STREAMING_AED_PARSE */


#  ifdef USE_MCMS_ATOMIC_AED_PARSE
    /*  Atomic test with insitu decode. For CONSTRUCTED content AED buffers the
        encrypted data has already been allocated to pack all the data together.
        So,     if this is a really large file there will already be two copies of
        the encrypted data.  So if you are not "overwritting" then you are
        basically getting 3 buffers of the data which could be too much */
    flags |= MCMS_FLAGS_EE_OVERWRITE_CT;
    if ((rc = matrixCmsParseAuthEnvData(pool, fileBuf, fileBufLen,
             cert, privKey, flags, &content, &contentLen, &ee))  < 0)
    {
        Printf("Error parsing or authenticating auth env data file %d\n", rc);
        psFree(fileBuf, NULL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(pool);
#   endif
        return rc;
    }

    psAssert(contentLen == origMsgLen);
    if (Memcmp(origMsg, content, contentLen) != 0)
    {
        Printf("ATOMIC INSITU OPENED ENVELOPE DOES NOT MATCH ORIGNAL CONTENT!\n");
        rc = -1;
    }
    /* NOTE: Important to free envelope after "content" is used because in the
        case of a parse of a stream-based AED, the content is pointing into
        the envelope structure.  In the atomic-based AED blob the atomic insitu
        decrypt is happening in the "fileBuf" directly */
    matrixCmsFreeParsedAuthEnvData(ee);

    /* This test run was doing in-situ decrypt so need to close and reopen
        for the dedicated buffer test*/
    psFree(fileBuf, NULL);
    if ((rc = psGetFileBuf(NULL, sd, &fileBuf, &fileBufLen)) < 0)
    {
        return rc;
    }

    /* Atomic test with dedicated output buffer */
    flags &= ~MCMS_FLAGS_EE_OVERWRITE_CT; /* saves MCMS_FLAGS_NO_CONTENT_INFO */
    if ((rc = matrixCmsParseAuthEnvData(pool, fileBuf, fileBufLen,
             cert, privKey, flags, &content, &contentLen, &ee))  < 0)
    {
        Printf("Error parsing or authenticating signed data file %d\n", rc);
        psFree(fileBuf, NULL);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(pool);
#   endif
        return rc;
    }
    /* Safe to free here because content is outside this context always */
    matrixCmsFreeParsedAuthEnvData(ee);

    psAssert(contentLen == origMsgLen);
    if (Memcmp(origMsg, content, contentLen) != 0)
    {
        Printf("ATOMIC OPENED ENVELOPE DOES NOT MATCH ORIGNAL CONTENT!\n");
        rc = -1;
    }
    psFree(content, pool);
#  endif /* USE_MCMS_ATOMIC_AED_PARSE */

    psFree(fileBuf, NULL);
#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
#  endif
    return rc;

}


#  ifdef USE_MCMS_STREAMING_AED_CREATE
int32 createAedStream(char *outFile, psX509Cert_t *myCert, psPubKey_t *privKey,
    psX509Cert_t *recipientCert, int32 keyMethod, int32 encryptMethod,
    int32 wrapMethod, int32 keyAgreeScheme, int32 flags,
    unsigned char *content, int32 contentLen, int32 contentType)
{
    cmsAuthEnvelopedData_t *aek;
    unsigned char *outBuf, *masterBuf, *p;
    unsigned char rand[4];
    psPool_t *pool;
    int32 rc, masterId, outBufLen, chunkLen;

    /* Until the Update stream is implemented */
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    pool = psOpenPool("createAedStream", (contentLen * 2) + (1024 * 24),
        0, NULL, NULL);
    if (pool == NULL)
    {
        return PS_MEM_FAIL;
    }
#   else
    pool = NULL;
#   endif
    rc = PS_SUCCESS;

    /* Collecting all the Update output in a single buffer for this test */
    masterBuf = psMalloc(pool, contentLen + 4096);
    masterId = 0;

    if ((rc = matrixCmsInitCreateAuthEnvData(pool, myCert, privKey, recipientCert,
             keyMethod, encryptMethod, wrapMethod, keyAgreeScheme, contentType,
             &outBuf, &outBufLen, flags, &aek)) < 0)
    {
        psFree(masterBuf, pool);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(pool);
#   endif
        return rc;
    }
    Memcpy(masterBuf, outBuf, outBufLen);
    masterId += outBufLen;
    psFree(outBuf, pool);

    p = content;
    while (contentLen > 0)
    {
        psGetEntropy(rand, 4, NULL);
        chunkLen = rand[0] + rand[1] + rand[2];
        if (chunkLen >= contentLen)
        {
            chunkLen = contentLen;
        }

        if (matrixCmsUpdateCreateAuthEnvData(pool, aek, p, chunkLen,
                &outBuf, &outBufLen) < 0)
        {
            psFree(masterBuf, pool);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
            psClosePool(pool);
#   endif
            return PS_MEM_FAIL;
        }
        Memcpy(masterBuf + masterId, outBuf, outBufLen);
        masterId += outBufLen;
        psFree(outBuf, pool);
        contentLen -= chunkLen;
        p += chunkLen;
    }

    rc = matrixCmsFinalCreateAuthEnvData(pool, aek, &outBuf, &outBufLen);
    Memcpy(masterBuf + masterId, outBuf, outBufLen);
    masterId += outBufLen;
    psFree(outBuf, pool);

    writeFile(outFile, masterBuf, masterId);
    psFree(masterBuf, pool);

    matrixCmsFreeStreamCreatedAuthEnvData(aek);

#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
#   endif
    return rc;
}

static int32 runAEDstream(psX509Cert_t *origCert, psPubKey_t *origKey,
    psX509Cert_t *recipCert, psPubKey_t *recipKey, int32 flags,
    unsigned char *messageData, int32 messageDataLen)
{
    int32 rc;
    char *output;

    nextAedStreamFile(&output);
    rc = createAedStream(output, origCert, origKey, recipCert,
        MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES128_CBC_CMAC, MCMS_AES256_WRAP, MCMS_ECKA_X963KDF_SHA256,
        flags, messageData, messageDataLen, CMS_PKCS7_DATA);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseAed(output, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextAedStreamFile(&output);
    rc = createAedStream(output, origCert, origKey, recipCert,
        MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES192_CBC_CMAC, MCMS_AES128_WRAP, MCMS_ECKA_X963KDF_SHA384,
        flags, messageData, messageDataLen, CMS_PKCS7_SIGNED_DATA);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseAed(output, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextAedStreamFile(&output);
    rc = createAedStream(output, origCert, origKey, recipCert,
        MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES256_CBC_CMAC, MCMS_AES192_WRAP, MCMS_ECKA_X963KDF_SHA512,
        flags, messageData, messageDataLen, CMS_PKCS9_AUTH_ENVELOPED_DATA);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseAed(output, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextAedStreamFile(&output);
    rc = createAedStream(output, origCert, origKey, recipCert,
        MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES128_GCM, MCMS_AES192_WRAP, MCMS_ECKA_X963KDF_SHA384,
        flags, messageData, messageDataLen, CMS_PKCS9_COMPRESSED_DATA);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseAed(output, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextAedStreamFile(&output);
    rc = createAedStream(output, origCert, origKey, recipCert,
        MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES192_GCM, MCMS_AES256_WRAP, MCMS_ECKA_X963KDF_SHA256,
        flags, messageData, messageDataLen, CMS_PKCS7_DATA);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseAed(output, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextAedStreamFile(&output);
    rc = createAedStream(output, origCert, origKey, recipCert,
        MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES256_GCM, MCMS_AES128_WRAP, MCMS_ECKA_X963KDF_SHA512,
        flags, messageData, messageDataLen, CMS_PKCS7_SIGNED_DATA);
    if (rc < 0)
    {
        psFree(output, NULL);
        return rc;
    }
    rc = parseAed(output, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(output, NULL);
    if (rc < 0)
    {
        return rc;
    }


    return rc;
}
#  endif

#  ifdef USE_MCMS_ATOMIC_AED_CREATE
int32 createAed(char *outFile, psX509Cert_t *myCert, psPubKey_t *privKey,
    psX509Cert_t *recipientCert, int32 keyMethod, int32 encryptMethod,
    int32 wrapMethod, int32 keyAgreeScheme, int32 flags,
    unsigned char *content, int32 contentLen, int32 contentType)
{
    unsigned char *outBuf;
    psPool_t *pool;
    int32 rc, outBufLen;

#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    /* The additional huge memory overhead here is for ECDSA key generation */
    if (myCert)
    {
        pool = psOpenPool("createAed", (contentLen * 2) + 10240 +
            myCert->binLen + sizeof(psPool_t), 0, NULL, NULL);
    }
    else
    {
        pool = psOpenPool("createAed", (contentLen * 2) + 10240 +
            sizeof(psPool_t), 0, NULL, NULL);
    }
#   else
    pool = NULL;
#   endif

    if ((rc = matrixCmsCreateAuthEnvData(pool, myCert, privKey,
             recipientCert, keyMethod, encryptMethod, wrapMethod, keyAgreeScheme,
             content, contentLen, contentType, &outBuf, &outBufLen, flags)) < 0)
    {
        Printf("matrixCmsCreateAuthEnvData failed %d\n", rc);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
        psClosePool(pool);
#   endif
        return rc;
    }

    writeFile(outFile, outBuf, outBufLen);

    psFree(outBuf, pool);
#   ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
#   endif
    return rc;
}

/* Create a variety of AED with different possible algorithm combinations and
    parse them.         Creation flags were passed in by the caller */
static int32 runAED(psX509Cert_t *origCert, psPubKey_t *origKey,
    psX509Cert_t *recipCert, psPubKey_t *recipKey, int32 flags,
    unsigned char *messageData, int32 messageDataLen)
{
    char *out;
    int32 rc;

    nextAedFile(&out);
    rc = createAed(out, origCert, origKey, recipCert, MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES128_CBC_CMAC, MCMS_AES256_WRAP, MCMS_ECKA_X963KDF_SHA256,
        flags, messageData, messageDataLen, CMS_PKCS7_DATA);
    if (rc < 0)
    {
        psFree(out, NULL);
        return rc;
    }
    rc = parseAed(out, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(out, NULL);
    if (rc < 0)
    {
        return rc;
    }

#   ifndef USE_AESNI_CRYPTO /* Can't do 192 bit keys */
    nextAedFile(&out);
    rc = createAed(out, origCert, origKey, recipCert, MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES192_CBC_CMAC, MCMS_AES128_WRAP, MCMS_ECKA_X963KDF_SHA384,
        flags, messageData, messageDataLen, CMS_PKCS7_SIGNED_DATA);
    if (rc < 0)
    {
        psFree(out, NULL);
        return rc;
    }
    rc = parseAed(out, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(out, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextAedFile(&out);
    rc = createAed(out, origCert, origKey, recipCert, MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES256_CBC_CMAC, MCMS_AES192_WRAP, MCMS_ECKA_X963KDF_SHA512,
        flags, messageData, messageDataLen, CMS_PKCS9_AUTH_ENVELOPED_DATA);
    if (rc < 0)
    {
        psFree(out, NULL);
        return rc;
    }
    rc = parseAed(out, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(out, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextAedFile(&out);
    rc = createAed(out, origCert, origKey, recipCert, MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES128_GCM, MCMS_AES192_WRAP, MCMS_ECKA_X963KDF_SHA384,
        flags, messageData, messageDataLen, CMS_PKCS9_COMPRESSED_DATA);
    if (rc < 0)
    {
        psFree(out, NULL);
        return rc;
    }
    rc = parseAed(out, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(out, NULL);
    if (rc < 0)
    {
        return rc;
    }

    nextAedFile(&out);
    rc = createAed(out, origCert, origKey, recipCert, MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES192_GCM, MCMS_AES256_WRAP, MCMS_ECKA_X963KDF_SHA256,
        flags, messageData, messageDataLen, CMS_PKCS7_SIGNED_DATA);
    if (rc < 0)
    {
        psFree(out, NULL);
        return rc;
    }
    rc = parseAed(out, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(out, NULL);
    if (rc < 0)
    {
        return rc;
    }
#   endif /* AESNI  */

#if !defined(USE_MCMS_STREAMING_AED_PARSE) || !defined(USE_AESNI_CRYPTO)
    nextAedFile(&out);
    rc = createAed(out, origCert, origKey, recipCert, MCMS_AED_KEY_AGREE_METHOD,
        MCMS_AES256_GCM, MCMS_AES128_WRAP, MCMS_ECKA_X963KDF_SHA512,
        flags, messageData, messageDataLen, CMS_PKCS7_SIGNED_DATA);
    if (rc < 0)
    {
        psFree(out, NULL);
        return rc;
    }
    rc = parseAed(out, recipKey, origCert, flags, messageData, messageDataLen);
    psFree(out, NULL);
    if (rc < 0)
    {
        return rc;
    }
#endif

    return 0;
}
#  endif

static int32 authEnvDataTest(int32 keysize)
{
    psX509Cert_t *recipientCert, *myCert;
    psPubKey_t recipientKey, privKey;
    char *origCert, *origKey, *recipCert, *recipKey, *message;
    unsigned char *messageData;
    int32 rc, flags, ncflag;
    psSizeL_t messageDataLen;

    flags = 0;
    origCert = origKey = recipCert = recipKey = message = NULL;
    messageData = NULL;
    recipientCert = myCert = NULL;

    Memset(&recipientKey, 0, sizeof(psPubKey_t));
    Memset(&privKey, 0, sizeof(psPubKey_t));

#  if 0
    if (keysize == 224)
    {
        fullPath(NULL, "EC/brainpool/224_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/brainpool/224_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/brainpool/224_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/brainpool/224_EC_CA_KEY.pem", &recipKey, 0);
    }
    else if (keysize == 256)
    {
        fullPath(NULL, "EC/brainpool/256_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/brainpool/256_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/brainpool/256_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/brainpool/256_EC_CA_KEY.pem", &recipKey, 0);
    }
    else if (keysize == 384)
    {
        fullPath(NULL, "EC/brainpool/384_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/brainpool/384_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/brainpool/384_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/brainpool/384_EC_CA_KEY.pem", &recipKey, 0);
    }
    else if (keysize == 521)
    {
        fullPath(NULL, "EC/brainpool/512_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/brainpool/512_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/brainpool/512_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/brainpool/512_EC_CA_KEY.pem", &recipKey, 0);
    }
    else
    {
        /* no brainpool this size */
        fullPath(NULL, "EC/192_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/192_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/192_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/192_EC_CA_KEY.pem", &recipKey, 0);
    }
#  endif

    if (keysize == 224)
    {
        fullPath(NULL, "EC/224_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/224_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/224_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/224_EC_CA_KEY.pem", &recipKey, 0);
    }
    else if (keysize == 256)
    {
        fullPath(NULL, "EC/256_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/256_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/256_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/256_EC_CA_KEY.pem", &recipKey, 0);
    }
    else if (keysize == 384)
    {
        fullPath(NULL, "EC/384_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/384_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/384_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/384_EC_CA_KEY.pem", &recipKey, 0);
    }
    else if (keysize == 521)
    {
        fullPath(NULL, "EC/521_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/521_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/521_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/521_EC_CA_KEY.pem", &recipKey, 0);
    }
    else
    {
        fullPath(NULL, "EC/192_EC.pem", &origCert, 0);
        fullPath(NULL, "EC/192_EC_KEY.pem", &origKey, 0);

        fullPath(NULL, "EC/192_EC_CA.pem", &recipCert, 0);
        fullPath(NULL, "EC/192_EC_CA_KEY.pem", &recipKey, 0);
    }

    /* fullPath(NULL, "messageLarge.txt", &message, 1); */
    fullPath(NULL, "messageMedium.txt", &message, 1);

    if ((rc = psGetFileBuf(NULL, message, &messageData, &messageDataLen)) < 0)
    {
        Printf("Error getting message from file %d\n", rc);
        goto LBL_ERR;
    }

    if ((rc = psX509ParseCertFile(NULL, recipCert, &recipientCert,
             CERT_STORE_DN_BUFFER)) < 0)
    {
        Printf("Error parsing recipient cert file %d\n", rc);
        goto LBL_ERR;
    }

    if ((rc = psX509ParseCertFile(NULL, origCert, &myCert,
             CERT_STORE_UNPARSED_BUFFER | CERT_STORE_DN_BUFFER)) < 0)
    {
        Printf("Error parsing cert file %d\n", rc);
        goto LBL_ERR;
    }

    if (myCert->pubKeyAlgorithm == OID_RSA_KEY_ALG)
    {
        if ((rc = psPkcs1ParsePrivFile(NULL, origKey, NULL, &privKey.key.rsa))
            < 0)
        {
            Printf("Error parsing key file %d\n", rc);
            goto LBL_ERR;
        }
        privKey.type = PS_RSA;
        privKey.keysize = psRsaSize(&privKey.key.rsa);
    }
    else
    {
        if ((rc = psEccParsePrivFile(NULL, origKey, NULL, &privKey.key.ecc))
            < 0)
        {
            Printf("Error parsing key file %d\n", rc);
            goto LBL_ERR;
        }
        privKey.type = PS_ECC;
        privKey.keysize = psEccSize(&privKey.key.ecc);
    }
    if (recipientCert->pubKeyAlgorithm == OID_RSA_KEY_ALG)
    {
        if ((rc = psPkcs1ParsePrivFile(NULL, recipKey, NULL,
                 &recipientKey.key.rsa)) < 0)
        {
            Printf("Error parsing key file %d\n", rc);
            goto LBL_ERR;
        }
        recipientKey.type = PS_RSA;
        recipientKey.keysize = psRsaSize(&recipientKey.key.rsa);
    }
    else
    {
        if ((rc = psEccParsePrivFile(NULL, recipKey, NULL,
                 &recipientKey.key.ecc)) < 0)
        {
            Printf("Error parsing key file %d\n", rc);
            goto LBL_ERR;
        }
        recipientKey.type = PS_ECC;
        recipientKey.keysize = psEccSize(&recipientKey.key.ecc);
    }

    ncflag = 0; /* one pass with ContentInfo and one without */

TOGGLE_CONTENT_INFO:
    /* This level is grouped by output flags.  The runAED level tests
        some various algorithm combos */
#  ifdef USE_MCMS_ATOMIC_AED_CREATE
    flags = 0 | ncflag;
    if ((rc = runAED(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_INCLUDE_CERT | ncflag;
    if ((rc = runAED(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID | MCMS_FLAGS_AED_INCLUDE_CERT | ncflag;
    if ((rc = runAED(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID | ncflag;
    if ((rc = runAED(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY | MCMS_FLAGS_AED_INCLUDE_CERT | ncflag;
    if ((rc = runAED(myCert, NULL, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY | ncflag;
    if ((rc = runAED(NULL, NULL, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID | ncflag;
    if ((rc = runAED(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID | MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY | ncflag;
    if ((rc = runAED(NULL, NULL, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }
#  endif


#  ifdef USE_MCMS_STREAMING_AED_CREATE
    flags = 0 | ncflag;
    if ((rc = runAEDstream(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_INCLUDE_CERT | ncflag;
    if ((rc = runAEDstream(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID | MCMS_FLAGS_AED_INCLUDE_CERT | ncflag;
    if ((rc = runAEDstream(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID | ncflag;
    if ((rc = runAEDstream(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY | MCMS_FLAGS_AED_INCLUDE_CERT | ncflag;
    if ((rc = runAEDstream(myCert, NULL, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY | ncflag;
    if ((rc = runAEDstream(myCert, NULL, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID | ncflag;
    if ((rc = runAEDstream(myCert, &privKey, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }

    flags = MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID | MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY | ncflag;
    if ((rc = runAEDstream(myCert, NULL, recipientCert, &recipientKey, flags,
             messageData, messageDataLen)) < 0)
    {
        goto LBL_ERR;
    }
#  endif

    if (ncflag == 0)
    {
        ncflag = MCMS_FLAGS_NO_CONTENT_INFO;
        goto TOGGLE_CONTENT_INFO;
    }

LBL_ERR:
    if (messageData)
    {
        psFree(messageData, NULL);
    }
    if (message)
    {
        psFree(message, NULL);
    }
    if (origCert)
    {
        psFree(origCert, NULL);
    }
    if (origKey)
    {
        psFree(origKey, NULL);
    }
    if (recipCert)
    {
        psFree(recipCert, NULL);
    }
    if (recipKey)
    {
        psFree(recipKey, NULL);
    }
    if (recipientCert)
    {
        psX509FreeCert(recipientCert);
    }
    if (myCert)
    {
        psX509FreeCert(myCert);
    }
    psClearPubKey(&recipientKey);
    psClearPubKey(&privKey);
    return rc;
}
# endif /* ANY AED */


#else
# include "osdep_stdio.h"
int main(int argc, char **argv)
{
    Printf("You need to #define MATRIX_USE_FILE_SYSTEM for this test\n");
    return 1;
}
#endif /* MATRIX_USE_FILE_SYSTEM */
