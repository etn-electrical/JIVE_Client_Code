/**
 *      @file    authEnvelopedDataParse.c
 *
 *
 *      Authenticated-Enveloped-Data parse.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/
#include "matrixCmsApi.h"
#include "cryptoImpl.h"

#ifdef USE_CMS

# if defined(USE_MCMS_ATOMIC_AED_PARSE) || defined(USE_MCMS_STREAMING_AED_PARSE)

#  ifdef USE_MCMS_STREAMING_AED_PARSE
int32 matrixCmsInitParseAuthEnvData(psPool_t *pool, unsigned char *buf,
    const uint32 bufLen, cmsEncryptedEnvelope_t **authData,
    unsigned char **remainder, int32 *remainderLen, int32 flags)
{
    cmsEncryptedEnvelope_t *ee;
    const unsigned char *p, *end, *endParams;
    uint32_t overallLen, len, algIdParamsLen;
    uint16_t l16;
    int32 intOut, rc, prc, type;
    int32 fullIndef, contentIndef, aedIndef;

#   ifdef USE_RFC_6476
    int32 oid, paramLen;
#   endif

    if (bufLen == 0)
    {
        return PS_LIMIT_FAIL;
    }
    p = buf;
    end = p + bufLen;

    prc = PS_PARSE_FAIL;
    *authData = NULL;
    ee = NULL;
    *remainder = NULL;
    *remainderLen = 0;

    if (!(flags & MCMS_FLAGS_NO_CONTENT_INFO))
    {
        /* General Syntax content is going to tell us what it is
            ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */

        if ((fullIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1))
            < 0)
        {
            /* The very first length is given special return code if length
                provided is too short */
            if (fullIndef == PS_LIMIT_FAIL)
            {
                return fullIndef;
            }
            psTraceCrypto("Initial parse error for signed data type\n");
            return PS_PARSE_FAIL;
        }

        if ((rc = mcmsParsePkcsOid(&p, (uint32_t) (end - p), &l16)) < 0)
        {
            psTraceCrypto("Error parsing OID for signed data type\n");
            return rc;
        }
        /* len is OID id */
        if (l16 != CMS_PKCS9_AUTH_ENVELOPED_DATA)
        {
            psTraceIntCrypto("Expected auth enveloped type but got %d", l16);
            return PS_PARSE_FAIL;
        }
        if (end - p < 1)
        {
            return PS_LIMIT_FAIL;
        }
        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Expected EXPLICIT content for contentInfo");
            return PS_PARSE_FAIL;
        }
        p++;
        if ((contentIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
        {
            psTraceCrypto("getAsnLength failure in ContenType parse\n");
            return contentIndef;
        }
    }
    else
    {
        fullIndef = contentIndef = 0;
    }

    /* AuthEnvelopedData ::= SEQUENCE {
        version CMSVersion,
        originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
        recipientInfos RecipientInfos,
        authEncryptedContentInfo EncryptedContentInfo,
        authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
        mac MessageAuthenticationCode,
        unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
     */
    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }
    if ((aedIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1)) < 0)
    {
        psTraceCrypto("Initial parse error SignedData\n");
        return aedIndef;
    }
    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }
    /*  CMSVersion ::= INTEGER MUST be 0 */
    if ((rc = getAsnInteger(&p, (uint32_t) (end - p), &intOut)) < 0)
    {
        psTraceCrypto("Error getting version for auth env data\n");
        return rc;
    }
    if (intOut != 0)
    {
        return PS_UNSUPPORTED_FAIL;
    }
    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }

    /* Set up the structure to hold the info we want to persist */
    if ((ee = psMalloc(pool, sizeof(cmsEncryptedEnvelope_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    /* All failures must use goto LBL_ERR after this to free ee */

    Memset(ee, 0, sizeof(cmsEncryptedEnvelope_t));
    ee->pool = pool;
    ee->contentIndef = contentIndef;
    ee->fullIndef = fullIndef;
    ee->aedIndef = aedIndef;

    /* originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
    {
        p++;
        /*      OriginatorInfo ::= SEQUENCE {
                certs [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT RevocationInfoChoices OPTIONAL } */
        if ((rc = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
        {
            psTraceCrypto("Couldn't parse originatorInfo length\n");
            prc = rc;
            goto LBL_ERR;
        }
        if (intOut != 0)
        {
            prc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        if (end - p < 1)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            p++;
            if ((rc = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
            {
                psTraceCrypto("Couldn't parse originatorInfo length\n");
                prc = rc;
                goto LBL_ERR;
            }
            /* X.509 doesn't support stream parse.  Will need the
                entire certificate here before success (or maybe we can hold
                onto the partial memory at this point).  Not going to stream
                parse the entire X.509 format though */
            if ((uint32_t) (end - p) < len)
            {
                prc = PS_LIMIT_FAIL;
                goto LBL_ERR;
            }
            if ((rc = psX509ParseCert(pool, p, len, &ee->originator, 0)) < 0)
            {
                psTraceCrypto("Couldn't parse X.509 certificate\n");
                prc = rc;
                goto LBL_ERR;
            }
            p += rc;
        }

        if (end - p < 1)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
        {
            p++;
            /* FUTURE Skipping CRLS */
            if ((rc = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
            {
                prc = rc;
                psTraceCrypto("Couldn't parse originatorInfo length\n");
                goto LBL_ERR;
            }
            if ((uint32) (end - p) < len)
            {
                prc = PS_LIMIT_FAIL;
                goto LBL_ERR;
            }
            p += len;
        }
    }

    if ((prc = matrixCmsParseRecipientInfos(pool, p, (int32) (end - p), ee)) < 0)
    {
        goto LBL_ERR;
    }
    p += prc;

    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }

    /* In-place streaming version of matrixCmsParseEncryptedContentInfo */
    if ((ee->encIndef = getAsnSequence32(&p, (uint32_t) (end - p),
             &overallLen, 1)) < 0)
    {
        prc = ee->encIndef;
        goto LBL_ERR;
    }
    if ((prc = mcmsParsePkcsOid(&p, (uint32_t) (end - p), &ee->contentType)) < 0)
    {
        goto LBL_ERR;
    }
    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }

    /* ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier */
    if ((prc = getStreamingAsnAlgorithmIdentifier(&p, (int32) (end - p),
             &ee->algId, &l16)) < 0)
    {
        goto LBL_ERR;
    }
    algIdParamsLen = l16;

    if (ee->algId == OID_AES_128_GCM)
    {
        ee->encKeyLen = 16;
        type = MCMS_AES_GCM_TYPE;
    }
    else if (ee->algId == OID_AES_CBC_CMAC_128)
    {
        ee->encKeyLen = 16;
        type = MCMS_AES_CBC_CMAC_TYPE;
    }
    else if (ee->algId == OID_AES_192_GCM)
    {
        ee->encKeyLen = 24;
        type = MCMS_AES_GCM_TYPE;
    }
    else if (ee->algId == OID_AES_CBC_CMAC_192)
    {
        ee->encKeyLen = 24;
        type = MCMS_AES_CBC_CMAC_TYPE;
    }
    else if (ee->algId == OID_AES_256_GCM)
    {
        ee->encKeyLen = 32;
        type = MCMS_AES_GCM_TYPE;
    }
    else if (ee->algId == OID_AES_CBC_CMAC_256)
    {
        ee->encKeyLen = 32;
        type = MCMS_AES_CBC_CMAC_TYPE;
    }
    else
    {
        psAssert(ee->algId == OID_AUTH_ENC_256_SUM);
    }

    /* Extension data on the Algorithm Identifier.  IV info embedded here.
        This could either be a AEAD type (or CMAC) where the single
        algorithm and IV parameter are presented or this could be the
        RFC 6476 authEnc OID where the individual PRF, encryption, and
        authentication algorithms are all presented as parameters. */
    if (ee->algId == OID_AUTH_ENC_256_SUM)
    {
#   ifdef USE_RFC_6476
        if (algIdParamsLen)
        {
            /* Will be reusing algIdParamsLen just as temp var */
            endParams = p + algIdParamsLen;

            /* AuthEncParams ::= SEQUENCE {
                prfAlgorithm   [0] AlgorithmIdentifier DEFAULT PBKDF2,
                encAlgorithm       AlgorithmIdentifier,
                macAlgorithm       AlgorithmIdentifier
                }
             */
            if (getAsnSequence32(&p, (uint32) (endParams - p),
                    &algIdParamsLen, 1) < 0)
            {
                psTraceCrypto("Error getting outer SEQ from authEnc alg\n");
                prc = PS_PARSE_FAIL;
                goto LBL_ERR;
            }
            /* PRF */
            if (getAsnAlgorithmIdentifier(&p, (int32) (endParams - p),
                    &oid, &paramLen) < 0)
            {
                psTraceCrypto("OID err for authEnc PRF\n");
                prc = PS_PARSE_FAIL;
                goto LBL_ERR;
            }
            if (oid != OID_PKCS_PBKDF2)
            {
                psTraceIntCrypto("Unsupported PRF %d\n", oid);
                prc = PS_UNSUPPORTED_FAIL;
                goto LBL_ERR;
            }
            if (mcmsCmpPbkdf2Params(p, paramLen) < 0)
            {
                /* Not going to fail here.  Will try with defaults */
                psTraceCrypto("Unexpected PBKDF2 parameters\n");
            }
            p += paramLen;

            /* encAlg - Overwrite ee->algId since we care about this one */
            if (getAsnAlgorithmIdentifier(&p, (int32) (endParams - p),
                    &ee->algId, &paramLen) < 0)
            {
                psTraceCrypto("OID err for authEnc PRF\n");
                prc = PS_PARSE_FAIL;
                goto LBL_ERR;
            }
            p += paramLen;
            if (ee->algId == OID_AES_128_CBC)
            {
                ee->encKeyLen = 16;
            }
            else if (ee->algId == OID_AES_192_CBC)
            {
                ee->encKeyLen = 24;
            }
            else if (ee->algId == OID_AES_256_CBC)
            {
                ee->encKeyLen = 32;
            }
            else
            {
                psTraceIntCrypto("Unsupported crypto alg %d\n", oid);
                prc = PS_UNSUPPORTED_FAIL;
                goto LBL_ERR;
            }
            /* Should be OCTET_STRING IV here */
            if ((*p++ != ASN_OCTET_STRING) ||
                getAsnLength32(&p, (uint32_t) (endParams - p), &len, 1) < 0 ||
                len != 16)
            {
                psTraceCrypto("Couldn't get crypto IV\n");
                prc = PS_PARSE_FAIL;
                goto LBL_ERR;
            }
            ee->encKeyIvLen = (uint16_t) len;
            Memcpy(ee->encKeyIv, p, 16);
            p += 16;

            /* macAlg */
            if (getAsnAlgorithmIdentifier(&p, (int32) (endParams - p),
                    &oid, &paramLen) < 0)
            {
                psTraceCrypto("OID err for authEnc PRF\n");
                prc = PS_PARSE_FAIL;
                goto LBL_ERR;
            }
            p += paramLen;
            if (oid != OID_AES_CMAC)
            {
                psTraceIntCrypto("Unsupported hash alg %d\n", oid);
                prc = PS_UNSUPPORTED_FAIL;
                goto LBL_ERR;
            }
            ee->authKeyLen = 16;
            /* No IV.  And the key is derived */
        }
        else
        {
            /* No parameters on the authEnc OID doesn't make any sense */
            psTraceCrypto("ERROR:  No parameters to authEnc alg\n");
            prc = PS_PARSE_FAIL;
            goto LBL_ERR;
        }
#   else
        return PS_UNSUPPORTED_FAIL;
#   endif
    }
    else
    {
        if (algIdParamsLen)
        {
            /* The getStreamingAsnAlgorithmIdentifier call will make sure
                all the algorithm parameter data is present but still have
                the streaming tests here to be paranoid */
            /* Will be reusing algIdParamsLen just as temp var */
            endParams = p + algIdParamsLen;
            if (end - p < 1)
            {
                prc = PS_LIMIT_FAIL;
                goto LBL_ERR;
            }

            if ((prc = getAsnSequence32(&p, (uint32_t) (endParams - p),
                     &algIdParamsLen, 1)) < 0)
            {
                goto LBL_ERR;
            }
            if (end - p < 1)
            {
                prc = PS_LIMIT_FAIL;
                goto LBL_ERR;
            }
            if ((*p++ != ASN_OCTET_STRING) ||
                getAsnLength32(&p, (uint32_t) (endParams - p), &len, 1) < 0 ||
                (uint32_t) (endParams - p) < len)
            {
                psTraceCrypto("Error getting IV param from CEK alg\n");
                return PS_PARSE_FAIL;
            }
            psAssert(len < 32); /* Sanity check on IV len */
            ee->encKeyIvLen = (uint16_t) len;
            Memcpy(ee->encKeyIv, p, ee->encKeyIvLen);
            p += ee->encKeyIvLen;
            /* This is OPTIONALLY here */
            if (p != endParams)
            {
                if (getAsnInteger(&p, (uint32) (end - p), &intOut) < 0)
                {
                    psTraceCrypto("Error getting mac len from CEK alg\n");
                    return PS_PARSE_FAIL;
                }
                ee->macLen = intOut;
            }

        }
        else
        {
            /* Empty parameters is apparently possible if encryption alg is
                using an empty IV.  Set that and default the MAC len */
            ee->encKeyIvLen = 16;
            Memset(ee->encKeyIv, 0x0, 16);
            if (type == MCMS_AES_GCM_TYPE)
            {
                ee->macLen = MCMS_GCM_TAG_LEN;
            }
            else
            {
                /* CBC_CMAC */
                ee->macLen = 16;
            }
        }

    }

    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }
    /* encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL

        Could be constructed or primitive */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
    {
        p++;

        if (end - p < 1)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if ((prc = getAsnLength32(&p, (uint32_t) (end - p),
                 &ee->encryptedContentLen, 1)) < 0)
        {
            goto LBL_ERR;
        }
        /* Flag that we are dealing with an indefinate length */
        if (prc == ASN_UNKNOWN_LEN)
        {
            ee->encryptedContentLen = 0;
            ee->indef = 1;
        }
    }
    else if (overallLen && *p == (ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE))
    {
        p++;
        if ((prc = getAsnLength32(&p, (uint32_t) (end - p),
                 &ee->encryptedContentLen, 1)) < 0)
        {
            goto LBL_ERR;
        }
        /* Encrypted content to follow */
    }

    *authData = ee;
    *remainderLen = (uint32_t) (end - p);
    if (*remainderLen > 0)
    {
        *remainder = (unsigned char *) p;
    }

    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        matrixCmsFreeParsedAuthEnvData(ee);
    }
    return prc;

}

/* Need some step between Init and Update to set the key material that will
    decrypt the stream */
int32 matrixCmsPostInitParseAuthEnvData(psPool_t *pool,
    cmsEncryptedEnvelope_t *ee, const psX509Cert_t *originatorCert,
    const psPubKey_t *privKey)
{
    int32 rc;

    if ((rc = matrixCmsConfirmRecipient(pool, ee, originatorCert, privKey))
        < 0)
    {
        psTraceIntCrypto("matrixCmsConfirmRecipient error %d\n", rc);
        return rc;
    }

    /* Derive encryption and authentication keys now */
    if (ee->algId == OID_AES_128_CBC || ee->algId == OID_AES_192_CBC ||
        ee->algId == OID_AES_256_CBC)
    {
        psPkcs5Pbkdf2(ee->unwrappedKey, ee->unwrappedKeyLen,
            (unsigned char *) "encryption", 10, 1, ee->encKey, ee->encKeyLen);
        /* psTraceBytes("parse derived key", ee->encKey, ee->encKeyLen); */
        psPkcs5Pbkdf2(ee->unwrappedKey, ee->unwrappedKeyLen,
            (unsigned char *) "authentication", 14, 1, ee->authKey,
            ee->authKeyLen);
        /* psTraceBytes("parse derived auth", ee->authKey, ee->authKeyLen); */
    }
    else if (ee->algId == OID_AES_CBC_CMAC_128 ||
             ee->algId == OID_AES_CBC_CMAC_192 ||
             ee->algId == OID_AES_CBC_CMAC_256)
    {
        /* By definition CMAC key length is same length as encryption key
            which we already have handy */
        psAssert(ee->unwrappedKeyLen == (ee->encKeyLen * 2));
        ee->authKeyLen = ee->encKeyLen;
        /* Wrapped key material is encryption || mac */
        Memcpy(ee->encKey, ee->unwrappedKey, ee->encKeyLen);
        Memcpy(ee->authKey, ee->unwrappedKey + ee->encKeyLen, ee->authKeyLen);

        psCmacInit(ee->authKey, ee->authKeyLen, &ee->cmacCtx);
        psAesInitCBC(&ee->ctx.aes, ee->encKeyIv, ee->encKey, ee->encKeyLen,
            PS_AES_DECRYPT);

    }
    else if (ee->algId == OID_AES_128_GCM ||
             ee->algId == OID_AES_192_GCM ||
             ee->algId == OID_AES_256_GCM)
    {
        /* The key is just the unwrapped key directly */
        psAssert(ee->unwrappedKeyLen == ee->encKeyLen);
        Memcpy(ee->encKey, ee->unwrappedKey, ee->encKeyLen);

        /* psTraceBytes("INIT GCM WITH KEY", ee->encKey, ee->encKeyLen); */
        /* psTraceBytes("INIT GCM WITH IV", ee->encKeyIv, 12); */
        /* psTraceBytes("INIT GCM WITH ATTRIBS", ee->authAttribs, ee->authAttribsLen); */
        psAesInitGCM(&ee->ctx.aesgcm, ee->encKey, ee->encKeyLen);
        psAesReadyGCM(&ee->ctx.aesgcm, ee->encKeyIv, ee->authAttribs,
            ee->authAttribsLen);
    }
    else
    {
        return PS_UNSUPPORTED_FAIL;
    }

    return PS_SUCCESS;
}


/*
    data is plaintext output.  May be insitu with buf.  If NOT in-situ
    the data MUST be pre-allocated by caller AND be at least bufLen in
    size. dataSize is used to make this clear

    remainder could exist for either a MCMS_PARTIAL return case (data that
        still has yet to be decrypted (should be < blocksize)) or in the
        PS_SUCCESS case (rest of ASN.1 (authAttribs, etc..))
 */
int32 matrixCmsUpdateParseAuthEnvData(psPool_t *pool, unsigned char *buf,
    uint32 bufLen, cmsEncryptedEnvelope_t *ee, unsigned char **data,
    int32 *dataLen, const uint32 dataSize, unsigned char **remainder,
    int32 *remainderLen)
{
    int32 makeblock, decLen, rc, needUnpad;
    const unsigned char *p, *end;
    unsigned char *output;
    int32 count = 0;

    *remainder = NULL;
    *remainderLen = 0;
    *dataLen = 0;

    if (bufLen == 0)
    {
        return MCMS_PARTIAL;
    }
    if (dataSize < bufLen)
    {
        /* We are requiring the caller to tell us how large the outgoing
            plaintext buffer is just to make it clear we are trusting them to
            have allocated enough space to hold the output.  Even checking
            this in insitu case just to be consistent */
        return PS_ARG_FAIL;
    }
    output = *data;
    needUnpad = 0;

CONSTRUCTED_OCTET_PARSE:
    count++;
    if (ee->encryptedContentLen == 0)
    {
        if (ee->indef)
        {
            p = buf;
            end = buf + bufLen;
            /* Always known that one byte will exist to parse */
            if (*p != ASN_OCTET_STRING)
            {
                /* This is management of the final two 0x0 bytes */
                if (*p != 0x0)
                {
                    return PS_PARSE_FAIL;
                }

                /* If we are here with needUnpad then we know we have already
                    been looping through and have the final part so we can
                    unpad */
                if (needUnpad)
                {
                    /* data will never have moved */
                    *dataLen -= (int32) (*data)[*dataLen - 1];
                    /* Still want those final 2 0x0 later so PARTIAL returned */
                    return MCMS_PARTIAL;
                }
                /* There is remainder data but not enough to check for
                    two 0x0 so return LIMIT_FAIL so they have to call us
                    back with more data... including these unparsed bytes */
                if (bufLen < 2)
                {
                    if (count > 1)
                    {
                        /* We've looped through a steam cipher (GCM) already
                            so there is data to return */
                        return MCMS_PARTIAL;
                    }
                    /* Not enough data was passed to complete ASN.1 parsing */
                    return PS_LIMIT_FAIL;
                }
                if (p[0] == 0x0 && p[1] == 0x0)
                {

                    p += 2;
                    *remainder = (unsigned char *) p;
                    *remainderLen = bufLen - 2;
                    return PS_SUCCESS;
                }
                else
                {
                    return PS_PARSE_FAIL;
                }
            }
            p++;
            if ((rc = getAsnLength32(&p, (uint32_t) (end - p),
                     &ee->encryptedContentLen, 0)) < 0)
            {
                if (rc == PS_LIMIT_FAIL)
                {
                    /* Couldn't get through the few bytes of len.  Give it
                        all back as remainder with PARTIAL return */
                    *remainder = buf;
                    *remainderLen = bufLen;
                    return MCMS_PARTIAL;
                }
                return rc;
            }
            /* catch up to where we've parsed */
            psAssert((uint32) (p - buf) <= bufLen);
            bufLen -= (int32) (p - buf);
            buf = (unsigned char *) p;
        }
        else
        {
            return PS_ARG_FAIL; /* Possibly called after this function has
                                   already      returned a PS_SUCCESS error code? */
        }
    }
    *remainderLen = 0; /* Could be leftover from previous component */

    /* Start with max amount to decrypt */
    if (bufLen > ee->encryptedContentLen)
    {
        /* Have all the encrypted data and more */
        decLen = ee->encryptedContentLen;
    }
    else
    {
        decLen = bufLen;
    }

    switch (ee->algId)
    {
    case OID_DES_EDE3_CBC:
    case OID_AES_CBC_CMAC_128:
    case OID_AES_CBC_CMAC_192:
    case OID_AES_CBC_CMAC_256:
        needUnpad = 1;
        /* There isn't enough data to do a single block decode.  Treat like
            normal case with remainder being the unprocessed amount but with
            no "data" to show for it */
        if (bufLen < 16)
        {
            *remainder = buf;
            *remainderLen = bufLen;
            return MCMS_PARTIAL;
        }
        /* Are we at a block boundary for the decrypt */
        makeblock = decLen % 16;
        decLen -= makeblock;
        psAssert((decLen % 16) == 0);
        if (makeblock)
        {
            *remainder = buf + (bufLen - makeblock);
            *remainderLen = makeblock;
        }

    default:;
    }

    psAssert((uint32) decLen <= ee->encryptedContentLen);
    ee->encryptedContentLen -= decLen;

    switch (ee->algId)
    {
    case OID_DES_EDE3_CBC:
        psDes3Decrypt(&ee->ctx.des3, buf, output, decLen);
        *dataLen += decLen;
        if (ee->encryptedContentLen == 0)
        {
            /* Unpad when end-of-data */
            if (ee->indef == 0)
            {
                *dataLen -= (int32) output[*dataLen - 1];
            }
        }

        break;
    case OID_AES_CBC_CMAC_128:
    case OID_AES_CBC_CMAC_192:
    case OID_AES_CBC_CMAC_256:
        psCmacUpdate(&ee->cmacCtx, buf, decLen);
        psAesDecryptCBC(&ee->ctx.aes, buf, output, decLen);
        *dataLen += decLen;

        if (ee->encryptedContentLen == 0)
        {
            /* Unpad when end-of-data */
            if (ee->indef == 0)
            {
                *dataLen -= (int32) output[*dataLen - 1];
            }
        }
        break;

    case OID_AES_128_GCM:
    case OID_AES_192_GCM:
    case OID_AES_256_GCM:
        psAesDecryptGCMtagless(&ee->ctx.aesgcm, buf, output, decLen);
        *dataLen += decLen;
        break;
    default:;      /* would have already caught unsupported above */
    }

    if (ee->encryptedContentLen != 0)
    {
        psAssert(*remainderLen < 16);
        return MCMS_PARTIAL;
    }

    /* Done with decryption.  Any unparsed remainder passed back in 'remainder'
        variables to pass along to Final OR if constructed string deal with
        next expected chunk.  The return code of PS_SUCCESS
        is the indication to move to Final */
    *remainder = buf + decLen;
    *remainderLen = bufLen - decLen;

    if (ee->indef)
    {
        /* Look for trailing 0x0 bytes.  Expecting four of them */
        if (*remainderLen > 1)
        {
            if ((*remainder)[0] == 0x0 && (*remainder)[1] == 0x0)
            {
                /* If we're here we know we are the end of a chunk so two
                    0x0 bytes are truly end of constructed octet string.
                    Can now unpad (if CMAC) move past two bytes and
                    return success */
                if (needUnpad)
                {
                    /* data will never have moved */
                    *dataLen -= (int32) (*data)[*dataLen - 1];
                }
                *remainder += 2;
                *remainderLen -= 2;
                return PS_SUCCESS;
            }
        }
        if (*remainderLen == 0)
        {
            /* needUnpad is just telling us this is as block cipher */
            if (needUnpad)
            {
                /* How could we possibly know if this is the final component
                    of the constructed octet string?  This unlucky case will
                    have to pass back the data still potentially PADDED */
                return MCMS_UNKNOWN;
            }
            return MCMS_PARTIAL;
        }
        /* Finished one component but more remaining */
        output += decLen;
        buf = *remainder;
        bufLen = *remainderLen;
        goto CONSTRUCTED_OCTET_PARSE;
    }
    return PS_SUCCESS;
}

/* */
int32 matrixCmsFinalParseAuthEnvData(psPool_t *pool, unsigned char *buf,
    uint32 bufLen, cmsEncryptedEnvelope_t *ee)
{
    const unsigned char *p, *end;
    unsigned char *attrib, *macString;
    unsigned char tag[16];
    uint32_t len, macStringLen;
    int32 prc;

    p = buf;
    end = p + bufLen;

    prc = PS_LIMIT_FAIL;
    if (end - p < 2)
    {
        return prc;
    }
    /* Check end-of-contents */
    if (ee->encIndef == ASN_UNKNOWN_LEN)
    {
        if (*p++ != 0x0 || *p++ != 0x0)
        {
            return PS_PARSE_FAIL;
        }
    }

    if (end - p < 1)
    {
        return prc;
    }
    /* AuthAttributes */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
    {
        switch (ee->algId)
        {
        case OID_AES_128_GCM:
        case OID_AES_192_GCM:
        case OID_AES_256_GCM:
            /* Can't use stream parsing with GCM if authenticated
                attributes exist */
            psTraceCrypto("ERROR: GCM streaming AED has authAttributes\n");
            return PS_UNSUPPORTED_FAIL;
        default:;
        }
        attrib = (unsigned char *) p;
        p++;
        /* FUTURE: parse if there are things that need looking at */
        if ((prc = getAsnLength32(&p, (uint32_t) (end - p), &len, 0)) < 0)
        {
            return prc;
        }
        /* Skipping */
        if ((uint32_t) (end - p) < len)
        {
            return PS_LIMIT_FAIL;
        }
        p += len;

        ee->authAttribsLen = (int32) (p - attrib);
        if ((ee->authAttribs = psMalloc(pool, ee->authAttribsLen)) == NULL)
        {
            prc = PS_MEM_FAIL;
            goto LBL_ERR;
        }
        Memcpy(ee->authAttribs, attrib, ee->authAttribsLen);
        /* For the purposes of constructing the AAD, the IMPLICIT [1] tag in
            the authAttrs field is not used for the DER encoding: rather a
            universal SET OF tag is used.  That is, the DER encoding of the
            SET OF tag, rather than of the IMPLICIT [1] tag, is to be included
            in the construction for the AAD along with the length and content
            octets of the authAttrs value */
        ee->authAttribs[0] = (ASN_SET | ASN_CONSTRUCTED);
    }

    /* LIMIT_FAILS beyond here might have an allocated ee->authAttribs */
    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }
    /* MAC */
    prc = PS_PARSE_FAIL;

    if (*p == ASN_OCTET_STRING)
    {
        p++;
        if (end - p < 1)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if ((prc = getAsnLength32(&p, (uint32_t) (end - p), &len, 0)) < 0)
        {
            goto LBL_ERR;
        }
        if (len > 32)   /* CMAC 256 max */
        {
            prc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        if ((uint32_t) (end  - p) < len)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        Memcpy(ee->mac, p, len);
        ee->macLen = len;
        p += len;
    }
    else if (*p == (ASN_OCTET_STRING | ASN_CONSTRUCTED))
    {
        p++;
        if ((prc = getAsnConstructedOctetString32(pool, &p, (uint32_t) (end - p),
                 &macString, &macStringLen)) < 0)
        {
            psTraceCrypto("Error parsing constructed string MAC\n");
            goto LBL_ERR;
        }
        if (macStringLen > 32)
        {
            psFree(macString, pool);
            prc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        Memcpy(ee->mac, macString, macStringLen);
        ee->macLen = (uint16_t) macStringLen;
        psFree(macString, pool);
    }
    else
    {
        goto LBL_ERR;
    }

    /* Unpad and test MAC for those ciphers that use them */
    if (ee->macVerified == 0)
    {
        switch (ee->algId)
        {
        case OID_DES_EDE3_CBC:
            break;
        case OID_AES_CBC_CMAC_128:
        case OID_AES_CBC_CMAC_192:
        case OID_AES_CBC_CMAC_256:

            if (ee->authAttribsLen)
            {
                psCmacUpdate(&ee->cmacCtx, ee->authAttribs,
                    ee->authAttribsLen);
            }
            psCmacFinal(&ee->cmacCtx, tag);
            if (Memcmp(tag, ee->mac, ee->macLen) != 0)
            {
                psTraceCrypto("AES_CMAC mismatch!!\n");
                prc = MCMS_AED_KEY_AGREED_BUT_AUTH_FAILED;
                goto LBL_ERR;
            }
            ee->macVerified = 1;
            break;

        case OID_AES_128_GCM:
        case OID_AES_192_GCM:
        case OID_AES_256_GCM:
            psAesGetGCMTag(&ee->ctx.aesgcm, ee->macLen, tag);
            if (Memcmp(tag, ee->mac, ee->macLen) != 0)
            {
                psTraceCrypto("AES_GCM mismatch!!\n");
                prc = MCMS_AED_KEY_AGREED_BUT_AUTH_FAILED;
                goto LBL_ERR;
            }
            ee->macVerified = 1;
            break;
        default:;      /* would have already caught unsupported above */
        }
    }

    /* Check end-of-contents */
    if (ee->aedIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (*p++ != 0x0 || *p++ != 0x0)
        {
            goto LBL_ERR;
        }
    }
    if (ee->contentIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (*p++ != 0x0 || *p++ != 0x0)
        {
            goto LBL_ERR;
        }
    }
    if (ee->fullIndef == ASN_UNKNOWN_LEN)
    {
        if (end - p < 2)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (*p++ != 0x0 || *p++ != 0x0)
        {
            goto LBL_ERR;
        }
    }

    /* should be the end */
    psAssert(p == end);
    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS && prc != MCMS_AED_KEY_AGREED_BUT_AUTH_FAILED)
    {
        if (ee->authAttribs)
        {
            psFree(ee->authAttribs, ee->pool);
            ee->authAttribs = NULL;
        }
    }
    return prc;

}

#  endif /* USE_MCMS_STREAMING_AED_PARSE */


#  ifdef USE_MCMS_ATOMIC_AED_PARSE
/******************************************************************************/
/*
    Primary Signed-Data Content Type parser.  Starts parsing from the
    General Syntax
 */
int32 matrixCmsParseAuthEnvData(psPool_t *pool,
    unsigned char *buf,
    const uint32 bufLen,
    const psX509Cert_t *originatorCert,
    const psPubKey_t *privKey,
    const int32 flags,
    unsigned char **data,
    int32 *dataLen,
    cmsEncryptedEnvelope_t **authData)
{
    cmsEncryptedEnvelope_t *ee;
    const unsigned char *p, *end;
    unsigned char *attrib, *macString;
    uint32_t len, macStringLen;
    uint16_t l16;
    int32 intOut, rc, prc, fullIndef, contentIndef;
    int32 aedIndef;

    p = buf;
    end = p + bufLen;

    prc = PS_PARSE_FAIL;
    ee = *authData = NULL;

    if (privKey == NULL)
    {
        return PS_ARG_FAIL;
    }

    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        fullIndef = contentIndef = 0;
    }
    else
    {
        /* General Syntax content is going to tell us what it is
            ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */

        if ((fullIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1)) < 0)
        {
            /* The very first length is given special return code if length
                provided is too short */
            if (fullIndef == PS_LIMIT_FAIL)
            {
                return MCMS_PARTIAL;
            }
            psTraceCrypto("Initial parse error for signed data type\n");
            return PS_PARSE_FAIL;
        }
        if (mcmsParsePkcsOid(&p, (uint32_t) (end - p), &l16) < 0)
        {
            psTraceCrypto("Error parsing OID for signed data type\n");
            return PS_PARSE_FAIL;
        }
        /* len is OID id */
        if (l16 != CMS_PKCS9_AUTH_ENVELOPED_DATA)
        {
            psTraceIntCrypto("Expected auth enveloped type but got %d", l16);
            return PS_PARSE_FAIL;
        }

        if (end - p < 1)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }

        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Expected EXPLICIT content for contentInfo");
            return PS_PARSE_FAIL;
        }
        p++;
        if ((contentIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("getAsnLength failure in ContenType parse\n");
            return PS_PARSE_FAIL;
        }
    }

    /*
       AuthEnvelopedData ::= SEQUENCE {
        version CMSVersion,
        originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
        recipientInfos RecipientInfos,
        authEncryptedContentInfo EncryptedContentInfo,
        authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
        mac MessageAuthenticationCode,
        unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
     */
    if ((aedIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1)) < 0)
    {
        psTraceCrypto("Initial parse error SignedData\n");
        return PS_PARSE_FAIL;
    }

    /*  CMSVersion ::= INTEGER MUST be 0 */
    if (getAsnInteger(&p, (uint32) (end - p), &intOut) < 0)
    {
        psTraceCrypto("Error getting version for auth env data\n");
        return PS_PARSE_FAIL;
    }
    if (intOut != 0)
    {
        return PS_UNSUPPORTED_FAIL;
    }

    /* Set up the structure to hold the info we want to persist */
    if ((ee = psMalloc(pool, sizeof(cmsEncryptedEnvelope_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(ee, 0, sizeof(cmsEncryptedEnvelope_t));
    ee->pool = pool;

    /* originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
    {
        p++;
        /*      OriginatorInfo ::= SEQUENCE {
                certs [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT RevocationInfoChoices OPTIONAL } */
        if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Couldn't parse originatorInfo length\n");
            goto LBL_ERR;
        }
        if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            uint16_t len16;
            p++;
            if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                (uint32_t) (end - p) < len ||
                len > 0xFFFF)
            {
                psTraceCrypto("Couldn't parse originatorInfo length\n");
                goto LBL_ERR;
            }
            len16 = (uint16_t) len;
            if ((rc = psX509ParseCert(pool, p, len16, &ee->originator,
                     0)) < 0)
            {
                psTraceCrypto("Couldn't parse X.509 certificate\n");
                prc = rc;
                goto LBL_ERR;
            }
            p += rc;
        }
        if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
        {
            p++;
            /* FUTURE Skipping CRLS */
            if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                (uint32_t) (end - p) < len)
            {
                psTraceCrypto("Couldn't parse originatorInfo length\n");
                goto LBL_ERR;
            }
            p += len;
        }
    }

    if ((rc = matrixCmsParseRecipientInfos(pool, p, (int32) (end - p), ee)) < 0)
    {
        prc = rc;
        goto LBL_ERR;
    }
    p += rc;

    /* Extract the key */
    if ((rc = matrixCmsConfirmRecipient(pool, ee, originatorCert, privKey))
        < 0)
    {
        prc = rc;
        goto LBL_ERR;
    }

    if ((rc = matrixCmsParseEncryptedContentInfo(pool, p, (int32) (end - p), ee))
        < 0)
    {
        prc = rc;
        goto LBL_ERR;;
    }
    p += rc;


    /* AuthAttributes */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
    {
        attrib = (unsigned char *) p;
        p++;
        /* FUTURE: parse if there are things that need looking at */
        if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Couldn't parse authAttributes length\n");
            goto LBL_ERR;
        }
        /* Skipping */
        p += len;
        ee->authAttribsLen = (int32) (p - attrib);
        if ((ee->authAttribs = psMalloc(pool, ee->authAttribsLen)) == NULL)
        {
            prc = PS_MEM_FAIL;
            goto LBL_ERR;
        }
        Memcpy(ee->authAttribs, attrib, ee->authAttribsLen);
        /* For the purposes of constructing the AAD, the IMPLICIT [1] tag in
            the authAttrs field is not used for the DER encoding: rather a
            universal SET OF tag is used.  That is, the DER encoding of the
            SET OF tag, rather than of the IMPLICIT [1] tag, is to be included
            in the construction for the AAD along with the length and content
            octets of the authAttrs value */
        ee->authAttribs[0] = (ASN_SET | ASN_CONSTRUCTED);
    }

    /* MAC */
    if (*p == ASN_OCTET_STRING)
    {
        p++;
        if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Error parsing MAC\n");
            goto LBL_ERR;
        }
        if (len > 32)   /* CMAC 256 max */
        {
            prc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        if (ee->macLen > 0)
        {
            /* If it exists, it was included in the parameters of the OID */
            psAssert(ee->macLen == len);
        }
        Memcpy(ee->mac, p, len);
        ee->macLen = (uint16_t) len;
        p += len;
    }
    else if (*p == (ASN_OCTET_STRING | ASN_CONSTRUCTED))
    {
        p++;
        if (getAsnConstructedOctetString32(pool, &p, (uint32_t) (end - p),
                &macString, &macStringLen) < 0)
        {
            psTraceCrypto("Error parsing constructed string MAC\n");
            goto LBL_ERR;
        }
        if (macStringLen > 32)
        {
            psFree(macString, pool);
            prc = PS_UNSUPPORTED_FAIL;
            goto LBL_ERR;
        }
        if (ee->macLen > 0)
        {
            /* If it exists, it was included in the parameters of the OID */
            psAssert(ee->macLen == (int32) macStringLen);
        }
        Memcpy(ee->mac, macString, macStringLen);
        ee->macLen = (uint16_t) macStringLen;
        psFree(macString, pool);
    }
    else
    {
        goto LBL_ERR;
    }


    /* Check end-of-contents */
    if (aedIndef == ASN_UNKNOWN_LEN)
    {
        if (*p++ != 0x0 || *p++ != 0x0)
        {
            goto LBL_ERR;
        }
    }
    if (contentIndef == ASN_UNKNOWN_LEN)
    {
        if (*p++ != 0x0 || *p++ != 0x0)
        {
            goto LBL_ERR;
        }
    }
    if (fullIndef == ASN_UNKNOWN_LEN)
    {
        if (*p++ != 0x0 || *p++ != 0x0)
        {
            goto LBL_ERR;
        }
    }

    /* should be the end */
    psAssert(p == end);

    /* Decrypt */
    if ((prc = matrixCmsDecryptAED(pool, ee, data, dataLen, flags)) < 0)
    {
        goto LBL_ERR;
    }

    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        matrixCmsFreeParsedAuthEnvData(ee);
    }
    else
    {
        *authData = ee;
    }
    return prc;

}

#   ifdef MATRIX_USE_FILE_SYSTEM
/* NOT USED */
int32 matrixCmsParseAuthEnvDataFile(psPool_t *pool, char *file,
    cmsEncryptedEnvelope_t **authData)
{

    /* Currently this function is unsupported. */
    return PS_UNSUPPORTED_FAIL;

#if 0
    unsigned char *sdBuf, *DERout;
    unsigned char *start, *end;
    psSizeL_t sdBufLen;
    psRes_t rc;
    psSize_t BASElen, DERlen;

    if (file == NULL)
    {
        psTraceCrypto("No fileName to matrixCmsParseAuthEnvelopedDataFile\n");
        return PS_ARG_FAIL;
    }
    if ((rc = psGetFileBuf(pool, file, &sdBuf, &sdBufLen)) < PS_SUCCESS)
    {
        return rc;
    }
    start = end = NULL;

    BASElen = sdBufLen;
    start = sdBuf;
    end = start + sdBufLen;


    /* Base64 decode */
    DERout = psMalloc(pool, BASElen);
    if (DERout == NULL)
    {
        psFree(sdBuf, pool);
        psError("Mem alloc error in matrixCmsParseAuthEnvelopedDataFile\n");
        return PS_MEM_FAIL;
    }
    DERlen = BASElen;
    if ((rc = psBase64decode((unsigned char *) start, BASElen, DERout,
             &DERlen)) != 0)
    {
        psTraceCrypto("Error base64 decode of auth env data file\n");
        psFree(DERout, pool);
        psFree(sdBuf, pool);
        return rc;
    }
    psFree(sdBuf, pool);

#    if 0
    if ((rc = matrixCmsParseAuthEnvData(pool, DERout, DERlen,
             authData)) < 0)
    {
        psFree(DERout, pool);
        return rc;
    }
#    endif
    psFree(DERout, pool);

    return 0;
#endif
}
#   endif /* FILE_SYSTEM */
#  endif  /* USE_MCMS_ATOMIC_AED_PARSE */
# endif   /* ATOMIC or STREAMING */
#endif    /* USE_CMS */
