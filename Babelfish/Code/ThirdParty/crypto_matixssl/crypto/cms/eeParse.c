/**
 *      @file    eeParse.c
 *
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/
#include "matrixCmsApi.h"
#include "cryptoImpl.h"

#ifdef USE_CMS

# ifdef USE_MCMS_ENVELOPED_DATA_PARSE
int32 matrixCmsParseEnvelopedDataFile(psPool_t *pool, char *file,
    cmsEncryptedEnvelope_t **ee)
{
    unsigned char *sdBuf, *DERout;
    unsigned char *start, *end;
    psSizeL_t sdBufLen;
    psRes_t rc;
    uint32 BASElen, DERlen;

    rc = PS_SUCCESS;
    if (file == NULL)
    {
        psTraceCrypto("No file sent to matrixCmsParseEnvelopedDataFile\n");
        return PS_ARG_FAIL;
    }
    if ((rc = psGetFileBuf(pool, file, &sdBuf, &sdBufLen)) < PS_SUCCESS)
    {
        return rc;
    }
    start = end = NULL;

    /* FUTURE: if S/MIME parse all the plaintext stuff at the start */
    BASElen = sdBufLen;
    start = sdBuf;
    end = start + sdBufLen;


    /* Base64 decode */
    DERout = psMalloc(pool, BASElen);
    if (DERout == NULL)
    {
        psFree(sdBuf);
        psError("Mem alloc error in matrixCmsParseEnvelopedDataFile\n");
        return PS_MEM_FAIL;
    }
    DERlen = BASElen;
    if ((rc = psBase64decode((unsigned char *) start, BASElen, DERout,
             &DERlen)) != 0)
    {
        psTraceCrypto("Error base64 decode of encrypted envelope file\n");
        psFree(DERout);
        psFree(sdBuf);
        return rc;
    }
    psFree(sdBuf);

    rc = matrixCmsParseEnvelopedDataBuf(pool, DERout, DERlen, ee);

    psFree(DERout);

    return rc;
}

int32 matrixCmsParseEnvelopedDataBuf(psPool_t *pool, unsigned char *sdBuf,
    uint32 sdBufLen, cmsEncryptedEnvelope_t **retee)
{
    cmsEncryptedEnvelope_t *ee;
    unsigned char *p, *end;
    uint32_t len;
    int32 intOut, rc, prc;

    p = sdBuf;
    end = p + sdBufLen;

    prc = PS_PARSE_FAIL;
    *retee = NULL;
    /* General Syntax content is going to tell us what it is
        ContentInfo ::= SEQUENCE {
            contentType ContentType,
            content [0] EXPLICIT ANY DEFINED BY contentType }

        ContentType ::= OBJECT IDENTIFIER */

    if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 1) < 0)
    {
        psTraceCrypto("Initial parse error for encrypted envelope type\n");
        return PS_PARSE_FAIL;
    }
    if (mcmsParsePkcsOid(&p, (uint32) (end - p), &intOut) < 0)
    {
        psTraceCrypto("Error parsing OID for encrypted envelope type\n");
        return PS_PARSE_FAIL;
    }
    /* intOut is OID id */
    if (intOut != CMS_PKCS7_ENVELOPED_DATA)
    {
        psTraceIntCrypto("Expected enveloped data type but got %d", intOut);
        return PS_PARSE_FAIL;
    }

    if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
    {
        psTraceCrypto("Expected EXPLICIT content for contentInfo");
        return PS_PARSE_FAIL;
    }
    p++;
    if (getAsnLength32(&p, (uint32_t) (end - p), &len, 1) < 0 ||
        (uint32_t) (end - p) < len)
    {
        psTraceCrypto("getAsnLength failure in ContenType parse\n");
        return PS_PARSE_FAIL;
    }

    /* OK, we've passed the General Syntax

        EnvelopedData ::= SEQUENCE {
            version CMSVersion,
            originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
            recipientInfos RecipientInfos,
            encryptedContentInfo EncryptedContentInfo,
            unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }

        OriginatorInfo ::= SEQUENCE {
            certs [0] IMPLICIT CertificateSet OPTIONAL,
            crls [1] IMPLICIT RevocationInfoChoices OPTIONAL }

        RecipientInfos ::= SET SIZE (1..MAX) OF RecipientInfo

        EncryptedContentInfo ::= SEQUENCE {
            contentType ContentType,
            contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
            encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }

        EncryptedContent ::= OCTET STRING

        UnprotectedAttributes ::= SET SIZE (1..MAX) OF Attribute
     */
    if (getAsnSequence32(&p, (uint32) (end - p), &len, 1) < 0)
    {
        psTraceCrypto("Initial parse error SignedData\n");
        return PS_PARSE_FAIL;
    }

    /* Set up the structure to hold the info we want to persist */
    if ((ee = psMalloc(pool, sizeof(cmsEncryptedEnvelope_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(ee, 0, sizeof(cmsEncryptedEnvelope_t));
    ee->pool = pool;

    /*  CMSVersion ::= INTEGER { v0(0), v1(1), v2(2), v3(3), v4(4), v5(5) }

       IF (originatorInfo is present) AND
            ((any certificates with a type of other are present) OR
            (any crls with a type of other are present))
         THEN version is 4
         ELSE
            IF ((originatorInfo is present) AND
               (any version 2 attribute certificates are present)) OR
               (any RecipientInfo structures include pwri) OR
               (any RecipientInfo structures include ori)
            THEN version is 3
            ELSE
               IF (originatorInfo is absent) AND
                  (unprotectedAttrs is absent) AND
                  (all RecipientInfo structures are version 0)
               THEN version is 0
               ELSE version is 2 */
    if (getAsnInteger(&p, (uint32) (end - p), &ee->version) < 0)
    {
        psTraceCrypto("Error getting version for enveloped data\n");
        goto LBL_ERR;
    }

    /* originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
    {
        p++;
        if (getAsnLength32(&p, (uint32_t) (end - p), &len, 1) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Couldn't parse originatorInfo length\n");
            goto LBL_ERR;
        }
        /* Skipping */
        p += len;
    }

    /* RecipientInfos ::= SET SIZE (1..MAX) OF RecipientInfo */
    if ((rc = matrixCmsParseRecipientInfos(pool, p, (int32) (end - p), ee)) < 0)
    {
        prc = rc;
        goto LBL_ERR;;
    }
    p += rc;

    /*  EncryptedContentInfo ::= SEQUENCE {
        contentType ContentType,
        contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
        encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL } */
    if ((rc = matrixCmsParseEncryptedContentInfo(pool, p, (int32) (end - p), ee))
        < 0)
    {
        prc = rc;
        goto LBL_ERR;;
    }
    p += rc;

    /* unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
    {
        p++;
        psTraceCrypto("TODO: unprotectedAttrs parse unsupported in Envelope\n");
        if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Initial parse error unprotectedAttrs\n");
            return PS_FAILURE;
        }
        /* Skipping */
        p += len;
    }

    /* should be the end */
    psAssert(p == end); /* Expect if you saw "Danger: ASN indefinite length" */
    *retee = ee;
    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        matrixCmsFreeParsedAuthEnvData(ee);
    }
    return prc;

}
# endif /* USE_MCMS_ENVELOPED_DATA_PARSE */


# ifdef NEED_MCMS_ENCRYPTED_ENVELOPE_PARSE
/******************************************************************************/
/* RecipientInfos ::= SET SIZE (1..MAX) OF RecipientInfo */
int32 matrixCmsParseRecipientInfos(psPool_t *pool, const unsigned char *buf,
    uint32 bufLen, cmsEncryptedEnvelope_t *ee)
{
    cmsRecipientInfos_t *recipient = NULL, *next;
    const unsigned char *p, *end, *overallLenPtr, *sanityStart;
    int32 choice, rc;
    psSize_t paramLen;
    uint32_t len, pubKeyLen, overallSetLen;

    p = buf;
    end = p + bufLen;
    overallSetLen = 0;


    /* The stream parsing at this level is simple... don't parse until we
        have this entire set length. */
    if ((rc = getAsnSet32(&p, (uint32_t) (end - p), &overallSetLen, 1)) < 0)
    {
        psTraceCrypto("Initial parse error for RecipientInfos\n");
        return rc;
    }

    /*
        RecipientInfo ::= CHOICE {
            ktri KeyTransRecipientInfo,
            kari [1] KeyAgreeRecipientInfo,
            kekri [2] KEKRecipientInfo,
            pwri [3] PasswordRecipientinfo,
            ori [4] OtherRecipientInfo }

        EncryptedKey ::= OCTET STRING
     */
    while (overallSetLen > 0)
    {
        overallLenPtr = p;

        if (ee->recipients == NULL)
        {
            if ((recipient = psMalloc(pool, sizeof(cmsRecipientInfos_t))) == NULL)
            {
                return PS_MEM_FAIL;
            }
            Memset(recipient, 0, sizeof(cmsRecipientInfos_t));
            recipient->pool = pool;
            ee->recipients = recipient;
        }
        else
        {
            if ((next = psMalloc(pool, sizeof(cmsRecipientInfos_t))) == NULL)
            {
                return PS_MEM_FAIL;
            }
            Memset(next, 0, sizeof(cmsRecipientInfos_t));
            next->pool = pool;
            recipient->next = next;
            recipient = recipient->next;
        }
        /* We're cheating a little bit here by parsing the SEQUENCE and version
            without looking at the RecipientInfo CHOICE but each of the
            supported options follows with an integer version which helps
            identify itself anyway.

            FUTURE: If the OtherRecipientInfo type is ever supported we'd
            have to move to an OID parse next instead of the INTEGER */
        choice = -1;
        if (*p >> 4 == 0xA)
        {
            choice = *p ^ 0xA0;
            p++;
            if ((rc = getAsnLength32(&p, (uint32_t) (end - p), &len, 0)) < 0 ||
                (uint32_t) (end - p) < len)
            {
                return rc;
            }
        }
        else
        {
            if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 1) < 0)
            {
                psTraceCrypto("Initial parse error for RecipientInfo\n");
                return PS_PARSE_FAIL;
            }
        }
        if ((rc = getAsnInteger(&p, (uint32) (end - p), &recipient->version))
            < 0)
        {
            psTraceCrypto("Error getting version for RecipientInfo\n");
            return rc;
        }
        /* We will always be past the CMSVersion going into these options */
        if (recipient->version == 0 || recipient->version == 2)
        {
            /*  KeyTransRecipientInfo ::= SEQUENCE {
                    version CMSVersion,  -- always set to 0 or 2
                    rid RecipientIdentifier,
                    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                    encryptedKey EncryptedKey }

                RecipientIdentifier ::= CHOICE {
                    issuerAndSerialNumber IssuerAndSerialNumber,
                    subjectKeyIdentifier [0] SubjectKeyIdentifier } */
            if (recipient->version == 0)
            {
                /*
                    IssuerAndSerialNumber ::= SEQUENCE {
                    issuer Name,
                    serialNumber CertificateSerialNumber } */
                if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 1) < 0)
                {
                    psTraceCrypto("Initial parse error KeyTransRecipientInfo\n");
                    return PS_PARSE_FAIL;
                }
                Memset(&recipient->recipientDn, 0, sizeof(x509DNattributes_t));
                if (psX509GetDNAttributes(pool, &p, (uint32) (end - p),
                        &recipient->recipientDn, 0) < 0)
                {
                    psTraceCrypto("Couldn't parse issuer DN attributes\n");
                    return PS_PARSE_FAIL;
                }
                if (getSerialNum(pool, &p, (uint32) (end - p),
                        &recipient->recipientSn, &recipient->recipientSnLen)
                    < 0)
                {
                    psTraceCrypto("IssuerAndSerialNumber serNum parse error\n");
                    return PS_PARSE_FAIL;
                }
            }
            else
            {
                psTraceCrypto("TODO: subjectKeyIdentifier recipient method\n");
                return PS_UNSUPPORTED_FAIL;
                /*      Snippet from extension parse in x509.c to get started
                    if (*p++ != ASN_OCTET_STRING || getAsnLength32(&p,
                        (int32)(end - p), &len, 0)) < 0 ||
                        (uint32)(end - p) < len) {
                    psTraceCrypto("Error parsing subjectKeyId extension\n");
                    return PS_PARSE_FAIL;
                   } */
            }

            /* KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier */
            if (getAsnAlgorithmIdentifier(&p, (int32) (end - p),
                    &recipient->keyEncryptAlgId, &paramLen) < 0)
            {
                psTraceCrypto("OID err for KeyEncryptionAlgorithmIdentifier\n");
                return PS_PARSE_FAIL;
            }
            p += paramLen;
            /* Do we support this digest? */
            if (recipient->keyEncryptAlgId != OID_RSA_KEY_ALG &&
                recipient->keyEncryptAlgId != OID_ECDSA_KEY_ALG)
            {
                psTraceCrypto("Unsupported KeyEncryptionAlgorithmIdentifier\n");
                return PS_UNSUPPORTED_FAIL;
            }

            /* EncryptedKey ::= OCTET STRING */
            if ((*p++ != ASN_OCTET_STRING) ||
                getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                (uint32_t) (end - p) < len)
            {
                psTraceCrypto("Error getting EncryptedKey\n");
                return PS_PARSE_FAIL;
            }
            recipient->eKey = psMalloc(pool, len);
            Memcpy(recipient->eKey, p, len);
            recipient->eKeyLen = len;
            p += len;

        }
        else if (recipient->version == 3)
        {
            psAssert(choice == 1);
            /*  KeyAgreeRecipientInfo ::= SEQUENCE {
                    version CMSVersion,  -- always set to 3
                    originator [0] EXPLICIT OriginatorIdentifierOrKey,
                    ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
                    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                    recipientEncryptedKeys RecipientEncryptedKeys }

                OriginatorIdentifierOrKey ::= CHOICE {
                    issuerAndSerialNumber IssuerAndSerialNumber,
                    subjectKeyIdentifier [0] SubjectKeyIdentifier,
                    originatorKey [1] OriginatorPublicKey }

                OriginatorPublicKey ::= SEQUENCE {
                    algorithm AlgorithmIdentifier,
                    publicKey BIT STRING }

                RecipientEncryptedKeys ::= SEQUENCE OF RecipientEncryptedKey

                RecipientEncryptedKey ::= SEQUENCE {
                    rid KeyAgreeRecipientIdentifier,
                    encryptedKey EncryptedKey }

                KeyAgreeRecipientIdentifier ::= CHOICE {
                    issuerAndSerialNumber IssuerAndSerialNumber,
                    rKeyId [0] IMPLICIT RecipientKeyIdentifier }

                RecipientKeyIdentifier ::= SEQUENCE {
                    subjectKeyIdentifier SubjectKeyIdentifier,
                    date GeneralizedTime OPTIONAL,
                    other OtherKeyAttribute OPTIONAL }

               SubjectKeyIdentifier ::= OCTET STRING */

            /* picking up at originator */
            if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
            {
                psTraceCrypto("Expected originator for key agreement\n");
            }
            p++;
            if ((rc = getAsnLength32(&p, (uint32_t) (end - p), &len, 0)) < 0 ||
                (uint32_t) (end - p) < len)
            {
                return rc;
            }
            choice = -1;
            if (*p >> 4 == 0xA)
            {
                choice = *p ^ 0xA0;
                p++;
                if ((rc = getAsnLength32(&p, (uint32_t) (end - p), &len, 0)) < 0 ||
                    (uint32_t) (end - p) < len)
                {
                    return rc;
                }
            }
            else if (*p >> 4 == 0x8)
            {
                choice = *p ^ 0x80;
                p++;
                if ((rc = getAsnLength32(&p, (uint32_t) (end - p), &len, 0)) < 0 ||
                    (uint32_t) (end - p) < len)
                {
                    return rc;
                }
            }
            else
            {
                /* issuerAndSerialNumber IssuerAndSerialNumber, */
                recipient->originatorId = MCMS_ORIGIN_ID_ISSUERDN;
                if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 1) < 0)
                {
                    psTraceCrypto("Initial parse error KeyTransRecipientInfo\n");
                    return PS_PARSE_FAIL;
                }
                Memset(&recipient->originatorDn, 0, sizeof(x509DNattributes_t));
                if (psX509GetDNAttributes(pool, &p, (uint32) (end - p),
                        &recipient->originatorDn, 0) < 0)
                {
                    psTraceCrypto("Couldn't parse issuer DN attributes\n");
                    return PS_PARSE_FAIL;
                }
                if (getSerialNum(pool, &p, (uint32) (end - p),
                        &recipient->originatorSn, &recipient->originatorSnLen)
                    < 0)
                {
                    psTraceCrypto("IssuerAndSerialNumber serNum parse error\n");
                    return PS_PARSE_FAIL;
                }
            }
            /* If wasn't isserAndSerialNum default, choice should be set */
            if (choice == 0)
            {
                /* SubjectKeyIdentifier */
                recipient->originatorId = MCMS_ORIGIN_ID_KEYID;
                if ((recipient->originatorSn = psMalloc(pool, len)) == NULL)
                {
                    return PS_MEM_FAIL;
                }
                Memcpy(recipient->originatorSn, p, len);
                recipient->originatorSnLen = len;
                p += len;
            }
            else if (choice == 1)
            {
                /*
                    originatorKey [1] OriginatorPublicKey
                    OriginatorPublicKey ::= SEQUENCE {
                        algorithm AlgorithmIdentifier,
                        publicKey BIT STRING }

                    NOTE: quirk of no SEQUENCE if not default choice */
                recipient->originatorId = MCMS_ORIGIN_ID_RAWPUB;
                if (getAsnAlgorithmIdentifier(&p, (int32) (end - p),
                        &recipient->originatorPubKeyAlg, &paramLen) < 0)
                {
                    psTraceCrypto("OID err for OriginatorPublicKey\n");
                    return PS_PARSE_FAIL;
                }
                p += paramLen;

                if (*p++ != ASN_BIT_STRING ||
                    getAsnLength32(&p, (uint32_t) (end - p), &pubKeyLen, 0) < 0 ||
                    (uint32_t) (end - p) < pubKeyLen)
                {
                    return PS_PARSE_FAIL;
                }
                if (*p++ != 0)
                {
                    psTraceCrypto("Expected 0 ignore bits in publicKey\n");
                    return PS_UNSUPPORTED_FAIL;
                }
                pubKeyLen--; /* "ignore bits" byte read */

                /*      This is the parsing of the      ECC public key in which
                    algorithms that Matrix does not support are being used.

                    It starts here with the init of the key structure
                    and continues with the reading of the pubic key point and
                    on to the keyEncryptionAlgorithm */
                if (recipient->originatorPubKeyAlg == OID_ECDSA_KEY_ALG)
                {
                    psEccInitKey(pool, &recipient->originatorPubKey.key.ecc,
                        NULL);
                    /* RFC 3278 section 3.1.1 -
                        The originatorKey publicKey field MUST
                        contain the DER-encoding of a value of the ASN.1 type
                        ECPoint, which represents the sending agent's ephemeral
                        EC public key. */
                    if (psEccX963ImportKey(pool, p, pubKeyLen,
                            &recipient->originatorPubKey.key.ecc, NULL) < 0)
                    {
                        return PS_PARSE_FAIL;
                    }
                    recipient->originatorPubKey.type = PS_ECC;
                    p += pubKeyLen;
                }
                else
                {
                    psTraceCrypto("Unsupported OriginatorPublicKey\n");
                    return PS_UNSUPPORTED_FAIL;
                }
            }
            /* ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL, */
            if (*p == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))
            {
                p++;
                if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                    (uint32_t) (end - p) < len)
                {
                    psTraceCrypto("Error parsing UserKeyingMaterial\n");
                    return PS_PARSE_FAIL;
                }
                if ((*p++ != ASN_OCTET_STRING) || getAsnLength32(&p,
                        (uint32_t) (end - p), &len, 0) < 0 ||
                    (uint32_t) (end - p) < len)
                {
                    psTraceCrypto("Error parsing UserKeyingMaterial\n");
                    return PS_PARSE_FAIL;
                }
                recipient->userKeyingMaterial = psMalloc(pool, len);
                Memcpy(recipient->userKeyingMaterial, p, len);
                recipient->userKeyingMaterialLen = len;
                p += len;
            }

            /* keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier, */
            if (getAsnAlgorithmIdentifier(&p, (int32) (end - p),
                    &recipient->keyEncryptAlgId, &paramLen) < 0)
            {
                psTraceCrypto("OID err for KeyEncryptionAlgorithmIdentifier\n");
                return PS_PARSE_FAIL;
            }
            /* keyEncryptionAlgorithm MUST contain the dhSinglePass-stdDH-
               sha1kdf-scheme object identifier (see Section 8.1) if standard
               ECDH primitive is used, or the dhSinglePass-cofactorDH-sha1kdf-
               scheme object identifier (see Section 8.1) if the cofactor ECDH
               primitive is used.  The parameters field contains
               KeyWrapAlgorithm.  The KeyWrapAlgorithm is the algorithm
               identifier that indicates the symmetric encryption algorithm used
               to encrypt the content-encryption key (CEK) with the key-
               encryption key (KEK). */
            psAssert(paramLen > 0);
            if (getAsnAlgorithmIdentifier(&p, (int32) (end - p),
                    &recipient->keyWrapAlgId, &paramLen) < 0)
            {
                psTraceCrypto("OID err for KeyEncryptionAlgorithmIdentifier\n");
                return PS_PARSE_FAIL;
            }

            /* RecipientEncryptedKeys ::= SEQUENCE OF RecipientEncryptedKey */
            if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 1) < 0)
            {
                psTraceCrypto("Initial parse error RecipientEncryptedKeys\n");
                return PS_PARSE_FAIL;
            }

            /* RecipientEncryptedKey ::= SEQUENCE {
                    rid KeyAgreeRecipientIdentifier,
                    encryptedKey EncryptedKey } */
            if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 1) < 0)
            {
                psTraceCrypto("Initial parse error RecipientEncryptedKey\n");
                return PS_PARSE_FAIL;
            }
            /* KeyAgreeRecipientIdentifier ::= CHOICE {
                    issuerAndSerialNumber IssuerAndSerialNumber,
                    rKeyId [0] IMPLICIT RecipientKeyIdentifier } */
            if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED ))
            {
                uint32_t l32;
                p++;
                if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                    (uint32_t) (end - p) < len)
                {
                    return PS_PARSE_FAIL;
                }
                sanityStart = p;
                recipient->recipientId = MCMS_ORIGIN_ID_KEYID;
                /* RecipientKeyIdentifier ::= SEQUENCE {
                    subjectKeyIdentifier SubjectKeyIdentifier,
                    date GeneralizedTime OPTIONAL,
                    other OtherKeyAttribute OPTIONAL } */
                if (*p++ != ASN_OCTET_STRING || getAsnLength32(&p,
                        (uint32_t) (end - p), &l32, 0) < 0 ||
                    (uint32_t) (end - p) < l32 ||
                    l32 > 0xFFFF)
                {
                    psTraceCrypto("Error parsing subjectKeyId extension\n");
                    return PS_PARSE_FAIL;
                }
                recipient->recipientSnLen = (uint16_t) l32;
                if ((recipient->recipientSn =
                         psMalloc(pool, recipient->recipientSnLen)) == NULL)
                {
                    return PS_MEM_FAIL;
                }
                Memcpy(recipient->recipientSn, p, recipient->recipientSnLen);
                p += recipient->recipientSnLen;
                len -= (p - sanityStart);
                if (len > 0)
                {
                    p += len; /* skipping optional parameters */
                }
            }
            else
            {
                /* issuerAndSerialNumber IssuerAndSerialNumber, */
                recipient->recipientId = MCMS_ORIGIN_ID_ISSUERDN;
                if (getAsnSequence32(&p, (uint32_t) (end - p), &len, 0) < 0)
                {
                    psTraceCrypto("Initial parse error KeyTransRecipientInfo\n");
                    return PS_PARSE_FAIL;
                }
                Memset(&recipient->recipientDn, 0, sizeof(x509DNattributes_t));
                if (psX509GetDNAttributes(pool, &p, (uint32) (end - p),
                        &recipient->recipientDn, 0) < 0)
                {
                    psTraceCrypto("Couldn't parse issuer DN attributes\n");
                    return PS_PARSE_FAIL;
                }
                if (getSerialNum(pool, &p, (uint32) (end - p),
                        &recipient->recipientSn, &recipient->recipientSnLen)
                    < 0)
                {
                    psTraceCrypto("IssuerAndSerialNumber serNum parse error\n");
                    return PS_PARSE_FAIL;
                }
            }

            /* EncryptedKey ::= OCTET STRING */
            if (*p == ASN_OCTET_STRING)
            {
                p++;
                if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                    (uint32_t) (end - p) < len)
                {
                    psTraceCrypto("Coudn't parse EncryptedKey\n");
                    return PS_PARSE_FAIL;
                }
                recipient->eKey = psMalloc(pool, len);
                Memcpy(recipient->eKey, p, len);
                recipient->eKeyLen = len;
                p += len;
            }
            else if (*p == (ASN_OCTET_STRING | ASN_CONSTRUCTED))
            {
                uint32_t l32;
                p++;
                if (getAsnConstructedOctetString32(pool, &p, (uint32_t) (end - p),
                        &recipient->eKey, &l32) < 0)
                {
                    psTraceCrypto("Couldn't parse EncryptedKey\n");
                    return PS_PARSE_FAIL;
                }
                if (l32 > 0xFFFF)
                {
                    psTraceCrypto("EncryptedKey too large\n");
                    return PS_PARSE_FAIL;
                }
                recipient->eKeyLen = (uint16_t) l32;
            }
            else
            {
                return PS_PARSE_FAIL;
            }
        }
        else
        {
            /* FUTURE: other RecipientInfo types */
            return PS_UNSUPPORTED_FAIL;
        }

        /* SET */
        overallSetLen -= (int32) (p - overallLenPtr);
    }

    return (int32) (p - buf);
}


/*      EncryptedContentInfo ::= SEQUENCE {
        contentType ContentType,
        contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
        encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL } */
int32 matrixCmsParseEncryptedContentInfo(psPool_t *pool,
    const unsigned char *buf, uint32 bufLen, cmsEncryptedEnvelope_t *ee)
{
    const unsigned char *p, *end, *endParams;
    unsigned char *constructedTmp;
    int32 encIndef, type = 0;
    psSize_t algIdParamsLen;
    uint32_t overallLen, l32;

#  ifdef USE_RFC_6476
    int32 paramLen, oid;
#  endif

    p = buf;
    end = p + bufLen;

    if ((encIndef = getAsnSequence32(&p, (uint32_t) (end - p), &overallLen, 1)) < 0)
    {
        psTraceCrypto("Initial parse error for EncryptedContent\n");
        return PS_PARSE_FAIL;
    }
    if (mcmsParsePkcsOid(&p, (uint32) (end - p), &ee->contentType) < 0)
    {
        psTraceCrypto("Couldn't get contentType for EncryptedContent\n");
        return PS_UNSUPPORTED_FAIL;
    }

    algIdParamsLen = 0; /* clear for downcast */
    /* ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier */
    if (getAsnAlgorithmIdentifier(&p, (uint32_t) (end - p),  &ee->algId,
            &algIdParamsLen) < 0)
    {
        psTraceCrypto("OID err for KeyEncryptionAlgorithmIdentifier\n");
        return PS_PARSE_FAIL;
    }

    if (ee->algId == OID_AES_128_GCM)
    {
        ee->encKeyLen = 16;
        type = MCMS_AES_GCM_TYPE;
    }
    else if (ee->algId == OID_AES_CBC_CMAC_128)
    {
        ee->encKeyLen = 16;
        type = MCMS_AES_CBC_CMAC_TYPE;
    }
    else if (ee->algId == OID_AES_192_GCM)
    {
        ee->encKeyLen = 24;
        type = MCMS_AES_GCM_TYPE;
    }
    else if (ee->algId == OID_AES_CBC_CMAC_192)
    {
        ee->encKeyLen = 24;
        type = MCMS_AES_CBC_CMAC_TYPE;
    }
    else if (ee->algId == OID_AES_256_GCM)
    {
        ee->encKeyLen = 32;
        type = MCMS_AES_GCM_TYPE;
    }
    else if (ee->algId == OID_AES_CBC_CMAC_256)
    {
        ee->encKeyLen = 32;
        type = MCMS_AES_CBC_CMAC_TYPE;
    }
    else
    {
        psAssert(ee->algId == OID_AUTH_ENC_256_SUM);
    }

    /* Extension data on the Algorithm Identifier.  IV info embedded here.
        This could either be a AEAD type (or CMAC) where the single
        algorithm and IV parameter are presented or this could be the
        RFC 6476 authEnc OID where the individual PRF, encryption, and
        authentication algorithms are all presented as parameters. */
    if (ee->algId == OID_AUTH_ENC_256_SUM)
    {
#  ifdef USE_RFC_6476
        if (algIdParamsLen)
        {
            /* Will be reusing algIdParamsLen just as temp var */
            endParams = p + algIdParamsLen;

            /* AuthEncParams ::= SEQUENCE {
                prfAlgorithm   [0] AlgorithmIdentifier DEFAULT PBKDF2,
                encAlgorithm       AlgorithmIdentifier,
                macAlgorithm       AlgorithmIdentifier
                }
             */
            if (getAsnSequence32(&p, (uint32_t) (endParams - p), &l32, 1) < 0 ||
                l32 > 0xFFFF)
            {
                psTraceCrypto("Error getting outer SEQ from authEnc alg\n");
                return PS_PARSE_FAIL;
            }
            algIdParamsLen = (uint16_t) l32;
            /* PRF */
            if (getAsnAlgorithmIdentifier(&p, (int32) (endParams - p),
                    &oid, &paramLen) < 0)
            {
                psTraceCrypto("OID err for authEnc PRF\n");
                return PS_PARSE_FAIL;
            }
            if (oid != OID_PKCS_PBKDF2)
            {
                psTraceIntCrypto("Unsupported PRF %d\n", oid);
                return PS_UNSUPPORTED_FAIL;
            }
            if (mcmsCmpPbkdf2Params(p, paramLen) < 0)
            {
                /* Not going to fail here.  Will try with defaults */
                psTraceCrypto("Unexpected PBKDF2 parameters\n");
            }
            p += paramLen;

            /* encAlg - Overwrite ee->algId since we care about this one */
            if (getAsnAlgorithmIdentifier(&p, (int32) (endParams - p),
                    &ee->algId, &paramLen) < 0)
            {
                psTraceCrypto("OID err for authEnc PRF\n");
                return PS_PARSE_FAIL;
            }
            p += paramLen;
            if (ee->algId == OID_AES_128_CBC)
            {
                ee->encKeyLen = 16;
            }
            else if (ee->algId == OID_AES_192_CBC)
            {
                ee->encKeyLen = 24;
            }
            else if (ee->algId == OID_AES_256_CBC)
            {
                ee->encKeyLen = 32;
            }
            else
            {
                psTraceIntCrypto("Unsupported crypto alg %d\n", oid);
                return PS_UNSUPPORTED_FAIL;
            }
            /* Should be OCTET_STRING IV here */
            if ((*p++ != ASN_OCTET_STRING) || getAsnLength32(&p,
                    (uint32_t) (endParams - p), &l32, 0) < 0)
            {
                psTraceCrypto("Couldn't get crypto IV\n");
                return PS_FAILURE;
            }
            psAssert(l32 == 16); /* AES IV len */
            ee->encKeyIvLen == (uint16_t) l32;
            Memcpy(ee->encKeyIv, p, 16);
            p += 16;

            /* macAlg */
            if (getAsnAlgorithmIdentifier(&p, (int32) (endParams - p),
                    &oid, &paramLen) < 0)
            {
                psTraceCrypto("OID err for authEnc PRF\n");
                return PS_PARSE_FAIL;
            }
            p += paramLen;
            if (oid != OID_AES_CMAC)
            {
                psTraceIntCrypto("Unsupported hash alg %d\n", oid);
                return PS_UNSUPPORTED_FAIL;
            }
            ee->authKeyLen = 16;
            /* No IV.  And the key is derived */
        }
        else
        {
            /* No parameters on the authEnc OID doesn't make any sense */
            psTraceCrypto("ERROR:  No parameters to authEnc alg\n");
            return PS_PARSE_FAIL;
        }
#  else
        return PS_UNSUPPORTED_FAIL;
#  endif
    }
    else
    {
        if (algIdParamsLen)
        {
            /* Will be reusing algIdParamsLen just as temp var */
            endParams = p + algIdParamsLen;

            algIdParamsLen = 0; /* reset for downcast just in case */
            if (getAsnSequence32(&p, (uint32_t) (endParams - p), &l32, 1) < 0 ||
                l32 > 0xFFFF)
            {
                psTraceCrypto("Error getting IV param from CEK alg\n");
                return PS_PARSE_FAIL;
            }
            algIdParamsLen = (uint16_t) l32;

            if (*p == ASN_OCTET_STRING)
            {
                p++;
                if (getAsnLength32(&p, (uint32_t) (endParams - p), &l32, 0) < 0 ||
                    (uint32_t) (endParams - p) < l32 ||
                    l32 > 16)
                {
                    psTraceCrypto("Error getting IV param from CEK alg\n");
                    return PS_PARSE_FAIL;
                }
                ee->encKeyIvLen = l32;
                Memcpy(ee->encKeyIv, p, ee->encKeyIvLen);
                p += ee->encKeyIvLen;
            }
            else if (*p == (ASN_OCTET_STRING | ASN_CONSTRUCTED))
            {
                uint32_t t32;
                p++;
                if (getAsnConstructedOctetString32(pool, &p,
                        (uint32_t) (endParams - p), &constructedTmp,
                        &t32) < 0)
                {
                    psTraceCrypto("Error getting IV param from CEK alg\n");
                    return PS_PARSE_FAIL;
                }
                if (t32 > 16)
                {
                    psFree(constructedTmp, pool);
                    return PS_LIMIT_FAIL;
                }
                ee->encKeyIvLen = (uint16_t) t32;
                Memcpy(ee->encKeyIv, constructedTmp, ee->encKeyIvLen);
                psFree(constructedTmp, pool);
            }
            else
            {
                psTraceCrypto("Error getting IV param from CEK alg\n");
                return PS_PARSE_FAIL;
            }

            /* This is OPTIONALLY here */
            if (p != endParams)
            {
                if (getAsnInteger(&p, (uint32) (end - p),
                        &type) < 0 || type < 0 || type > 0xFFFF)
                {
                    psTraceCrypto("Error getting mac len from CEK alg\n");
                    return PS_PARSE_FAIL;
                }
                ee->macLen = (uint16_t) type;
            }

        }
        else
        {
            /* Empty parameters is apparently possible if encryption alg is
                using an empty IV.  Set that and default the MAC len */
            ee->encKeyIvLen = 16;
            Memset(ee->encKeyIv, 0x0, 16);
            if (type == MCMS_AES_GCM_TYPE)
            {
                ee->macLen = MCMS_GCM_TAG_LEN;
            }
            else
            {
                /* CBC_CMAC */
                ee->macLen = 16;
            }
        }

    }

    /* encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL

        Seen several variations here.

        For definate lengths sometimes this will be a straight PRIMITIVE
        with an implied OCTET_STRING ("else if" case below)     that we parse
        directly and sometimes it will be a CONSTRUCTED type with the
        OCTET_STRING wrapper (the "if" case immediately below and then the
        test for a sole ASN_OCTET_STRING within there).  Not completely sure
        which is technically correct but I think it's the PRIMITIVE one since
        the underlying type really is an implied primitive. */
    if (*p == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
    {
        p++;

        if (getAsnConstructedOctetString32(pool, &p, (uint32_t) (end - p),
                &ee->encryptedContent, &ee->encryptedContentLen) < 0)
        {
            return PS_PARSE_FAIL;
        }
        /* This parse will always allocate the ee->encryptedContent
            pointer because the encrypted component parts are packed
            together before the one large decryption.  Need to mark that
            fact for the free */
        ee->encryptedContentAllocated = 1;
    }
    else if (overallLen && *p == (ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE))
    {
        p++;
        if (getAsnLength32(&p, (uint32_t) (end - p), &ee->encryptedContentLen, 0) < 0 ||
            (uint32_t) (end - p) < ee->encryptedContentLen)
        {
            return PS_PARSE_FAIL;
        }
        /* No reason to copy the data.  Just save aside the pointer */
        ee->encryptedContent = (unsigned char *) p;
        p += ee->encryptedContentLen;
    }

    /* Check end-of-contents */
    if (encIndef == ASN_UNKNOWN_LEN)
    {
        if (*p++ != 0x0 || *p++ != 0x0)
        {
            return PS_PARSE_FAIL;
        }
    }
    return (int32) (p - buf);
}

static void matrixCmsFreeRecipientInfos(cmsRecipientInfos_t *recipients)
{
    cmsRecipientInfos_t *prev, *recipient = recipients;
    psEccKey_t *eccKey;

    while (recipient)
    {
        if (recipient->recipientSnLen)
        {
            if (recipient->recipientSn)
            {
                psFree(recipient->recipientSn,
                    recipient->pool);
            }
            psX509FreeDNStruct(&recipient->recipientDn, recipient->pool);
        }
        if (recipient->originatorSnLen)
        {
            if (recipient->originatorSn)
            {
                psFree(recipient->originatorSn,
                    recipient->pool);
            }
            psX509FreeDNStruct(&recipient->originatorDn, recipient->pool);
        }
        if (recipient->eKey)
        {
            psFree(recipient->eKey, recipient->pool);
        }
        if (recipient->userKeyingMaterial)
        {
            psFree(recipient->userKeyingMaterial, recipient->pool);
        }
        if (recipient->originatorPubKey.type == PS_ECC)
        {
            eccKey = &recipient->originatorPubKey.key.ecc;
            psEccClearKey(eccKey);
        }
        prev = recipient;
        recipient = recipient->next;
        psFree(prev, prev->pool);
    }

}

void matrixCmsFreeParsedAuthEnvData(cmsEncryptedEnvelope_t *ee)
{
    if (ee == NULL)
    {
        return;
    }
    matrixCmsFreeRecipientInfos(ee->recipients);
    if (ee->encryptedContentAllocated)
    {
        if (ee->encryptedContent)
        {
            psFree(ee->encryptedContent, ee->pool);
            ee->encryptedContent = NULL;
        }
    }
    if (ee->authAttribs)
    {
        psFree(ee->authAttribs, ee->pool);
    }
    if (ee->originator)
    {
        psX509FreeCert(ee->originator);
    }
    psFree(ee, ee->pool);
}

# endif /* NEED_MCMS_ENCRYPTED_ENVELOPE_PARSE */
#endif  /* USE_CMS */
