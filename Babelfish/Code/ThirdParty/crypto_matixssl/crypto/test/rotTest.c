/**
 *      @file    rotTest.c
 *
 *
 *      Crypto-level tests specific to RoT integration.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "crypto/cryptoImpl.h"

# if defined(USE_ROT_CRYPTO) && defined(USE_ROT_ECC)

#include "../../crypto-rot/rot/include/api_val.h"
#include "../../crypto-rot/rotCommon.h"

#include "testkeys/EC/256_EC_KEY.h"
#include "testkeys/EC/384_EC_KEY.h"
#include "testkeys/EC/521_EC_KEY.h"

#include "testkeys/RSA/2048_RSA_KEY.h"
#include "testkeys/RSA/3072_RSA_KEY.h"

#include "psUtil.h"
#include "osdep_stdio.h"
#include "osdep_string.h"

/* Allow FAIL_IF() just like in cl's tests. */
#define INTSTR2(x) #x
#define INTSTR(x) INTSTR2(x)
#define FAIL_IF(x)                                       \
    do                                                   \
    {                                                    \
        if (x)                                           \
        {                                                \
            _psTraceStr("  FAILED (condition=%s)\n",     \
                        #x" [line="INTSTR(__LINE__)"]"); \
            return -1;                                   \
        }                                                \
    } while(0)

#define fail_if(cond, msg, arg)                            \
    do                                                     \
    {                                                      \
        if (cond)                                          \
        {                                                  \
            _psTraceStr("  FAILED (condition=%s)\n",       \
                    #msg" [line="INTSTR(__LINE__)"]");     \
            _psTraceInt("%d\n", arg);                      \
            return -1;                                     \
        }                                                  \
                    } while (0)

#define GOTO_FAIL_IF(x, lbl)                             \
    do                                                   \
    {                                                    \
        if (x)                                           \
        {                                                \
            _psTraceStr("  FAILED (condition=%s)\n",     \
                        #x" [line="INTSTR(__LINE__)"]"); \
            goto lbl;                                    \
        }                                                \
    } while(0)

static int num_fails;
static int num_tests;

# ifdef ABORT_ON_FIRST_FAIL
static int g_abort_on_first_fail = 1;
# else
static int g_abort_on_first_fail;
# endif

#define TO_STRING_INNER(x) #x
#define TO_STRING(x) TO_STRING_INNER(x)

psBool_t testEnabled(int argc, char **argv, const char *name)
{
    int i;

    if (argc == 1)
    {
        /* Enable all tests if no list is given on cmd line. */
        return PS_TRUE;
    }

    for (i = 0; i < argc; i++)
    {
        if (argv[i] != NULL && !Strcmp(argv[i], name))
        {
            argv[i] = NULL;
            return PS_TRUE;
        }
    }

    return PS_FALSE;
}

#define TEST(name)                                  \
    do                                              \
    {                                               \
        psRes_t rc;                                 \
                                                    \
        if (testEnabled(argc, argv, #name))         \
        {                                           \
            printf("%s...\n", #name);               \
            rc = name();                            \
            if (rc == PS_SUCCESS)                   \
            {                                       \
                printf("  %s: SUCCESS\n", #name);   \
            }                                       \
            else                                    \
            {                                       \
                printf ("  %s: FAILED\n", #name);   \
                num_fails++;                        \
                if (g_abort_on_first_fail)          \
                {                                   \
                    psCryptoClose();                \
                    exit(EXIT_FAILURE);             \
                }                                   \
            }                                       \
            num_tests++;                            \
        }                                           \
    }                                               \
    while(0)

unsigned char ecc_256_pub[] =
{
    0x30, 0x59, /* SEQ. len = 89. */
    0x30, 0x13, /* SEQ. len = 19 */
          0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01,
          0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07,
          0x03, 0x42, 0x00,
    0x04, 0x5f, 0xad, 0x62, 0x02, 0x42, 0x48, 0xba, 0xfb, 0xe2,
    0x88, 0xd8, 0x7f, 0xb9, 0x72, 0xcb, 0x28, 0xae, 0xc3, 0x8a, 0x1e, 0xc3,
    0x0e, 0x9c, 0x7d, 0x7a, 0xa4, 0xb5, 0x7f, 0xda, 0xbd, 0x46, 0x5a, 0xb9,
    0x95, 0x39, 0xe0, 0x44, 0x51, 0x71, 0xba, 0xe3, 0xb3, 0x40, 0xf2, 0x54,
    0xfd, 0x23, 0x84, 0xb2, 0xea, 0x2a, 0x84, 0xa3, 0x4f, 0xd7, 0xb0, 0x08,
    0xba, 0x6e, 0x80, 0xc3, 0xeb, 0xdf, 0x2f
};
unsigned char ecc_256_pub_inner[] =
{
    0x04, 0x5f, 0xad, 0x62, 0x02, 0x42, 0x48, 0xba, 0xfb, 0xe2,
    0x88, 0xd8, 0x7f, 0xb9, 0x72, 0xcb, 0x28, 0xae, 0xc3, 0x8a, 0x1e, 0xc3,
    0x0e, 0x9c, 0x7d, 0x7a, 0xa4, 0xb5, 0x7f, 0xda, 0xbd, 0x46, 0x5a, 0xb9,
    0x95, 0x39, 0xe0, 0x44, 0x51, 0x71, 0xba, 0xe3, 0xb3, 0x40, 0xf2, 0x54,
    0xfd, 0x23, 0x84, 0xb2, 0xea, 0x2a, 0x84, 0xa3, 0x4f, 0xd7, 0xb0, 0x08,
    0xba, 0x6e, 0x80, 0xc3, 0xeb, 0xdf, 0x2f
};
unsigned char ecc_256_pub_x[] =
{
    0x5f, 0xad, 0x62, 0x02, 0x42, 0x48, 0xba, 0xfb, 0xe2, 0x88, 0xd8, 0x7f,
    0xb9, 0x72, 0xcb, 0x28, 0xae, 0xc3, 0x8a, 0x1e, 0xc3, 0x0e, 0x9c, 0x7d,
    0x7a, 0xa4, 0xb5, 0x7f, 0xda, 0xbd, 0x46, 0x5a
};
unsigned char ecc_256_pub_y[] =
{
    0xb9, 0x95, 0x39, 0xe0, 0x44, 0x51, 0x71, 0xba, 0xe3, 0xb3, 0x40, 0xf2,
    0x54, 0xfd, 0x23, 0x84, 0xb2, 0xea, 0x2a, 0x84, 0xa3, 0x4f, 0xd7, 0xb0,
    0x08, 0xba, 0x6e, 0x80, 0xc3, 0xeb, 0xdf, 0x2f
};

unsigned char ecc_384_pub[] =
{
    0x30, 0x76,
    0x30, 0x10,
          0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01,
          0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x22,
          0x03, 0x62, 0x00,
    0x04,
    0x4b, 0x01, 0x73, 0xc0, 0x92, 0xb5, 0x50, 0xaa, 0x7f, 0x00, 0x21, 0xde,
    0x6e, 0x70, 0x1b, 0x97, 0x70, 0x71, 0xfc, 0x94, 0x93, 0x7b, 0x5f, 0x09,
    0x78, 0x57, 0x6b, 0x43, 0x55, 0x43, 0x19, 0x21, 0x10, 0x92, 0x79, 0x57,
    0xcb, 0x44, 0x29, 0x50, 0xdf, 0xc9, 0x72, 0x04, 0xda, 0xc0, 0x43, 0x37,
    0xe5, 0xcd, 0x08, 0x6c, 0x98, 0xed, 0xfb, 0x95, 0x71, 0xf8, 0xa5, 0x88,
    0xb7, 0x12, 0x27, 0x51, 0xb8, 0x10, 0x7b, 0x14, 0xfd, 0x29, 0x23, 0xe8,
    0x45, 0x10, 0x3f, 0x81, 0x84, 0xf8, 0xf6, 0xa7, 0xc8, 0x2a, 0x6b, 0xa8,
    0x2f, 0x8b, 0x9e, 0x29, 0x6e, 0xfc, 0x15, 0xf1, 0x23, 0xe5, 0x23, 0x4b
};

unsigned char ecc_384_pub_inner[] =
{
    0x04,
    0x4b, 0x01, 0x73, 0xc0, 0x92, 0xb5, 0x50, 0xaa, 0x7f, 0x00, 0x21, 0xde,
    0x6e, 0x70, 0x1b, 0x97, 0x70, 0x71, 0xfc, 0x94, 0x93, 0x7b, 0x5f, 0x09,
    0x78, 0x57, 0x6b, 0x43, 0x55, 0x43, 0x19, 0x21, 0x10, 0x92, 0x79, 0x57,
    0xcb, 0x44, 0x29, 0x50, 0xdf, 0xc9, 0x72, 0x04, 0xda, 0xc0, 0x43, 0x37,
    0xe5, 0xcd, 0x08, 0x6c, 0x98, 0xed, 0xfb, 0x95, 0x71, 0xf8, 0xa5, 0x88,
    0xb7, 0x12, 0x27, 0x51, 0xb8, 0x10, 0x7b, 0x14, 0xfd, 0x29, 0x23, 0xe8,
    0x45, 0x10, 0x3f, 0x81, 0x84, 0xf8, 0xf6, 0xa7, 0xc8, 0x2a, 0x6b, 0xa8,
    0x2f, 0x8b, 0x9e, 0x29, 0x6e, 0xfc, 0x15, 0xf1, 0x23, 0xe5, 0x23, 0x4b
};

psRes_t rotVersion(void)
{
    ValStatus_t st;
    char versionString[4096];
    ValSize_t versionStringLen = sizeof(versionString);
    psRes_t rc;

    st = val_SystemGetVersion(
            (ValOctetsOut_t *)versionString,
            &versionStringLen);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("valSystemGetVersion", st);
        goto out_fail;
    }
    printf("RoT version: %s\n", versionString);

    rc = PS_SUCCESS;

out_fail:
    return rc;
}

psRes_t rotState(void)
{
    ValStatus_t st;
    uint8_t OtpErrorCode = 0;
    uint16_t OtpErrorLocation = 0;
    uint8_t Mode = 0;
    uint8_t ErrorTest = 0;
    uint8_t CryptoOfficer = 0;
    uint8_t HostID = 0;
    uint8_t NonSecure = 0;
    uint32_t Identity = 0;
    psRes_t rc;

    st = val_SystemGetState(
            &OtpErrorCode,
            &OtpErrorLocation,
            &Mode,
            &ErrorTest,
            &CryptoOfficer,
            &HostID,
            &NonSecure,
            &Identity);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_SystemGetState", st);
        goto out_fail;
    }

    printf("OTP State     : %u (%u)\n", OtpErrorCode, OtpErrorLocation);
    printf("Mode          : %u (0x%02X)\n", Mode, ErrorTest);
    printf("CryptoOfficer : %sAvailable\n", CryptoOfficer ? "" : "NOT ");
    printf("HostID        : %u\n", HostID);
    printf("Secure        : %s\n", NonSecure ? "No" : "Yes ");
    printf("Identity      : 0x%X\n", Identity);

    rc = PS_SUCCESS;
out_fail:
    return rc;
}

psRes_t rotConfigTrng(void)
{
    ValStatus_t st;

    /* Same default values as in da_val_specials.c */
    st = val_TrngConfig(0, 3072, 1, 2, 1);
    FAIL_IF(st != VAL_SUCCESS);

    return PS_SUCCESS;
}

psRes_t rotLoadEcCurve(void)
{
    int rc;
    ValAssetId_t DomainAssetId;

    rc = psRotLoadCurve(IANA_SECP256R1, &DomainAssetId);
    FAIL_IF(rc != PS_SUCCESS);

    return PS_SUCCESS;
}

psRes_t ecdsaTest(uint16_t curveId,
        const unsigned char *tbs,
        psSizeL_t tbsLen,
        unsigned char *validSig,
        psSizeL_t validSigLen,
        const unsigned char *keyData,
        psSize_t keyDataLen,
        int32_t sigAlg)
{
    const psEccCurve_t *curve;
    psPubKey_t key;
    unsigned char *sig;
    psSize_t sigLen;
    psBool_t verifyResult;
    psRes_t rc = PS_FAILURE;

    rc = getEccParamById(curveId, &curve);
    FAIL_IF(rc != PS_SUCCESS);

    key.key.ecc.rotKeyType = ps_ecc_key_type_ecdsa;
    key.key.ecc.rotSigAlg = sigAlg;
    rc = psEccParsePrivKey(
            NULL,
            keyData,
            keyDataLen,
            &key.key.ecc,
            curve);
    FAIL_IF(rc != PS_SUCCESS);
    key.type = PS_ECC;

    /* Verify a known valid signature for tbs. */
    rc = psVerifySig(
            NULL,
            tbs,
            tbsLen,
            validSig,
            validSigLen,
            &key,
            sigAlg,
            &verifyResult,
            NULL);
    if (rc != PS_SUCCESS || verifyResult != PS_TRUE)
    {
        printf("Failed to verify a known valid sig\n");
        goto out_fail;
    }

    rc = psSign(
            NULL,
            &key,
            sigAlg,
            tbs,
            tbsLen,
            &sig,
            &sigLen,
            NULL);
    if (rc != PS_SUCCESS)
    {
        goto out_fail_no_sig;
    }

    /* Verify the signature we produced. */
    rc = psVerifySig(
            NULL,
            tbs,
            tbsLen,
            sig,
            sigLen,
            &key,
            sigAlg,
            &verifyResult,
            NULL);
    if (rc != PS_SUCCESS || verifyResult != PS_TRUE)
    {
        printf("Failed to self-verify a sig\n");
        goto out_fail;
    }

    /* Now try to corrupt the sig and ensure that verification fails. */
    sig[8]++;

    rc = psVerifySig(
            NULL,
            tbs,
            tbsLen,
            sig,
            sigLen,
            &key,
            sigAlg,
            &verifyResult,
            NULL);
    if (verifyResult == PS_TRUE)
    {
        printf("Verified a corrupted sig\n");
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    psFree(sig, NULL);

out_fail_no_sig:
    psEccClearKey(&key.key.ecc);

    return rc;
}

static unsigned char tbs[] = { 'a', 'b', 'c', 'd' };
static psSizeL_t tbsLen = sizeof(tbs);

/*
      echo -n "abcd" \
      |openssl dgst -binary -sha256 \
      |openssl pkeyutl -sign \
      -inkey testkeys/EC/256_EC_KEY.pem \
      -pkeyopt digest:sha256 \
      |xxd -i
*/
static unsigned char sig_p256[] =
{
    0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xb1, 0x74, 0xf0, 0x77, 0x89, 0xf6,
    0x42, 0xad, 0x57, 0x38, 0x31, 0xdb, 0xeb, 0x79, 0xa0, 0x97, 0x59, 0x68,
    0x52, 0xbf, 0x38, 0x82, 0x29, 0x51, 0x61, 0x1c, 0xc4, 0x15, 0x24, 0x7b,
    0x15, 0x02, 0x20, 0x1e, 0x78, 0xb0, 0xd6, 0x96, 0x61, 0x5a, 0x60, 0x7b,
    0x25, 0x1d, 0x79, 0x92, 0x24, 0xfd, 0x50, 0x64, 0x39, 0xc8, 0x87, 0x7c,
    0x8d, 0xef, 0xbe, 0xd5, 0x15, 0xca, 0x96, 0xdc, 0x69, 0x38, 0x46
};

static unsigned char sig_p384[] =
{
    0x30, 0x66, 0x02, 0x31, 0x00, 0x8a, 0x49, 0x63, 0xb2, 0x55, 0xd2, 0x4f,
    0xba, 0xdf, 0xdd, 0xc9, 0xa0, 0xdc, 0xc5, 0x19, 0x9d, 0x2d, 0x86, 0xfd,
    0x8e, 0x6e, 0xd9, 0xf7, 0xf4, 0xfc, 0x1e, 0x66, 0x91, 0x9e, 0x62, 0x89,
    0x89, 0x55, 0xad, 0x17, 0x44, 0x0e, 0xda, 0x7c, 0x12, 0x0f, 0x52, 0x58,
    0xab, 0xb6, 0xe7, 0x0f, 0xdb, 0x02, 0x31, 0x00, 0xee, 0xbb, 0x1c, 0xaf,
    0xd0, 0x08, 0xe3, 0x20, 0x69, 0x54, 0x7f, 0x2d, 0x98, 0x77, 0xb9, 0x32,
    0x24, 0xd9, 0xe1, 0x78, 0xdc, 0x34, 0xf2, 0x4d, 0xa2, 0x47, 0x36, 0x74,
    0x98, 0x69, 0x45, 0xa5, 0x21, 0x65, 0xa7, 0xff, 0x32, 0xbd, 0x86, 0xf8,
    0x75, 0xf1, 0xe6, 0xe6, 0xfc, 0xec, 0x41, 0xdf
};

static unsigned char sig_p521[] =
{
    0x30, 0x81, 0x87, 0x02, 0x41, 0x01, 0xbb, 0x4c, 0xc6, 0xd3, 0x02, 0x32,
    0x68, 0xdf, 0x19, 0x5d, 0x36, 0xb1, 0xe6, 0x05, 0x43, 0x8e, 0x5a, 0x20,
    0x64, 0xe0, 0xe8, 0x56, 0x33, 0x13, 0x80, 0x64, 0x8f, 0xc2, 0xef, 0xa4,
    0x07, 0xd6, 0x67, 0xb5, 0x6c, 0x1a, 0xb2, 0x5a, 0xe4, 0x0c, 0x14, 0xb8,
    0x4b, 0x72, 0xe5, 0x3b, 0x47, 0xa0, 0x16, 0x14, 0x37, 0x41, 0xc8, 0x05,
    0xfd, 0x62, 0xee, 0x4a, 0x13, 0xc0, 0xe6, 0x93, 0x83, 0x75, 0x02, 0x42,
    0x01, 0x5e, 0x6b, 0xa0, 0xc9, 0xee, 0xc5, 0x0e, 0xc7, 0x24, 0x7e, 0xa9,
    0xa6, 0x49, 0xdd, 0x07, 0x32, 0x46, 0x1e, 0x8b, 0xa5, 0x53, 0x0b, 0x9e,
    0x63, 0xb8, 0x99, 0x6f, 0x01, 0xc2, 0xfb, 0x93, 0x02, 0xb4, 0x81, 0xc0,
    0xec, 0xdc, 0x92, 0x4a, 0x65, 0xb2, 0x60, 0x90, 0x36, 0x87, 0x13, 0x5d,
    0xf3, 0x83, 0x53, 0x33, 0xd8, 0x90, 0x6d, 0xfa, 0xfd, 0x5b, 0xeb, 0x3a,
    0x1f, 0xac, 0xae, 0x90, 0x49, 0x0e
};

static unsigned char sig_p521_b[] =
{
    0x30, 0x81, 0x88, 0x02, 0x42, 0x01, 0x9f, 0x3f, 0xc7, 0x45, 0xee, 0xad,
    0xf6, 0xe7, 0x01, 0x5d, 0xf1, 0x9c, 0x08, 0xdb, 0x21, 0x53, 0x31, 0x71,
    0x93, 0xf5, 0x6c, 0x79, 0xba, 0xd1, 0x92, 0x10, 0x8c, 0x70, 0xc8, 0x88,
    0x10, 0x84, 0xe6, 0xaa, 0x64, 0x32, 0xb9, 0x86, 0xc8, 0x9f, 0xc8, 0xfb,
    0xcb, 0x49, 0xe3, 0x5b, 0x5b, 0x07, 0x64, 0x68, 0x02, 0xa2, 0x7c, 0x5f,
    0xe0, 0x17, 0xa4, 0x2d, 0x94, 0x6a, 0xf2, 0xf3, 0x3b, 0x64, 0xf9, 0x02,
    0x42, 0x00, 0xf5, 0x8c, 0xbd, 0xb3, 0x34, 0x13, 0xb2, 0x84, 0x09, 0x0f,
    0x6e, 0x3e, 0x76, 0xa7, 0x6e, 0x43, 0x42, 0x69, 0xc2, 0x61, 0x64, 0x64,
    0xd3, 0xee, 0x9c, 0x98, 0x2c, 0x20, 0x53, 0x21, 0x69, 0x36, 0x32, 0x5f,
    0x52, 0x51, 0x52, 0xe9, 0x16, 0xc2, 0x11, 0x5c, 0xfe, 0x60, 0xae, 0xa3,
    0x41, 0xc3, 0x5e, 0x83, 0x12, 0xb2, 0x25, 0xb9, 0xb3, 0x78, 0x8a, 0x54,
    0x89, 0x90, 0xc4, 0x4e, 0xe7, 0x81, 0x6d
};

psRes_t ecdsaWithP256(void)
{
    return ecdsaTest(
            IANA_SECP256R1,
            tbs,
            tbsLen,
            sig_p256,
            sizeof(sig_p256),
            EC256KEY,
            EC256KEY_SIZE,
            OID_SHA256_ECDSA_SIG);
}

psRes_t ecdsaWithP384(void)
{
    return ecdsaTest(
            IANA_SECP384R1,
            tbs,
            tbsLen,
            sig_p384,
            sizeof(sig_p384),
            EC384KEY,
            EC384KEY_SIZE,
            OID_SHA384_ECDSA_SIG);
}

psRes_t ecdsaWithP521(void)
{
    psRes_t rc;

    rc = ecdsaTest(
            IANA_SECP521R1,
            tbs,
            tbsLen,
            sig_p521,
            sizeof(sig_p521),
            EC521KEY,
            EC521KEY_SIZE,
            OID_SHA512_ECDSA_SIG);
    if (rc < 0)
    {
        return rc;
    }

    rc = ecdsaTest(
            IANA_SECP521R1,
            tbs,
            tbsLen,
            sig_p521_b,
            sizeof(sig_p521_b),
            EC521KEY,
            EC521KEY_SIZE,
            OID_SHA512_ECDSA_SIG);

    return rc;
}

psRes_t rotLoadEcPub(void)
{
    psRes_t rc = PS_FAILURE;
    unsigned char tbs[] = {'a', 'b', 'c', 'd'};
    size_t tbsLen = 4;
    const psEccCurve_t *curve;
    unsigned char tbsHashSigP256[] =
    {
        0x30, 0x45,

        0x02, 0x20, 0x5b, 0x98, 0x85, 0x9e, 0x8c, 0x15, 0xe1, 0x6a, 0x9a, 0x61,
        0x76, 0xc6, 0x0f, 0x89, 0xa7, 0xa7, 0x03, 0xcd, 0xe6, 0xef, 0x0d, 0x7b,
        0xd4, 0x84, 0x3e, 0xe0, 0x79, 0xc2, 0xde, 0xc5, 0x48, 0xd7,

        0x02, 0x21, 0x00, 0xcb, 0x02, 0x4f, 0xaf, 0x9f, 0x1f, 0xa2, 0xd5, 0xcd,
        0xdd, 0x61, 0xb0, 0x08, 0x36, 0x03, 0x25, 0x10, 0x27, 0x09, 0xae, 0x24,
        0xb9, 0x18, 0xbd, 0x47, 0xd0, 0x3c, 0x46, 0x9e, 0x7b, 0xda, 0x6f
    };
    psSize_t tbsHashSigP256Len = sizeof(tbsHashSigP256);
    unsigned char tbsHashSigP256Wrong[] =
    {
        0x30, 0x45,

        0x02, 0x20, 0x5b, 0x98, 0x85, 0x9e, 0x8c, 0x15, 0xe1, 0x6a, 0x9a, 0x61,
        0x76, 0xc6, 0x0f, 0x89, 0xa7, 0xa7, 0x03, 0xcd, 0xe6, 0xef, 0x0d, 0x7b,
        0xd4, 0x84, 0x3e, 0xe0, 0x79, 0xc2, 0xde, 0xc5, 0x48, 0xd8, /* d7->d8 */

        0x02, 0x21, 0x00, 0xcb, 0x02, 0x4f, 0xaf, 0x9f, 0x1f, 0xa2, 0xd5, 0xcd,
        0xdd, 0x61, 0xb0, 0x08, 0x36, 0x03, 0x25, 0x10, 0x27, 0x09, 0xae, 0x24,
        0xb9, 0x18, 0xbd, 0x47, 0xd0, 0x3c, 0x46, 0x9e, 0x7b, 0xda, 0x6f
    };
    psSize_t tbsHashSigP256WrongLen = sizeof(tbsHashSigP256Wrong);
    unsigned char tbsHashSigP384Sha384[] =
    {
        0x30, 0x65, 0x02, 0x30, 0x0a, 0x7a, 0x90, 0x6f, 0x27, 0xe5, 0x72, 0x3b,
        0xa0, 0x0b, 0x33, 0x2f, 0x1f, 0x4b, 0x77, 0xcb, 0xb5, 0x4f, 0x8f, 0xa5,
        0xd6, 0x9a, 0x8f, 0xc0, 0x2e, 0x45, 0xc4, 0x10, 0xcc, 0x0a, 0x38, 0xed,
        0x04, 0x58, 0xba, 0x9c, 0x2f, 0x07, 0x9f, 0x30, 0xb0, 0x03, 0x0e, 0x50,
        0xe0, 0x89, 0xe1, 0xb4, 0x02, 0x31, 0x00, 0x9d, 0xba, 0xb7, 0xa2, 0x77,
        0xb6, 0x08, 0x37, 0x00, 0x62, 0x88, 0xa1, 0x09, 0xbe, 0x01, 0xbd, 0x61,
        0x14, 0x4e, 0x44, 0xd2, 0x65, 0xd3, 0x30, 0x90, 0xe9, 0x7d, 0xe3, 0x21,
        0x83, 0xe8, 0x2c, 0x76, 0xb0, 0xb6, 0x19, 0xea, 0x7e, 0x6d, 0x8d, 0xa3,
        0xf6, 0x7b, 0xde, 0x59, 0x34, 0x67, 0xda
    };
    psSize_t tbsHashSigP384Sha384Len = sizeof(tbsHashSigP384Sha384);
    unsigned char tbsHashSigP384Sha384Wrong1[] =
    {
        0x30, 0x65, 0x02, 0x30, 0x0a, 0x7a, 0x90, 0x6f, 0x27, 0xe5, 0x72, 0x3b,
        0xa0, 0x0b, 0x33, 0x2f, 0x1f, 0x4b, 0x77, 0xcb, 0xb5, 0x4f, 0x8f, 0xa5,
        0xd6, 0x9a, 0x8f, 0xc0, 0x2e, 0x45, 0xc4, 0x10, 0xcc, 0x0a, 0x38, 0xed,
        0x04, 0x58, 0xba, 0x9c, 0x2f, 0x07, 0x9f, 0x30, 0xb0, 0x03, 0x0e, 0x50,
        0xe0, 0x89, 0xe1, 0xb4, 0x02, 0x31, 0x00, 0x9d, 0xba, 0xb7, 0xa2, 0x77,
        0xb6, 0x08, 0x37, 0x00, 0x62, 0x88, 0xa1, 0x09, 0xbe, 0x01, 0xbd, 0x61,
        0x14, 0x4e, 0x44, 0xd2, 0x65, 0xd3, 0x30, 0x90, 0xe9, 0x7d, 0xe3, 0x21,
        0x83, 0xe8, 0x2c, 0x76, 0xb0, 0xb6, 0x19, 0xea, 0x7e, 0x6d, 0x8d, 0xa3,
        0xf6, 0x7b, 0xde, 0x59, 0x34, 0x67, 0xdb /* da --> db */
    };
    psSize_t tbsHashSigP384Sha384Wrong1Len = sizeof(tbsHashSigP384Sha384Wrong1);
    unsigned char tbsHashSigP384Sha384Wrong2[] =
    {
        0x30,
        0x66, /* 65 --> 66: Wrong SEQ len */
        0x02, 0x30, 0x0a, 0x7a, 0x90, 0x6f, 0x27, 0xe5, 0x72, 0x3b,
        0xa0, 0x0b, 0x33, 0x2f, 0x1f, 0x4b, 0x77, 0xcb, 0xb5, 0x4f, 0x8f, 0xa5,
        0xd6, 0x9a, 0x8f, 0xc0, 0x2e, 0x45, 0xc4, 0x10, 0xcc, 0x0a, 0x38, 0xed,
        0x04, 0x58, 0xba, 0x9c, 0x2f, 0x07, 0x9f, 0x30, 0xb0, 0x03, 0x0e, 0x50,
        0xe0, 0x89, 0xe1, 0xb4, 0x02, 0x31, 0x00, 0x9d, 0xba, 0xb7, 0xa2, 0x77,
        0xb6, 0x08, 0x37, 0x00, 0x62, 0x88, 0xa1, 0x09, 0xbe, 0x01, 0xbd, 0x61,
        0x14, 0x4e, 0x44, 0xd2, 0x65, 0xd3, 0x30, 0x90, 0xe9, 0x7d, 0xe3, 0x21,
        0x83, 0xe8, 0x2c, 0x76, 0xb0, 0xb6, 0x19, 0xea, 0x7e, 0x6d, 0x8d, 0xa3,
        0xf6, 0x7b, 0xde, 0x59, 0x34, 0x67, 0xda
    };
    psSize_t tbsHashSigP384Sha384Wrong2Len = sizeof(tbsHashSigP384Sha384Wrong2);

    psPubKey_t key, key2;
    psBool_t verifyResult;

    memset(&key, 0, sizeof(key));

    rc = getEccParamById(IANA_SECP256R1, &curve);
    FAIL_IF(rc != PS_SUCCESS);
    key.key.ecc.rotKeyType = ps_ecc_key_type_ecdsa;
    rc = psEccX963ImportKey(
            NULL,
            ecc_256_pub_inner,
            sizeof(ecc_256_pub_inner),
            &key.key.ecc,
            curve);
    GOTO_FAIL_IF(rc != PS_SUCCESS, out_fail_no_key);
    key.type = PS_ECC;

# ifdef USE_SECP384R1
    Memset(&key2, 0, sizeof(key2));
    rc = getEccParamById(IANA_SECP384R1, &curve);
    FAIL_IF(rc != PS_SUCCESS);
    key2.key.ecc.rotKeyType = ps_ecc_key_type_ecdsa;
    rc = psEccX963ImportKey(
            NULL,
            ecc_384_pub_inner,
            sizeof(ecc_384_pub_inner),
            &key2.key.ecc,
            curve);
    GOTO_FAIL_IF(rc != PS_SUCCESS, out_fail_no_key);
    key2.type = PS_ECC;
# endif

    /* Try to verify a valid signature (P-256). */
    rc = psVerifySig(
            NULL,
            tbs,
            tbsLen,
            tbsHashSigP256,
            tbsHashSigP256Len,
            &key,
            OID_SHA256_ECDSA_SIG,
            &verifyResult,
            NULL);
    if (rc != PS_SUCCESS || verifyResult != PS_TRUE)
    {
        printf("ECDSA sig KAT 1 failed\n");
        goto out_fail;
    }

    /* Try to verify an invalid signature (P-256). */
    rc = psVerifySig(
            NULL,
            tbs,
            tbsLen,
            tbsHashSigP256Wrong,
            tbsHashSigP256WrongLen,
            &key,
            OID_SHA256_ECDSA_SIG,
            &verifyResult,
            NULL);
    if (verifyResult == PS_TRUE)
    {
        printf("ECDSA sig KAT 2 failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    /* Try to verify a SHA-384 based signature (P-384). */
    rc = psVerifySig(
            NULL,
            tbs,
            tbsLen,
            tbsHashSigP384Sha384,
            tbsHashSigP384Sha384Len,
            &key2,
            OID_SHA384_ECDSA_SIG,
            &verifyResult,
            NULL);
    if (rc == PS_SUCCESS || verifyResult != PS_TRUE)
    {
        printf("ECDSA sig KAT 3 failed\n");
        goto out_fail;
    }

    /* Try to verify an invalid SHA-384 based signature (P-384). */
    rc = psVerifySig(
            NULL,
            tbs,
            tbsLen,
            tbsHashSigP384Sha384Wrong1,
            tbsHashSigP384Sha384Wrong1Len,
            &key2,
            OID_SHA384_ECDSA_SIG,
            &verifyResult,
            NULL);
    if (verifyResult == PS_TRUE)
    {
        printf("ECDSA sig KAT 3 failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    /* Try to verify an invalid SHA-384 based signature (P-384). */
    rc = psVerifySig(
            NULL,
            tbs,
            tbsLen,
            tbsHashSigP384Sha384Wrong2,
            tbsHashSigP384Sha384Wrong2Len,
            &key2,
            OID_SHA384_ECDSA_SIG,
            &verifyResult,
            NULL);
    if (verifyResult == PS_TRUE)
    {
        printf("ECDSA sig KAT 3 failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    psEccClearKey(&key.key.ecc);
out_fail_no_key:

    return rc;
}

psRes_t rotVerify(void)
{
    return PS_FAILURE;
}

psRes_t rotGenSharedKAT(uint16_t curveId,
        unsigned char *priv,
        psSizeL_t privLen,
        unsigned char *pub,
        psSizeL_t pubLen,
        unsigned char *expected_secret,
        psSizeL_t expected_secret_len)
{
    psRes_t rc;
    psEccKey_t privKey = PS_ECC_STATIC_INIT;
    psEccKey_t pubkey_imported = PS_ECC_STATIC_INIT;
    const psEccCurve_t *curve;
    unsigned char got_secret[128] = { 0 };
    psSize_t secret_len = sizeof(got_secret);

    rc = getEccParamById(curveId, &curve);
    FAIL_IF(rc != PS_SUCCESS);

    privKey.rotKeyType = ps_ecc_key_type_ecdhe;
    rc = psEccParsePrivKey(
            NULL,
            priv,
            privLen,
            &privKey,
            curve);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccParsePrivKey failed\n");
        goto out_fail_no_priv;
    }

    pubkey_imported.rotKeyType = ps_ecc_key_type_ecdhe;
    rc = psEccX963ImportKey(
            NULL,
            pub,
            pubLen,
            &pubkey_imported,
            curve);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccX963ImportKey failed\n");
        goto out_fail_no_pub;
    }

    secret_len = sizeof(got_secret);
    rc = psEccGenSharedSecret(
            NULL,
            &privKey,
            &pubkey_imported,
            got_secret,
            &secret_len,
            NULL);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccGenSharedSecret failed\n");
        goto out_fail;
    }

    if (secret_len != expected_secret_len ||
            Memcmp(got_secret, expected_secret, secret_len))
    {
        _psTrace("KAT failed\n");
        psTraceBytes("Got", got_secret, secret_len);
        psTraceBytes("Expected", expected_secret, expected_secret_len);
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    psEccClearKey(&pubkey_imported);

out_fail_no_pub:
    psEccClearKey(&privKey);

out_fail_no_priv:
    return rc;
}

/* Same test vector as in algorithmTest.c */
psRes_t rotGenSharedP256(void)
{
    unsigned char alice_priv[] =
    {
        0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0x2a, 0x50, 0x32, 0x9a, 0xa5,
        0x7e, 0x0d, 0xc0, 0x1f, 0xf9, 0xb1, 0xeb, 0xe4, 0x01, 0x4c, 0xc2, 0x87,
        0x78, 0x91, 0xe3, 0xb6, 0x53, 0x59, 0x77, 0x3c, 0x0e, 0x3c, 0x15, 0xa3,
        0xb5, 0x82, 0x96, 0xa0, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d,
        0x03, 0x01, 0x07, 0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x42, 0x37, 0x6d,
        0xf6, 0x3e, 0x06, 0x70, 0x7f, 0xa2, 0x36, 0x8d, 0x37, 0x90, 0x92, 0x93,
        0xe5, 0xc3, 0x70, 0x94, 0x00, 0xd1, 0x09, 0xb2, 0xb5, 0x70, 0xa1, 0x82,
        0xfe, 0xa6, 0xb0, 0xfc, 0xfa, 0x18, 0xea, 0x5e, 0xff, 0x87, 0x0f, 0xbf,
        0xd5, 0xd6, 0x8b, 0x88, 0xb9, 0x1a, 0xcf, 0xf9, 0x53, 0xd2, 0xb0, 0x5c,
        0x7b, 0x2f, 0x71, 0xf5, 0x95, 0xb0, 0xa1, 0x3d, 0xd6, 0xa5, 0x59, 0x14,
        0x56
    };
    psSizeL_t alice_priv_len = sizeof(alice_priv);
    unsigned char bob_pub[] =
    {
        0x04, 0x32, 0xee, 0xb1, 0x56, 0xf9, 0xb1, 0xc9, 0x80, 0x66, 0xa5, 0x7d,
        0x94, 0xff, 0xde, 0x61, 0xbd, 0x3f, 0x2d, 0xf0, 0x1f, 0xc0, 0xb5, 0x1e,
        0xc1, 0x05, 0x5b, 0x2b, 0xf9, 0x2a, 0x39, 0x6a, 0x94, 0x82, 0x6b, 0x77,
        0xd4, 0xb9, 0x07, 0x02, 0xdb, 0x73, 0x6f, 0x95, 0xe9, 0xc3, 0xbd, 0xd5,
        0x25, 0x5f, 0xea, 0x0b, 0xc4, 0xa6, 0x60, 0x83, 0x5c, 0xe4, 0x3a, 0xd9,
        0x08, 0xf9, 0x9b, 0x09, 0x8c
    };
    psSizeL_t bob_pub_len = sizeof(bob_pub);
    unsigned char expected_secret[] =
    {
        0xb1, 0xe2, 0x6c, 0x88, 0xe7, 0x06, 0x12, 0x1e, 0x92, 0x0f, 0xc2, 0x89,
        0x35, 0x8d, 0x37, 0x36, 0x20, 0xfa, 0x81, 0x91, 0x53, 0x5d, 0x4c, 0xa1,
        0x71, 0x1f, 0x8c, 0x90, 0xa4, 0x7f, 0x8b, 0xf4
    };
    psSizeL_t expected_secret_len = sizeof(expected_secret);

    return rotGenSharedKAT(
            IANA_SECP256R1,
            alice_priv,
            alice_priv_len,
            bob_pub,
            bob_pub_len,
            expected_secret,
            expected_secret_len);
}

/* Same test vector as in algorithmTest.c */
psRes_t rotGenSharedP384(void)
{
    unsigned char alice_priv[] =
    {
        0x30, 0x81, 0xa4, 0x02, 0x01, 0x01, 0x04, 0x30, 0xfc, 0x80, 0x44, 0xc5,
        0x86, 0xd4, 0x6a, 0x93, 0xa5, 0xd1, 0x33, 0xe0, 0x59, 0xe2, 0x5c, 0xca,
        0x04, 0x89, 0xc6, 0x0e, 0x45, 0xcb, 0x5a, 0x3b, 0x22, 0x07, 0x6d, 0xcc,
        0x1b, 0x49, 0xba, 0x80, 0xe9, 0x7f, 0x48, 0xb7, 0x7c, 0x9f, 0x49, 0x17,
        0xa0, 0x41, 0x81, 0x5e, 0xc0, 0x75, 0x2a, 0x9b, 0xa0, 0x07, 0x06, 0x05,
        0x2b, 0x81, 0x04, 0x00, 0x22, 0xa1, 0x64, 0x03, 0x62, 0x00, 0x04, 0x6c,
        0xc2, 0x05, 0x72, 0x70, 0x4b, 0x07, 0x2f, 0x36, 0x7c, 0x77, 0xa3, 0x04,
        0xbe, 0x18, 0x56, 0x3f, 0xc9, 0xfa, 0x50, 0xe9, 0x2e, 0x0a, 0x24, 0x74,
        0xa1, 0x0d, 0x48, 0x92, 0x71, 0x62, 0xb4, 0xd5, 0x69, 0xad, 0x8c, 0x31,
        0xf0, 0xfe, 0xa5, 0x00, 0x6c, 0x1e, 0x34, 0x58, 0x1a, 0xd3, 0x83, 0x5a,
        0x79, 0x81, 0xc9, 0xb5, 0x2b, 0x0f, 0x72, 0x6b, 0x5d, 0x20, 0x7b, 0xba,
        0xd3, 0x4c, 0x93, 0xbb, 0xe4, 0x58, 0x46, 0x06, 0x92, 0xab, 0x5d, 0x30,
        0xff, 0x03, 0xf6, 0xfe, 0x1c, 0x87, 0xfb, 0x5a, 0x00, 0xa5, 0x7e, 0x5e,
        0xbd, 0x53, 0x02, 0x38, 0xe7, 0xf8, 0x53, 0x58, 0x19, 0x77, 0x2c
    };
    size_t alice_priv_len = sizeof(alice_priv);
    unsigned char bob_pub[] =
    {
        0x04, 0xba, 0x84, 0x0b, 0xd0, 0xab, 0xfd, 0x2f, 0x4c, 0x49, 0x19, 0x8c,
        0xbf, 0x97, 0x55, 0x2d, 0xbc, 0x2d, 0x2a, 0xf0, 0x8b, 0x8f, 0xfc, 0x2b,
        0x85, 0xdb, 0x02, 0x83, 0x9b, 0x41, 0xdd, 0x91, 0xda, 0xad, 0x1e, 0x43,
        0x81, 0x18, 0xc9, 0xf7, 0xc2, 0x5a, 0x06, 0x05, 0xc5, 0x9b, 0x72, 0xf8,
        0x5c, 0xf7, 0x25, 0xb3, 0x50, 0x98, 0x5e, 0x31, 0xa0, 0x24, 0x0f, 0xc4,
        0x9a, 0x2f, 0xc9, 0x6d, 0x4e, 0x2a, 0xab, 0xdb, 0x9e, 0xa1, 0x73, 0x36,
        0x5b, 0x3f, 0x39, 0xcf, 0x5f, 0x45, 0x0f, 0xa5, 0xc8, 0xfc, 0x40, 0x57,
        0xaf, 0x96, 0x0d, 0x25, 0xd6, 0x7e, 0x0b, 0xe1, 0x6a, 0x4d, 0x09, 0x08,
        0xca
    };
    size_t bob_pub_len = sizeof(bob_pub);
    unsigned char expected_secret[] =
    {
        0x1b, 0x74, 0x01, 0x47, 0x86, 0x9a, 0x79, 0x25, 0x43, 0x2a, 0x39, 0x3f,
        0xe5, 0x8c, 0x7c, 0xb6, 0x9b, 0xd3, 0x19, 0xb0, 0x3d, 0xc2, 0xa2, 0xb0,
        0x6a, 0xca, 0x33, 0x66, 0x82, 0xb2, 0x47, 0x84, 0x1e, 0xe8, 0x71, 0xeb,
        0x68, 0x88, 0xfa, 0xfd, 0x08, 0x52, 0xe3, 0x2e, 0x04, 0x59, 0xe7, 0xe7
    };
    size_t expected_secret_len = sizeof(expected_secret);

    return rotGenSharedKAT(
            IANA_SECP384R1,
            alice_priv,
            alice_priv_len,
            bob_pub,
            bob_pub_len,
            expected_secret,
            expected_secret_len);
}

/*
  Generated with:
  CURVE_NAME=secp521r1 scripts/generate-ecdh-kat.sh
*/
psRes_t rotGenSharedP521(void)
{
    unsigned char alice_priv[] =
    {
        0x30, 0x81, 0xdc, 0x02, 0x01, 0x01, 0x04, 0x42, 0x00, 0x1e, 0xca, 0x2c,
        0x9e, 0xca, 0x82, 0x39, 0xeb, 0x40, 0x4e, 0x3b, 0xd2, 0xa1, 0x60, 0x45,
        0xeb, 0x59, 0x60, 0xdf, 0xcb, 0xb2, 0x99, 0x2b, 0x7b, 0xab, 0x83, 0xee,
        0x54, 0x5b, 0xc6, 0xbf, 0xac, 0x12, 0x68, 0x91, 0xe3, 0x81, 0x68, 0xb8,
        0x43, 0xed, 0x20, 0xac, 0x7b, 0xea, 0xdb, 0x4c, 0x70, 0xc6, 0x18, 0xf9,
        0xa3, 0xcd, 0x09, 0x10, 0xe3, 0x55, 0xf8, 0x4b, 0x6b, 0x55, 0x0b, 0xd1,
        0x7f, 0x4f, 0xa0, 0x07, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x23, 0xa1,
        0x81, 0x89, 0x03, 0x81, 0x86, 0x00, 0x04, 0x01, 0x0b, 0x06, 0xbc, 0xec,
        0x13, 0xc3, 0x7f, 0xec, 0x3f, 0x89, 0x75, 0x02, 0x67, 0x59, 0x22, 0x25,
        0xce, 0x4e, 0x2b, 0xa0, 0xec, 0xd7, 0xe5, 0x77, 0xe7, 0x8d, 0x7d, 0xd9,
        0xb8, 0x7b, 0xf4, 0x55, 0xa8, 0x66, 0x58, 0x70, 0xda, 0x30, 0xcc, 0xa0,
        0x01, 0xc5, 0x9f, 0xf8, 0xb7, 0xde, 0xf8, 0xf3, 0x42, 0x15, 0x35, 0x0e,
        0x14, 0xd1, 0x26, 0x39, 0x5b, 0xd3, 0x68, 0x87, 0x59, 0x94, 0x5a, 0x4a,
        0xd0, 0x01, 0x4c, 0x3d, 0xe2, 0x74, 0x28, 0xf5, 0xf2, 0x37, 0x2e, 0x96,
        0xb7, 0x11, 0x33, 0x51, 0x11, 0xed, 0x10, 0xa1, 0x4f, 0xc5, 0x71, 0x38,
        0x25, 0x0f, 0x98, 0x9e, 0x2e, 0xcd, 0xd4, 0xdd, 0x10, 0xbf, 0x23, 0x17,
        0x2b, 0x71, 0x65, 0x32, 0xcc, 0x26, 0x61, 0x03, 0xb0, 0x5c, 0x76, 0x34,
        0xbc, 0x08, 0xab, 0x6f, 0x71, 0xf4, 0xaf, 0x04, 0x07, 0x76, 0x7d, 0x10,
        0x1b, 0x79, 0x9d, 0x6f, 0xfa, 0x50, 0x61
    };
    size_t alice_priv_len = sizeof(alice_priv);
    unsigned char bob_pub[] =
    {
        0x04, 0x00, 0xf1, 0x5f, 0x8f, 0x05, 0xf8, 0x76, 0x9b, 0x9e, 0x5a, 0xa7,
        0xde, 0xf7, 0x23, 0xa8, 0xf2, 0xf9, 0x74, 0x98, 0x5a, 0x5c, 0x77, 0xc3,
        0x93, 0xf1, 0xf9, 0x61, 0x5d, 0xb3, 0x06, 0x77, 0x0b, 0x4c, 0xdc, 0x5a,
        0x43, 0xb2, 0x4f, 0xcb, 0x55, 0xa0, 0x06, 0x11, 0xd6, 0xc1, 0xee, 0xcf,
        0x73, 0x29, 0xc0, 0x08, 0x12, 0x6e, 0x48, 0xa6, 0x96, 0xb9, 0xd1, 0x27,
        0xcd, 0x7c, 0x12, 0xab, 0x51, 0x67, 0x3a, 0x00, 0x36, 0x8a, 0x13, 0x1a,
        0x63, 0xb0, 0x35, 0xcf, 0x56, 0x42, 0x85, 0xa9, 0x4c, 0x48, 0x1d, 0x19,
        0x2a, 0x3c, 0x15, 0x62, 0xff, 0x19, 0x91, 0x0d, 0xa4, 0xb3, 0x41, 0xe7,
        0xa2, 0x4b, 0x56, 0xa2, 0x7d, 0x97, 0x45, 0xee, 0x26, 0x86, 0xb2, 0x00,
        0xd3, 0x9b, 0x6f, 0xb7, 0x47, 0x01, 0xc1, 0x50, 0x2d, 0x2a, 0x6c, 0x23,
        0x71, 0x69, 0xd4, 0x50, 0x24, 0xba, 0x01, 0x8f, 0x7d, 0x36, 0x86, 0xd4,
        0x03
    };
    size_t bob_pub_len = sizeof(bob_pub);
    unsigned char expected_secret[] =
    {
        0x00, 0xd6, 0x97, 0x4f, 0x8d, 0xe8, 0xb0, 0x8f, 0xaf, 0x66, 0x57, 0x5b,
        0xcf, 0x59, 0x6a, 0x76, 0xad, 0x8c, 0xda, 0x9b, 0x6a, 0x64, 0x77, 0x4c,
        0x37, 0xe1, 0xfb, 0x63, 0x89, 0x51, 0x3d, 0x27, 0xa7, 0xfa, 0x75, 0xa0,
        0xa2, 0x5f, 0x07, 0xe8, 0x13, 0xc8, 0x3a, 0xcd, 0x92, 0x62, 0xe7, 0xb8,
        0x3e, 0x2d, 0xcc, 0x99, 0x30, 0xff, 0x56, 0x5e, 0x02, 0x30, 0x0d, 0xdf,
        0x14, 0x9a, 0xef, 0xda, 0x09, 0xb4
    };
    size_t expected_secret_len = sizeof(expected_secret);

    return rotGenSharedKAT(
            IANA_SECP521R1,
            alice_priv,
            alice_priv_len,
            bob_pub,
            bob_pub_len,
            expected_secret,
            expected_secret_len);
}

psRes_t rotEcdheGenKeyInner(uint16_t curveId)
{
    psRes_t rc;
    psEccKey_t alicePriv = PS_ECC_STATIC_INIT;
    psEccKey_t bobPriv = PS_ECC_STATIC_INIT;
    psEccKey_t alicePub = PS_ECC_STATIC_INIT;
    psEccKey_t bobPub = PS_ECC_STATIC_INIT;
    const psEccCurve_t *curve;
    unsigned char aliceExport[141] = {0};
    psSize_t aliceExportLen = sizeof(aliceExport);
    unsigned char bobExport[141] = {0};
    psSize_t bobExportLen = sizeof(bobExport);
    unsigned char secret1[66] = {0};
    psSize_t secret1Len = sizeof(secret1);
    unsigned char secret2[66] = {0};
    psSize_t secret2Len = sizeof(secret2);

    rc = getEccParamById(curveId, &curve);
    FAIL_IF(rc != PS_SUCCESS);

    /* Generate two ECDHE key pairs. */
    alicePriv.rotKeyType = ps_ecc_key_type_ecdhe;
    rc = psEccGenKey(
            NULL,
            &alicePriv,
            curve,
            NULL);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccGenKey failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }
    bobPriv.rotKeyType = ps_ecc_key_type_ecdhe;
    rc = psEccGenKey(
            NULL,
            &bobPriv,
            curve,
            NULL);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccGenKey failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    /* Export the public values. */
    rc = psEccX963ExportKey(
            NULL,
            &alicePriv,
            aliceExport,
            &aliceExportLen);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccX963ExportKey failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }
    rc = psEccX963ExportKey(
            NULL,
            &bobPriv,
            bobExport,
            &bobExportLen);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccX963ExportKey failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    /* Import the peer public values. */
    alicePub.rotKeyType = ps_ecc_key_type_ecdhe;
    rc = psEccX963ImportKey(
            NULL,
            aliceExport,
            aliceExportLen,
            &alicePub,
            curve);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccX963ImportKey failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }
    bobPub.rotKeyType = ps_ecc_key_type_ecdhe;
    rc = psEccX963ImportKey(
            NULL,
            bobExport,
            bobExportLen,
            &bobPub,
            curve);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccX963ImportKey failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    /* Generate shared secret */
    rc = psEccGenSharedSecret(
            NULL,
            &alicePriv,
            &bobPub,
            secret1,
            &secret1Len,
            NULL);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccGenSharedSecret failed\n");
        goto out_fail;
    }
    rc = psEccGenSharedSecret(
            NULL,
            &bobPriv,
            &alicePub,
            secret2,
            &secret2Len,
            NULL);
    if (rc != PS_SUCCESS)
    {
        _psTrace("psEccGenSharedSecret failed\n");
        goto out_fail;
    }

    if (secret1Len != secret2Len ||
            Memcmp(secret1, secret2, secret1Len))
    {
        _psTrace("Secrets mismatch\n");
        goto out_fail;
    }

    rc = PS_SUCCESS;


out_fail:
    psEccClearKey(&alicePub);
    psEccClearKey(&bobPub);
    psEccClearKey(&bobPriv);
    psEccClearKey(&alicePriv);

    return rc;
}

psRes_t rotEcdheGenKeyP256(void)
{
    return rotEcdheGenKeyInner(IANA_SECP256R1);
}

psRes_t rotEcdheGenKeyP384(void)
{
    return rotEcdheGenKeyInner(IANA_SECP384R1);
}

psRes_t rotEcdheGenKeyP521(void)
{
    return rotEcdheGenKeyInner(IANA_SECP521R1);
}

psRes_t rotGCMPairwise(void)
{
    psRes_t rc = PS_FAILURE;
    unsigned char key[16]
        = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
    size_t keyLen = sizeof(key);
    unsigned char iv[16] = {0};
    unsigned char aad[13] = {0};
    size_t aadLen = sizeof(aad);
    unsigned char pt[] = { 'a', 'b', 'c' };
    size_t ptLen = sizeof(pt);
    unsigned char ct[32] = {0};
    size_t ctLen = sizeof(ct);
    unsigned char decrypted[32] = {0};
    unsigned char tag[16] = {0};
    psAesGcm_t ctx, ctx2;

    rc = psAesInitGCM(&ctx, key, keyLen);
    if (rc != PS_SUCCESS)
    {
        return rc;
    }
    psAesReadyGCM(&ctx, iv, aad, aadLen);
    psAesEncryptGCM(&ctx, pt, ct, ptLen);
    psAesGetGCMTag(&ctx, 16, tag);

# if 0
    psTraceBytes("ct", ct, ptLen);
    psTraceBytes("tag", tag, 16);
# endif

    Memcpy(ct + ptLen, tag, 16);
    ctLen = ptLen + 16;

    rc = psAesInitGCM(&ctx2, key, keyLen);
    if (rc != PS_SUCCESS)
    {
        return rc;
    }
    psAesReadyGCM(&ctx2, iv, aad, aadLen);
    rc = psAesDecryptGCM(&ctx2, ct, ctLen, decrypted, ctLen - 16);
    if (rc != PS_SUCCESS)
    {
        return rc;
    }

    if (Memcmp(pt, decrypted, ptLen))
    {
        printf("Pairwise KAT failed\n");
        return PS_FAILURE;
    }

    return PS_SUCCESS;
}

psRes_t rotGCM(void)
{
    psRes_t rc = PS_FAILURE;
    ValStatus_t st;
    ValSymContextPtr_t ctx;
    unsigned char keyValue[16]
        = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
    size_t keyValueLen = sizeof(keyValue);
    unsigned char iv[12] = {0};
    size_t ivLen = sizeof(iv);
    unsigned char aad[13] = {0};
    size_t aadLen = sizeof(aad);
    unsigned char pt[] = { 'a', 'b', 'c' };
    size_t ptLen = sizeof(pt);
    unsigned char ct[32] = {0};
    size_t ctLen = sizeof(ct);
    unsigned char tag[16] = {0};
    size_t tagLen = sizeof(tag);

    st = val_SymAlloc(
            VAL_SYM_ALGO_CIPHER_AES,
            VAL_SYM_MODE_CIPHER_GCM,
            false,
            &ctx);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("valAsymAlloc", st);
        goto out_fail_no_ctx;
    }

    st = val_SymInitKey(
            ctx,
            VAL_ASSETID_INVALID,
            keyValue,
            keyValueLen);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_SymInitKey", st);
        goto out_fail;
    }

    st = val_SymCipherAEInit(
            ctx,
            iv,
            ivLen,
            tagLen,
            VAL_SYM_MODE_GCM_AUTO);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_SymCipherAEInit", st);
        goto out_fail;
    }

    st = val_SymCipherInitEncrypt(ctx);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_SymCipherInitEncrypt", st);
        goto out_fail;
    }

    st = val_SymCipherAEFinal(
            ctx,
            aad,
            aadLen,
            pt,
            ptLen,
            ct,
            &ctLen,
            tag,
            &tagLen);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_SymCipherAEFinal", st);
        goto out_fail;
    }

    rc = PS_SUCCESS;

# if 0
    psTraceBytes("ct", ct, ptLen);
    psTraceBytes("tag", tag, 16);
# endif

out_fail:
    if (rc != PS_SUCCESS)
    {
        st = val_SymRelease(ctx);
        if (st != VAL_SUCCESS)
        {
            PSROT_FAIL("val_SymRelease", st);
        }
    }

out_fail_no_ctx:
    return rc;
}

psRes_t rotGCMKAT(unsigned char *pt,
        size_t ptLen,
        unsigned char *aad,
        size_t aadLen,
        unsigned char *key,
        size_t keyLen,
        unsigned char *nonce,
        size_t nonceLen,
        unsigned char *expect_ct,
        size_t expectCtLen,
        unsigned char *expect_tag,
        size_t expectTagLen)
{
    psAesGcm_t ctx, ctx2;
    unsigned char tag[16] = {0};
    psRes_t rc;
    unsigned char *decrypted;
    size_t decryptedLen;
    unsigned char *ct;
    size_t ctLen;

    ctLen = ptLen + 16;
    ct = malloc(ctLen);
    if (ct == NULL)
    {
        return PS_MEM_FAIL;
    }

    rc = psAesInitGCM(&ctx, key, keyLen);
    if (rc != PS_SUCCESS)
    {
        return rc;
    }
    psAesReadyGCM(&ctx, nonce, aad, aadLen);
    psAesEncryptGCM(&ctx, pt, ct, ptLen);
    psAesGetGCMTag(&ctx, 16, tag);

# if 0
    psTraceBytes("ct", ct, ptLen);
    psTraceBytes("expect_ct", expect_ct, ptLen);
    psTraceBytes("tag", tag, 16);
    psTraceBytes("expect_tag", expect_tag, 16);
# endif

    if (Memcmp(ct, expect_ct, ptLen))
    {
        printf("KAT failed: wrong ct\n");
        return PS_FAILURE;
    }
    if (Memcmp(tag, expect_tag, 16))
    {
        printf("KAT failed: wrong tag\n");
        return PS_FAILURE;
    }

    Memcpy(ct, expect_ct, expectCtLen);
    Memcpy(ct + expectCtLen, tag, 16);

    decryptedLen = ptLen;
    decrypted = malloc(decryptedLen);
    if (decrypted == NULL)
    {
        return PS_MEM_FAIL;
    }
    rc = psAesInitGCM(&ctx2, key, keyLen);
    if (rc != PS_SUCCESS)
    {
        return rc;
    }
    psAesReadyGCM(&ctx2, nonce, aad, aadLen);
    rc = psAesDecryptGCM(&ctx2,
            ct,
            ptLen + 16,
            decrypted,
            ptLen);
    if (rc != PS_SUCCESS)
    {
        return rc;
    }

    if (Memcmp(pt, decrypted, ptLen))
    {
        printf("Pairwise KAT failed\n");
        return PS_FAILURE;
    }

    return PS_SUCCESS;
}

psRes_t rotGCMKAT1(void)
{
    unsigned char pt[] =
    {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };
    unsigned char key[] =
    {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };
    unsigned char *aad = NULL;
    size_t aadLen = 0;
    unsigned char nonce[] =
    {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00
    };
    unsigned char expect_ct[] =
    {
        0x03,0x88,0xda,0xce,0x60,0xb6,0xa3,0x92,
        0xf3,0x28,0xc2,0xb9,0x71,0xb2,0xfe,0x78
    };
    unsigned char expect_tag[] =
    {
        0xab,0x6e,0x47,0xd4,0x2c,0xec,0x13,0xbd,
        0xf5,0x3a,0x67,0xb2,0x12,0x57,0xbd,0xdf
    };
    int32_t rc;

    rc = rotGCMKAT(pt,
            sizeof(pt),
            aad,
            aadLen,
            key,
            sizeof(key),
            nonce,
            sizeof(nonce),
            expect_ct,
            sizeof(expect_ct),
            expect_tag,
            sizeof(expect_tag));
    if (rc != PS_SUCCESS)
    {
        printf("KAT1 failed\n");
        return rc;
    }

    return PS_SUCCESS;
}

psRes_t rotGCMKAT2(void)
{
    /* NIST test vector 0 from section:
       [Keylen = 128]
       [IVlen = 96]
       [PTlen = 256]
       [AADlen = 160]
       [Taglen = 128]
    */
    unsigned char pt[] =
        {0x68,0x31,0x43,0x5b,0x88,0x57,0xda,0xf1,
         0xc5,0x13,0xb1,0x48,0x82,0x0d,0x13,0xb5,
         0xa7,0x2c,0xc4,0x90,0xbd,0xa7,0x9a,0x98,
         0xa6,0xf5,0x20,0xd8,0x76,0x3c,0x39,0xd1};
    unsigned char key[] =
        {0xfe,0xdc,0x71,0x55,0x19,0x2d,0x00,0xb2,
         0x3c,0xdd,0x98,0x75,0x0d,0xb9,0xeb,0xba};
    unsigned char nonce[] =
        {0xa7,0x6b,0x74,0xf5,0x5c,0x1a,0x17,0x56,
         0xa0,0x83,0x38,0xb1};
    unsigned char expect_ct[] =
        {0x15,0x82,0x38,0x05,0xda,0x89,0xa1,0x92,
         0x3b,0xfc,0x1d,0x6f,0x87,0x78,0x4d,0x56,
         0xba,0xd1,0x12,0x8b,0x4d,0xff,0xdb,0xde,
         0xef,0xbb,0x2f,0xa5,0x62,0xc3,0x5e,0x68};
    unsigned char expect_tag[] =
        {0xd2,0x3d,0xc4,0x55,0xce,0xd4,0x98,0x87,
         0xc7,0x17,0xe8,0xea,0xbe,0xec,0x29,0x84};
    unsigned char aad[] =
        {0x2a,0xd2,0x06,0xc4,0x17,0x6e,0x7e,0x55,
         0x2a,0xa0,0x88,0x36,0x88,0x68,0x16,0xfa,
         0xfa,0x77,0xe7,0x59};
    int32_t rc;

    rc = rotGCMKAT(pt,
            sizeof(pt),
            aad,
            sizeof(aad),
            key,
            sizeof(key),
            nonce,
            sizeof(nonce),
            expect_ct,
            sizeof(expect_ct),
            expect_tag,
            sizeof(expect_tag));
    if (rc != PS_SUCCESS)
    {
        printf("KAT1 failed\n");
        return rc;
    }

    return PS_SUCCESS;
}

psRes_t rotHmacKAT1(void)
{
    static const unsigned char hmac_sha256_vector16_key[] = {
        0x41, 0x42, 0x43, 0x44, 0x41, 0x42, 0x43, 0x44, 0x41, 0x42, 0x43, 0x44,
        0x41, 0x42, 0x43, 0x44
    };
    static const unsigned char hmac_sha256_vector16_in[] = {
        0x68, 0x6f, 0x70, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65,
        0x20, 0x62, 0x65, 0x73, 0x74, 0x20, 0x70, 0x6c, 0x61, 0x6e, 0x20, 0x66,
        0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x6f, 0x72, 0x73, 0x74
    };
    static const unsigned char hmac_sha256_vector16_out[] = {
        0xa0, 0xe0, 0xbe, 0x36, 0x7a, 0x4e, 0x12, 0x57, 0x60, 0x58, 0x9d, 0xda,
        0x97, 0x41, 0xcc, 0x13, 0x48, 0x42, 0x56, 0x73, 0xaa, 0x75, 0xed, 0x6f,
        0x58, 0x7c, 0x80, 0xdb, 0x40, 0x9a, 0xd7, 0x89
    };
    ValStatus_t st;
    ValSymContextPtr_t ctx;
    psHmac_t hmacCtx;
    unsigned char out[sizeof(hmac_sha256_vector16_out)];
    unsigned char out2[sizeof(hmac_sha256_vector16_out)];
    ValSize_t outLen = sizeof(out);
    psRes_t rc = PS_FAILURE;

    st = val_SymAlloc(
            VAL_SYM_ALGO_MAC_HMAC_SHA256,
            VAL_SYM_MODE_NONE,
            false,
            &ctx);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_SymAlloc", st);
        goto out_fail_no_ctx;
    }

    st = val_SymInitKey(
            ctx,
            VAL_ASSETID_INVALID,
            hmac_sha256_vector16_key,
            sizeof(hmac_sha256_vector16_key));
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_SymInitKey", st);
        goto out_fail;
    }

    st = val_SymMacGenerate(
            ctx,
            hmac_sha256_vector16_in,
            sizeof(hmac_sha256_vector16_in),
            out,
            &outLen);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_SymMacGenerate", st);
        goto out_fail_no_ctx;
    }

    if (outLen != sizeof(hmac_sha256_vector16_out) ||
            Memcmp(out, hmac_sha256_vector16_out, outLen))
    {
        printf("KAT failed\n");
        psTraceBytes("expected",
                hmac_sha256_vector16_out,
                sizeof(hmac_sha256_vector16_out));
        psTraceBytes("got", out, outLen);
        rc = PS_FAILURE;
        goto out_fail_no_ctx; /* SymMacGenerate clears the ctx. */
    }

    rc = psHmacSingle(
            &hmacCtx,
            HMAC_SHA256,
            hmac_sha256_vector16_key,
            sizeof(hmac_sha256_vector16_key),
            hmac_sha256_vector16_in,
            sizeof(hmac_sha256_vector16_in),
            out2);
    if (rc != PS_SUCCESS)
    {
        goto out_fail;
    }

    if (Memcmp(out, out2, outLen))
    {
        printf("psHmac and VAL produced different results\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    if (rc != PS_SUCCESS)
    {
        st = val_SymRelease(ctx);
        if (st != VAL_SUCCESS)
        {
            PSROT_FAIL("val_SymRelease", st);
        }
    }

out_fail_no_ctx:
    return rc;
}

psRes_t rotHmacKAT2(void)
{
    /* Test vector resembles the inputs to HMAC invocations within
       TLS-PRF. */
    unsigned char key[] =
    {
        0xa7, 0x38, 0x8d, 0x40, 0xc9, 0x1d, 0x59, 0x6c, 0xb3, 0xa3, 0x99, 0x60,
        0xce, 0xfe, 0x53, 0x5d, 0xa8, 0x32, 0x3d, 0x02, 0x1e, 0x53, 0xb2, 0xdc,
        0x87, 0x3a, 0x8f, 0xee, 0x9c, 0xcb, 0xb4, 0x72
    };
    unsigned char in[] =
    {
        0x65, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x6d, 0x61, 0x73,
        0x74, 0x65, 0x72, 0x20, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x6b, 0x43,
        0x47, 0x71, 0x2b, 0xd3, 0x18, 0x50, 0x66, 0x80, 0xd3, 0xfd, 0x2d, 0xd3,
        0x17, 0xf5, 0xf1, 0x67, 0xfb, 0xb5, 0x8e, 0xff, 0xe3, 0xbe, 0x64, 0xce,
        0xb8, 0x25, 0x11, 0xa6, 0x9a, 0x77
    };
    unsigned char expected_out[] =
    {
        0xbc, 0xeb, 0xc6, 0x5e, 0x20, 0xaa, 0x2c, 0xac, 0x5d, 0xe3, 0x58, 0xbd,
        0x6d, 0xf8, 0xe1, 0x43, 0x8f, 0x75, 0x37, 0xc2, 0xd7, 0x76, 0xb4, 0xd8,
        0x58, 0x19, 0xd6, 0xc6, 0x79, 0xf5, 0xb1, 0x5c
    };
    unsigned char out[SHA256_HASH_SIZE];
    psRes_t rc = PS_FAILURE;
    psHmac_t ctx;

    rc = psHmacSingle(
            &ctx,
            HMAC_SHA256,
            key,
            sizeof(key),
            in,
            sizeof(in),
            out);
    if (rc < 0)
    {
        goto out_fail;
    }

    if (Memcmp(out, expected_out, SHA256_HASH_SIZE))
    {
        printf("HMAC KAT failed\n");
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    return rc;
}

psRes_t rotRandom(void)
{
    psRes_t rc = PS_FAILURE;
    ValStatus_t st;
    unsigned char random[64] = {0};

    st = val_RandomData(32, random);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_RandomData", st);
        goto out_fail;
    }

    st = val_RandomData(64, random);
    if (st != VAL_SUCCESS)
    {
        PSROT_FAIL("val_RandomData", st);
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    return rc;
}

psRes_t rotRSAVerify(void)
{
# ifdef USE_ROT_RSA
    unsigned char tbs[] =
    {
        'a', 'b', 'c'
    };
    /*
      echo -n "abc" \
      |openssl dgst -binary -sha256 \
      |openssl pkeyutl -sign \
      -inkey testkeys/RSA/2048_RSA_KEY.pem \
      -pkeyopt digest:sha256 -pkeyopt rsa_padding_mode:pkcs1 \
      |xxd -i
    */
    unsigned char sig[] =
    {
        0x94, 0x34, 0xe2, 0x3f, 0x6e, 0xa9, 0x04, 0x32, 0xe0, 0x31, 0x24, 0x59,
        0xe4, 0x9e, 0xfb, 0x0e, 0x80, 0xe2, 0xc1, 0x56, 0xe4, 0x8b, 0xfc, 0xed,
        0xeb, 0xed, 0x29, 0xf0, 0x32, 0xc6, 0x07, 0x45, 0xfa, 0xab, 0x59, 0x54,
        0x62, 0xc1, 0xd2, 0xc3, 0x6f, 0xad, 0x49, 0xb3, 0xf3, 0x7d, 0x1a, 0x60,
        0x18, 0x52, 0xc9, 0xda, 0x35, 0xe7, 0xca, 0x94, 0xb7, 0x5a, 0x6e, 0x88,
        0xa7, 0xcc, 0x45, 0x54, 0x99, 0xdc, 0x87, 0x25, 0x72, 0x0c, 0x5f, 0x84,
        0xb6, 0x62, 0xc4, 0xdb, 0x84, 0xc2, 0x44, 0xcf, 0x54, 0x93, 0x11, 0x66,
        0xbb, 0x07, 0x31, 0xe6, 0x10, 0x19, 0xb2, 0x27, 0xda, 0x9f, 0x13, 0x51,
        0xe8, 0xe5, 0xde, 0xd3, 0x0f, 0xc5, 0x7c, 0x9b, 0xc9, 0x53, 0x01, 0x3b,
        0xc4, 0x45, 0x82, 0x0c, 0x96, 0x3b, 0x44, 0x05, 0xe1, 0xe1, 0x42, 0x73,
        0x2c, 0xb2, 0x80, 0x26, 0xbc, 0x75, 0xe3, 0x48, 0x3b, 0xe6, 0x80, 0xff,
        0x7d, 0xd0, 0xd8, 0x0c, 0xdf, 0xb4, 0xfd, 0xe2, 0x1a, 0xba, 0x90, 0x62,
        0x19, 0x69, 0x68, 0xb5, 0x0b, 0x35, 0xb6, 0x9b, 0xb7, 0xd8, 0x39, 0x3c,
        0x34, 0x5e, 0x9a, 0x65, 0xb6, 0xc3, 0x01, 0x59, 0x4e, 0xe7, 0x82, 0x6a,
        0xf6, 0x8c, 0xbf, 0xac, 0x48, 0x16, 0x9d, 0xf6, 0x79, 0x6e, 0x3a, 0x26,
        0x0e, 0xff, 0x15, 0x46, 0xfa, 0xb6, 0x70, 0x7b, 0x5c, 0x6e, 0xa3, 0x44,
        0x10, 0xa3, 0x3d, 0x56, 0x0d, 0x97, 0xcb, 0xc5, 0xc7, 0xde, 0x2a, 0x1d,
        0x29, 0xe2, 0xd5, 0x14, 0xcc, 0x7e, 0x08, 0xc4, 0x47, 0xac, 0xfa, 0xb6,
        0x12, 0xdb, 0x37, 0x98, 0x9e, 0x8b, 0xf7, 0xcf, 0x19, 0xe8, 0x7e, 0x83,
        0x40, 0xf1, 0x77, 0xb5, 0x5a, 0x69, 0x1a, 0xdd, 0x37, 0x85, 0x19, 0x38,
        0x80, 0x90, 0xd3, 0xae, 0xb0, 0x19, 0xa9, 0xa3, 0x95, 0xf7, 0xf9, 0x73,
        0xd5, 0xcf, 0x7b, 0xe4
    };
    /*
      echo -n "abc" \
      |openssl dgst -binary -sha384 \
      |openssl pkeyutl -sign \
      -inkey testkeys/RSA/2048_RSA_KEY.pem \
      -pkeyopt digest:sha384 -pkeyopt rsa_padding_mode:pkcs1 \
      |xxd -i
    */
    unsigned char sig_sha384[] =
    {
        0xa5, 0xfb, 0xec, 0x64, 0x4d, 0x21, 0x0a, 0x9d, 0x33, 0x00, 0x34, 0x96,
        0x11, 0x8f, 0x31, 0x60, 0x7c, 0xd3, 0xef, 0x8b, 0x8c, 0xa0, 0x98, 0x2d,
        0xa6, 0x8c, 0x0c, 0xce, 0x33, 0x7b, 0x04, 0x03, 0x6f, 0xba, 0xfd, 0x9e,
        0x64, 0x93, 0x6c, 0x5f, 0x97, 0x84, 0xa1, 0x5a, 0x59, 0xed, 0x5b, 0x8a,
        0xf1, 0x34, 0x65, 0x52, 0x8b, 0x43, 0x42, 0x49, 0x9d, 0x91, 0xcb, 0x83,
        0x2e, 0x7e, 0x47, 0x70, 0x41, 0x8b, 0x7b, 0x04, 0xdb, 0x66, 0x8e, 0x8a,
        0x86, 0x53, 0x0b, 0xa7, 0x80, 0xdf, 0x9d, 0xf8, 0xfd, 0x8d, 0x9b, 0x99,
        0xb2, 0xe7, 0x35, 0x2a, 0x71, 0xa1, 0xb4, 0xa2, 0xb1, 0x01, 0x3d, 0x02,
        0xb6, 0x91, 0x9d, 0x22, 0xfc, 0x5b, 0x92, 0x55, 0x8b, 0xe7, 0x55, 0xcb,
        0xf7, 0xda, 0xb5, 0x43, 0x9f, 0xbc, 0x2d, 0x5d, 0x69, 0xae, 0xec, 0x95,
        0x64, 0xd8, 0x10, 0x5c, 0x8c, 0x4e, 0x58, 0x88, 0x3b, 0x8d, 0xee, 0x37,
        0xb2, 0x9b, 0x11, 0xb4, 0x4f, 0xf0, 0x8d, 0xfa, 0x51, 0x47, 0x2f, 0x05,
        0x5b, 0xf4, 0x24, 0x25, 0x7d, 0x60, 0xdf, 0x7e, 0x2d, 0x4b, 0x0c, 0xb2,
        0x00, 0xe4, 0x7a, 0x8b, 0xe4, 0xaa, 0x81, 0x27, 0x68, 0x5a, 0x6c, 0x05,
        0xea, 0xbe, 0x75, 0x06, 0x96, 0x3a, 0x72, 0x1e, 0x7a, 0x25, 0x0f, 0x0b,
        0x13, 0xe1, 0x16, 0xf7, 0x8b, 0x5b, 0xe3, 0x03, 0x6c, 0x2c, 0x1c, 0xc3,
        0x6b, 0x98, 0x9d, 0x46, 0x0a, 0xcc, 0x9f, 0xa8, 0x85, 0x2c, 0x92, 0xf4,
        0x4a, 0x64, 0x43, 0x9e, 0xaa, 0x60, 0x97, 0x0e, 0xa1, 0x84, 0x20, 0x2f,
        0x3c, 0x1a, 0x8f, 0x89, 0x12, 0x88, 0x98, 0x5e, 0xaa, 0x51, 0x16, 0xf9,
        0x0c, 0x0c, 0xb0, 0x6e, 0xe7, 0x62, 0x0b, 0xb5, 0xa1, 0xa2, 0x5f, 0xa4,
        0xd4, 0x45, 0x6c, 0x37, 0x54, 0xab, 0x74, 0x1b, 0x2d, 0x70, 0x8f, 0x96,
        0x64, 0xcb, 0xe8, 0x29
    };
    unsigned char pub_key[] =
    {
        0x03, 0x82, 0x01, 0x0f, 0x00,
        0x30, 0x82, 0x01,
        0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xad, 0x6a, 0x33, 0xee, 0xa2, 0x73,
        0x6d, 0x68, 0xba, 0xbd, 0x2d, 0xb1, 0xb5, 0x54, 0xf0, 0x04, 0x14, 0xff,
        0xbd, 0xd7, 0x5b, 0x4c, 0x69, 0xe7, 0xf4, 0x66, 0x7f, 0xac, 0x06, 0xe1,
        0x95, 0x77, 0x6b, 0x9d, 0x9a, 0x1f, 0x51, 0x61, 0xe6, 0xd2, 0x92, 0x50,
        0xdc, 0x0f, 0x5d, 0x15, 0x0c, 0x9e, 0xd3, 0x37, 0xa6, 0xf9, 0x77, 0x36,
        0x76, 0x74, 0xda, 0x3f, 0x50, 0x7f, 0x9c, 0xdf, 0x52, 0xc9, 0x32, 0x4c,
        0xda, 0x22, 0x31, 0xeb, 0x94, 0xb0, 0xcf, 0x56, 0xee, 0x91, 0x86, 0x30,
        0xa9, 0x24, 0x29, 0x01, 0x2f, 0x83, 0xd1, 0x08, 0x73, 0x94, 0x97, 0xe1,
        0xdb, 0x88, 0x85, 0x3b, 0xe1, 0x46, 0x2b, 0xc5, 0xff, 0x03, 0xea, 0x7c,
        0x74, 0xa6, 0x89, 0x64, 0x41, 0xcc, 0x88, 0xe7, 0x9c, 0xaf, 0x33, 0xfb,
        0x48, 0xe7, 0x5b, 0xca, 0x6f, 0x90, 0x75, 0x7a, 0x42, 0xa2, 0xba, 0x8a,
        0x4e, 0x06, 0x38, 0x87, 0x51, 0x66, 0x96, 0xc1, 0xef, 0x8a, 0xe2, 0xb2,
        0xe7, 0x63, 0x57, 0xf4, 0xfa, 0xf8, 0xa6, 0x4d, 0x4d, 0x43, 0x28, 0xac,
        0x3a, 0x4c, 0xee, 0x33, 0x5d, 0xf1, 0x21, 0x0d, 0xd4, 0xfc, 0x9e, 0x23,
        0xf0, 0x29, 0xd8, 0xf6, 0x55, 0x66, 0x36, 0x1a, 0x29, 0x7a, 0x6d, 0x33,
        0x2f, 0x0d, 0x30, 0x72, 0xf8, 0xb4, 0x2b, 0x7f, 0xe9, 0x61, 0x75, 0x49,
        0xdd, 0xfd, 0x3b, 0x2c, 0x29, 0xdf, 0x7b, 0xb1, 0x96, 0x32, 0x0c, 0x98,
        0xc4, 0x36, 0x3c, 0xd8, 0x0c, 0x82, 0xd3, 0xc7, 0xf4, 0xf0, 0xf4, 0xc4,
        0xe2, 0x7c, 0xd4, 0x56, 0xae, 0x74, 0x60, 0xfc, 0xc2, 0xe9, 0x44, 0xda,
        0xf4, 0x74, 0x12, 0x05, 0x6a, 0x4f, 0xbc, 0xba, 0xbb, 0x4c, 0x04, 0xaa,
        0x43, 0x9d, 0x50, 0x88, 0xa7, 0xa2, 0x38, 0x73, 0x5a, 0x01, 0x01, 0x40,
        0xcd, 0xd2, 0x7c, 0x79, 0xc8, 0x78, 0xdc, 0x26, 0x44, 0xe5,
        0x02, 0x03,
        0x01, 0x00, 0x01,
    };
    unsigned char sha1Hash[SHA1_HASH_SIZE];
    psPubKey_t pubKey, privKey, privKeySha384;
    psRes_t rc = PS_FAILURE;
    psRes_t tmpRc;
    const unsigned char *pPubKey = pub_key;
    psBool_t verifyResult;
    unsigned char *sigBuf, *sigBufSha384;
    psSize_t sigLen, sigLenSha384;

    /* Alloc and load the public key asset. */
    tmpRc = psRsaParseAsnPubKey(
            NULL,
            &pPubKey,
            sizeof(pub_key),
            &pubKey.key.rsa,
            sha1Hash);
    if (tmpRc != PS_SUCCESS)
    {
        goto out_fail_no_sig;
    }
    pubKey.type = PS_RSA;

    tmpRc = psVerifySig(
            NULL,
            tbs,
            sizeof(tbs),
            sig,
            sizeof(sig),
            &pubKey,
            OID_SHA256_RSA_SIG,
            &verifyResult,
            NULL);
    if (tmpRc != PS_SUCCESS || verifyResult != PS_TRUE)
    {
        printf("RSA sig ver KAT failed\n");
        goto out_fail_no_sig;
    }

    tmpRc = psVerifySig(
            NULL,
            tbs,
            sizeof(tbs),
            sig_sha384,
            sizeof(sig_sha384),
            &pubKey,
            OID_SHA384_RSA_SIG,
            &verifyResult,
            NULL);
    if (tmpRc != PS_SUCCESS || verifyResult != PS_TRUE)
    {
        printf("RSA sig ver KAT failed\n");
        goto out_fail_no_sig;
    }

    /* Load the private key for SHA-256 signatures. */
    privKey.rotSigAlg = OID_SHA256_RSA_SIG;
    rc = psParseUnknownPrivKeyMem(
            NULL,
            RSA2048KEY,
            RSA2048KEY_SIZE,
            NULL,
            &privKey);
    if (rc < 0)
    {
        printf("psParseUnknownPrivKeyMem failed: %d\n", rc);
        goto out_fail_no_sig;
    }

    /* Load the private key for SHA-384 signatures. */
    privKeySha384.rotSigAlg = OID_SHA384_RSA_SIG;
    rc = psParseUnknownPrivKeyMem(
            NULL,
            RSA2048KEY,
            RSA2048KEY_SIZE,
            NULL,
            &privKeySha384);
    if (rc < 0)
    {
        printf("psParseUnknownPrivKeyMem failed: %d\n", rc);
        goto out_fail_no_sig;
    }

    /* Create RSA-SHA256 signature. */
    rc = psSign(
            NULL,
            &privKey,
            OID_SHA256_RSA_SIG,
            tbs,
            sizeof(tbs),
            &sigBuf,
            &sigLen,
            NULL);
    if (rc != PS_SUCCESS)
    {
        printf("psSign failed: %d\n", rc);
        goto out_fail_no_sig;
    }

    /* Create RSA-SHA384 signature. */
    rc = psSign(
            NULL,
            &privKeySha384,
            OID_SHA384_RSA_SIG,
            tbs,
            sizeof(tbs),
            &sigBufSha384,
            &sigLenSha384,
            NULL);
    if (rc != PS_SUCCESS)
    {
        printf("psSign failed: %d\n", rc);
        goto out_fail_no_sig;
    }

    /* Verify the RSA-SHA256 signature we produced. */
    tmpRc = psVerifySig(
            NULL,
            tbs,
            sizeof(tbs),
            sigBuf,
            sigLen,
            &pubKey,
            OID_SHA256_RSA_SIG,
            &verifyResult,
            NULL);
    if (tmpRc != PS_SUCCESS || verifyResult != PS_TRUE)
    {
        printf("psVerifySig failed: %d\n", rc);
        goto out_fail;
    }

    /* Verify the RSA-SHA384 signature we produced. */
    tmpRc = psVerifySig(
            NULL,
            tbs,
            sizeof(tbs),
            sigBufSha384,
            sigLenSha384,
            &pubKey,
            OID_SHA384_RSA_SIG,
            &verifyResult,
            NULL);
    if (tmpRc != PS_SUCCESS || verifyResult != PS_TRUE)
    {
        printf("psVerifySig failed: %d\n", rc);
        goto out_fail;
    }

    /* KAT: verify that the RSA-SHA256 signature is as expected. */
    if (sigLen != sizeof(sig) || Memcmp(sigBuf, sig, sigLen))
    {
        printf("KAT failed\n");
        psTraceBytes("got", sigBuf, sigLen);
        psTraceBytes("expected", sig, sizeof(sig));
        goto out_fail;
    }

    /* KAT: verify that the RSA-SHA256 signature is as expected. */
    if (sigLenSha384 != sizeof(sig_sha384)
            || Memcmp(sigBufSha384, sig_sha384, sigLenSha384))
    {
        printf("KAT failed\n");
        psTraceBytes("got", sigBufSha384, sigLenSha384);
        psTraceBytes("expected", sig_sha384, sizeof(sig_sha384));
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    psFree(NULL, sigBuf);
    psFree(NULL, sigBufSha384);

out_fail_no_sig:
    psClearPubKey(&privKey);
    psClearPubKey(&privKeySha384);
    psClearPubKey(&pubKey);

    return rc;
# else
    printf("Skipped (USE_ROT_RSA disabled)\n");
    return PS_SUCCESS;
# endif /* USE_ROT_RSA */
}

psRes_t rotRSAKeyTransport(void)
{
# ifdef USE_ROT_RSA
    psRes_t rc = PS_FAILURE;
    psPubKey_t pubKey, privKey;
    unsigned char premaster[48] =  { 0xff, 0xfa, 0xfa };
    size_t premaster_len = sizeof(premaster);
    unsigned char wrapped[256];
    size_t wrapped_len = sizeof(wrapped);
    unsigned char unwrapped[48];
    size_t unwrapped_len = sizeof(unwrapped);
    unsigned char pub_key[] =
    {
        0x03, 0x82, 0x01, 0x0f, 0x00,
        0x30, 0x82, 0x01,
        0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xad, 0x6a, 0x33, 0xee, 0xa2, 0x73,
        0x6d, 0x68, 0xba, 0xbd, 0x2d, 0xb1, 0xb5, 0x54, 0xf0, 0x04, 0x14, 0xff,
        0xbd, 0xd7, 0x5b, 0x4c, 0x69, 0xe7, 0xf4, 0x66, 0x7f, 0xac, 0x06, 0xe1,
        0x95, 0x77, 0x6b, 0x9d, 0x9a, 0x1f, 0x51, 0x61, 0xe6, 0xd2, 0x92, 0x50,
        0xdc, 0x0f, 0x5d, 0x15, 0x0c, 0x9e, 0xd3, 0x37, 0xa6, 0xf9, 0x77, 0x36,
        0x76, 0x74, 0xda, 0x3f, 0x50, 0x7f, 0x9c, 0xdf, 0x52, 0xc9, 0x32, 0x4c,
        0xda, 0x22, 0x31, 0xeb, 0x94, 0xb0, 0xcf, 0x56, 0xee, 0x91, 0x86, 0x30,
        0xa9, 0x24, 0x29, 0x01, 0x2f, 0x83, 0xd1, 0x08, 0x73, 0x94, 0x97, 0xe1,
        0xdb, 0x88, 0x85, 0x3b, 0xe1, 0x46, 0x2b, 0xc5, 0xff, 0x03, 0xea, 0x7c,
        0x74, 0xa6, 0x89, 0x64, 0x41, 0xcc, 0x88, 0xe7, 0x9c, 0xaf, 0x33, 0xfb,
        0x48, 0xe7, 0x5b, 0xca, 0x6f, 0x90, 0x75, 0x7a, 0x42, 0xa2, 0xba, 0x8a,
        0x4e, 0x06, 0x38, 0x87, 0x51, 0x66, 0x96, 0xc1, 0xef, 0x8a, 0xe2, 0xb2,
        0xe7, 0x63, 0x57, 0xf4, 0xfa, 0xf8, 0xa6, 0x4d, 0x4d, 0x43, 0x28, 0xac,
        0x3a, 0x4c, 0xee, 0x33, 0x5d, 0xf1, 0x21, 0x0d, 0xd4, 0xfc, 0x9e, 0x23,
        0xf0, 0x29, 0xd8, 0xf6, 0x55, 0x66, 0x36, 0x1a, 0x29, 0x7a, 0x6d, 0x33,
        0x2f, 0x0d, 0x30, 0x72, 0xf8, 0xb4, 0x2b, 0x7f, 0xe9, 0x61, 0x75, 0x49,
        0xdd, 0xfd, 0x3b, 0x2c, 0x29, 0xdf, 0x7b, 0xb1, 0x96, 0x32, 0x0c, 0x98,
        0xc4, 0x36, 0x3c, 0xd8, 0x0c, 0x82, 0xd3, 0xc7, 0xf4, 0xf0, 0xf4, 0xc4,
        0xe2, 0x7c, 0xd4, 0x56, 0xae, 0x74, 0x60, 0xfc, 0xc2, 0xe9, 0x44, 0xda,
        0xf4, 0x74, 0x12, 0x05, 0x6a, 0x4f, 0xbc, 0xba, 0xbb, 0x4c, 0x04, 0xaa,
        0x43, 0x9d, 0x50, 0x88, 0xa7, 0xa2, 0x38, 0x73, 0x5a, 0x01, 0x01, 0x40,
        0xcd, 0xd2, 0x7c, 0x79, 0xc8, 0x78, 0xdc, 0x26, 0x44, 0xe5,
        0x02, 0x03,
        0x01, 0x00, 0x01,
    };

    /* Load the private and public keys. */
    Memset(&privKey, 0, sizeof(privKey));
    rc = psParseUnknownPrivKeyMem(
            NULL,
            RSA2048KEY,
            RSA2048KEY_SIZE,
            NULL,
            &privKey);
    if (rc < 0)
    {
        printf("psParseUnknownPrivKeyMem failed: %d\n", rc);
        goto out_fail_no_priv_key;
    }
    Memset(&pubKey, 0, sizeof(pubKey));
    rc = psParseUnknownPubKeyMem(
            NULL,
            pub_key,
            sizeof(pub_key),
            NULL,
            &pubKey);
    if (rc < 0)
    {
        printf("psParseUnknownPubKeyMem failed: %d\n", rc);
        goto out_fail_no_pub_key;
    }

    rc = psRsaEncryptPub(
            NULL,
            &pubKey.key.rsa,
            premaster,
            premaster_len,
            wrapped,
            wrapped_len,
            NULL);
    if (rc < 0)
    {
        printf("psRsaEncryptPub failed: %d\n", rc);
        goto out_fail;
    }
    wrapped_len = 256;

    rc = psRsaDecryptPriv(
            NULL,
            &privKey.key.rsa,
            wrapped,
            wrapped_len,
            unwrapped,
            unwrapped_len,
            NULL);
    if (rc < 0)
    {
        printf("psRsaDecryptPriv failed: %d\n", rc);
        goto out_fail;
    }

    if (Memcmp(premaster, unwrapped, 48))
    {
        printf("RSA key transport KAT failed\n");
        psTraceBytes("got", unwrapped, 48);
        psTraceBytes("expected", premaster, 48);
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    psClearPubKey(&pubKey);
out_fail_no_pub_key:
    psClearPubKey(&privKey);
out_fail_no_priv_key:
    return rc;
# else
    printf("Skipped (USE_ROT_RSA disabled)\n");
    return PS_SUCCESS;
# endif /* USE_ROT_RSA */
}

psRes_t rotECDHRSACertValidate(void)
{
# if defined(USE_ROT_RSA) && defined(USE_PEM_DECODE)
    psRes_t rc = PS_FAILURE;
    const char *caFile = "testkeys/ECDH_RSA/1024_ECDH-RSA_CA.pem";
    psX509Cert_t *caCert;
    const char *certFile = "testkeys/ECDH_RSA/256_ECDH-RSA.pem";
    psX509Cert_t *cert;
    psX509Cert_t *foundIssuer;

    rc = psX509ParseCertFile(
            NULL,
            certFile,
            &cert,
            CERT_STORE_UNPARSED_BUFFER);
    if (rc < 0)
    {
        printf("psX509ParseCertFile failed: %d\n", rc);
        goto out_fail_no_certs;
    }

    rc = psX509ParseCertFile(
            NULL,
            caFile,
            &caCert,
            CERT_STORE_UNPARSED_BUFFER);
    if (rc < 0)
    {
        printf("psX509ParseCertFile failed: %d\n", rc);
        goto out_fail_no_ca_cert;
    }

    rc = psX509AuthenticateCert(
            NULL,
            cert,
            caCert,
            &foundIssuer,
            NULL,
            NULL);
    if (rc != PS_SUCCESS || cert->authStatus != PS_CERT_AUTH_PASS)
    {
        printf("psX509AuthenticateCert failed: %d\n", rc);
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    psX509FreeCert(caCert);
out_fail_no_ca_cert:
    psX509FreeCert(cert);
out_fail_no_certs:
    return rc;
# else
    printf("Skipped (USE_ROT_RSA or USE_PEM_DECODE disabled)\n");
    return PS_SUCCESS;
# endif /* USE_ROT_RSA && USE_PEM_DECODE */
}

psRes_t rotSha256KAT1(void)
{
    unsigned char tbs[] = { 'a', 'b', 'c' };
    size_t tbs_len = sizeof(tbs);
    unsigned char expect[] =
    {
        0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea, 0x41, 0x41, 0x40, 0xde,
        0x5d, 0xae, 0x22, 0x23, 0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,
        0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad
    };
    size_t expect_len = sizeof(expect);
    unsigned char out[sizeof(expect)] = {0};
    psSha256_t ctx;
    psRes_t rc = PS_FAILURE;

    rc = psSha256Init(&ctx);
    if (rc != PS_SUCCESS)
    {
        goto out_fail;
    }

    psSha256Update(&ctx, tbs, tbs_len);
    psSha256Final(&ctx, out);

    if (Memcmp(out, expect, expect_len))
    {
        printf("SHA-256 KAT failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    return rc;
}

psRes_t rotSha256KAT2(void)
{
    unsigned char tbs[] =
    {
        0xb6, 0x9c, 0xa9, 0x5a, 0xd3, 0x8b, 0x41, 0x48, 0x15, 0xee, 0xf5, 0x7a,
        0x29, 0x02, 0xe2, 0xb8, 0x25, 0x17, 0xd5, 0x4d, 0x5c, 0xd8, 0x21, 0x37,
        0x79, 0x8a, 0xac, 0xa4, 0xd1, 0x2b, 0xd6, 0xe7, 0x5c, 0x98, 0x9f, 0xb0,
        0xc0, 0x03, 0x2d, 0x77, 0x5a, 0x78, 0x98, 0x8a, 0x50, 0x9e, 0x90, 0x6d,
        0x75, 0xad, 0x21, 0x40, 0x28, 0x6d, 0x42, 0xce, 0xfc, 0xcb, 0xbf, 0xac,
        0xab, 0xa4, 0x43, 0x90, 0x8c, 0xec, 0x66, 0xfd, 0x66, 0x80, 0xb1, 0x50,
        0xac, 0x37, 0x8b, 0x77, 0x80, 0xd6, 0xee, 0x28, 0xaa, 0x2c, 0x78, 0xd0,
        0xa3, 0xb0, 0x6b, 0x5f, 0xf1, 0x2b, 0xd2, 0x28, 0x24, 0x43, 0xaf, 0xae,
        0x94, 0x7f, 0x81, 0x6c, 0xbb, 0xa1, 0xa7, 0x69, 0xdd, 0xca, 0xef, 0xe8,
        0xa8, 0x36, 0xf9, 0x6d, 0x92, 0xd6, 0x3c, 0xd8, 0x64, 0x38, 0xa3, 0xa8,
        0xe8, 0x96, 0xc3, 0xef, 0x60, 0x40, 0x7f, 0x1c, 0x1d, 0x3e
    };
    size_t tbs_len = sizeof(tbs);
    unsigned char expect[] =
    {
        0x76, 0x2d, 0x44, 0xb4, 0xc0, 0xd4, 0xf6, 0xa0, 0xbd, 0xdb, 0x3d, 0x09,
        0x3a, 0xbc, 0x1d, 0x55, 0xfd, 0x96, 0xbc, 0x5a, 0xe8, 0x5d, 0xea, 0x1b,
        0xe9, 0x38, 0x55, 0xb1, 0xe8, 0x97, 0x62, 0x8b
    };
    size_t expect_len = sizeof(expect);
    unsigned char out[sizeof(expect)] = {0};
    psDigestContext_t ctx;
    psRes_t rc = PS_FAILURE;
    size_t hashed_len, n_to_hash;

    /* Test 1: call update separately on each input octet. */
    rc = psHashInit(&ctx, OID_SHA256_ALG, NULL);
    if (rc != PS_SUCCESS)
    {
        goto out_fail;
    }
    hashed_len = 0;
    n_to_hash = 1;
    while (hashed_len < tbs_len)
    {
        psHashUpdate(&ctx, tbs + hashed_len, n_to_hash);
        hashed_len += n_to_hash;
    }
    psHashFinal(&ctx, out);
    if (Memcmp(out, expect, expect_len))
    {
        printf("SHA-256 KAT failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    /* Test 2: input sizes 64, 32, 16, 8, 4, 2, 1, 3. */
    rc = psHashInit(&ctx, OID_SHA256_ALG, NULL);
    if (rc != PS_SUCCESS)
    {
        goto out_fail;
    }
    hashed_len = 0;
    n_to_hash = 64;
    while (n_to_hash >= 1 && hashed_len < tbs_len)
    {
        psHashUpdate(&ctx, tbs + hashed_len, n_to_hash);
        hashed_len += n_to_hash;
        n_to_hash /= 2;
    }
    psHashUpdate(&ctx, tbs + hashed_len, 3);
    hashed_len += 3;
    psAssert(hashed_len == sizeof(tbs));
    psHashFinal(&ctx, out);
    if (Memcmp(out, expect, expect_len))
    {
        printf("SHA-256 KAT failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    return rc;
}

psRes_t rotSha256KAT3(void)
{
    unsigned char tbs[] =
    {
        0xb1, 0x57, 0x56, 0x2b, 0x9a, 0xaf, 0x37, 0x38, 0x65, 0x0d, 0x2f, 0x7a,
        0xb2, 0xb6, 0x17, 0xc1, 0x98, 0x1f, 0x21, 0xa3, 0x5e, 0xbf, 0x70, 0xf9,
        0xcf, 0x08, 0x04, 0x8c, 0x49, 0x9b, 0x81, 0x8a, 0x5e, 0x8a, 0x36, 0x38,
        0xa1, 0x75, 0xe2, 0xcb, 0x01, 0xb6, 0x4a, 0x3c, 0x20, 0x4b, 0x84, 0x38,
        0x75, 0xb5, 0x97, 0xda, 0x03, 0x50, 0x92, 0x20, 0xd0, 0x2e, 0xea, 0x73,
        0xf6, 0x4c, 0xb3, 0xaf, 0x4c, 0xdf, 0xe6, 0xe2, 0xe4, 0x08, 0x35, 0x8c,
        0x41, 0xba, 0x7e, 0x39, 0x6d, 0x0f, 0xf4, 0x78, 0x05, 0xc9, 0xdc, 0x4a,
        0x18, 0xdd, 0xa7, 0xdb, 0x86, 0x7e, 0xd3, 0x76, 0x8d, 0x10, 0xba, 0xa4,
        0x8d, 0x96, 0x59, 0x06, 0x1d, 0x1a, 0x7f, 0x9e, 0x61, 0x86, 0xd2, 0x30,
        0x47, 0x01, 0x33, 0x82, 0xed, 0x16, 0x06, 0x92, 0x15, 0xeb, 0xce, 0xd2,
        0x7e, 0x80, 0x2f, 0x3f, 0x79, 0xe4, 0xf9, 0x68, 0x7e, 0xa3, 0x59, 0x50,
        0xce, 0x80, 0x89, 0xea, 0x4a, 0xf4, 0xed, 0xe9, 0x26, 0x22, 0x1e, 0x72,
        0xb0, 0x42, 0x03, 0x50, 0xdb, 0xe9, 0x51, 0xd1, 0x10, 0x6c, 0xa1, 0x4c,
        0xc8, 0x52, 0x5a, 0x37, 0x1a, 0xca, 0x10, 0xfb, 0x63, 0x16, 0x94, 0x61,
        0x42, 0xf5, 0xf8, 0xfd, 0x57, 0x4f, 0x35, 0xbb, 0xac, 0x17, 0x11, 0xc4,
        0xcf, 0x14, 0x5b, 0xb0, 0x3a, 0xfd, 0x72, 0x8a, 0xfa, 0xfa, 0x56, 0x86,
        0x84, 0xda, 0x11, 0x39, 0x99, 0x33, 0x75, 0x7d, 0xca, 0x39, 0xc0, 0x4c,
        0x02, 0x99, 0xbc, 0x93, 0x37, 0xe6, 0xfa, 0xa1, 0x58, 0x4a, 0xeb, 0xca,
        0x8e, 0xa4, 0x2f, 0xd9, 0x44, 0x90, 0xb6, 0x1f, 0x2f, 0x43, 0x55, 0x12,
        0xe9, 0xd8, 0x43, 0x9e, 0x28, 0x85, 0x59, 0x01, 0x7a, 0x7d, 0x54, 0x85,
        0x9e, 0x2b, 0xc8, 0x3b, 0xa5, 0xc6, 0x05, 0x51, 0x0f, 0x58, 0x90, 0x15,
        0xfc, 0x34, 0xfa, 0xbc
    };
    size_t tbs_len = sizeof(tbs);
    unsigned char expect[] =
    {
        0x48, 0x3d, 0xca, 0xfd, 0x75, 0x41, 0xe6, 0x64, 0x2f, 0x6f, 0x23, 0x0c,
        0x9a, 0x7e, 0x02, 0xea, 0x37, 0xf9, 0xea, 0xde, 0xf6, 0x14, 0xe0, 0x25,
        0x18, 0x55, 0xda, 0x1c, 0x5a, 0x1e, 0x23, 0x3f
    };
    size_t expect_len = sizeof(expect);
    unsigned char out[sizeof(expect)] = {0};
    psSha256_t ctx;
    psRes_t rc = PS_FAILURE;

    /* Note: Input vector length is a multiple of SHA-256 block size.
       Process it all at once.
       No buffering should be needed in this case. */
    rc = psSha256Init(&ctx);
    if (rc != PS_SUCCESS)
    {
        goto out_fail;
    }

    psSha256Update(&ctx, tbs, tbs_len);
    psSha256Final(&ctx, out);
    if (Memcmp(out, expect, expect_len))
    {
        printf("SHA-256 KAT failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    return rc;
}

psRes_t rotSha384KAT1(void)
{
    unsigned char tbs[] = { 'a', 'b', 'c' };
    size_t tbs_len = sizeof(tbs);
    unsigned char expect[] =
    {
        0xcb, 0x00, 0x75, 0x3f, 0x45, 0xa3, 0x5e, 0x8b, 0xb5, 0xa0, 0x3d, 0x69,
        0x9a, 0xc6, 0x50, 0x07, 0x27, 0x2c, 0x32, 0xab, 0x0e, 0xde, 0xd1, 0x63,
        0x1a, 0x8b, 0x60, 0x5a, 0x43, 0xff, 0x5b, 0xed, 0x80, 0x86, 0x07, 0x2b,
        0xa1, 0xe7, 0xcc, 0x23, 0x58, 0xba, 0xec, 0xa1, 0x34, 0xc8, 0x25, 0xa7
    };
    size_t expect_len = sizeof(expect);
    unsigned char out[sizeof(expect)] = {0};
    psDigestContext_t ctx;
    psRes_t rc = PS_FAILURE;

    rc = psHashInit(&ctx, OID_SHA384_ALG, NULL);
    if (rc != PS_SUCCESS)
    {
        goto out_fail;
    }

    psHashUpdate(&ctx, tbs, tbs_len);
    psHashFinal(&ctx, out);

    if (Memcmp(out, expect, expect_len))
    {
        printf("SHA-384 KAT failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    return rc;
}

psRes_t rotSha512KAT1(void)
{
    unsigned char tbs[] = { 'a', 'b', 'c' };
    size_t tbs_len = sizeof(tbs);
    unsigned char expect[] =
    {
        0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba, 0xcc, 0x41, 0x73, 0x49,
        0xae, 0x20, 0x41, 0x31, 0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2,
        0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a, 0x21, 0x92, 0x99, 0x2a,
        0x27, 0x4f, 0xc1, 0xa8, 0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,
        0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e, 0x2a, 0x9a, 0xc9, 0x4f,
        0xa5, 0x4c, 0xa4, 0x9f
    };
    size_t expect_len = sizeof(expect);
    unsigned char out[sizeof(expect)] = {0};
    psDigestContext_t ctx;
    psRes_t rc = PS_FAILURE;

    rc = psHashInit(&ctx, OID_SHA512_ALG, NULL);
    if (rc != PS_SUCCESS)
    {
        goto out_fail;
    }

    psHashUpdate(&ctx, tbs, tbs_len);
    psHashFinal(&ctx, out);

    if (Memcmp(out, expect, expect_len))
    {
        printf("SHA-512 KAT failed\n");
        rc = PS_FAILURE;
        goto out_fail;
    }

    rc = PS_SUCCESS;

out_fail:
    return rc;
}

int main(int argc, char **argv)
{
    psRes_t rc;

    if (getenv("ABORT_ON_FIRST_FAIL"))
    {
        g_abort_on_first_fail = 1;
    }

    /* The psCryptoOpen call is needed to pre-load the supported ECC
       curve domain assets. */
    rc = psCryptoOpen(PSCRYPTO_CONFIG);
    if (rc < 0)
    {
        printf("psCryptoOpen failed: %d\n", rc);
        return EXIT_FAILURE;
    }
    TEST(rotVersion);
    TEST(rotState);
    TEST(rotConfigTrng);
    TEST(rotLoadEcCurve);
    TEST(ecdsaWithP256);
    TEST(ecdsaWithP384);
    TEST(ecdsaWithP521);
    TEST(rotLoadEcPub);
    TEST(rotGenSharedP256);
    TEST(rotGenSharedP384);
    TEST(rotGenSharedP521);
    TEST(rotEcdheGenKeyP256);
    TEST(rotEcdheGenKeyP384);
    TEST(rotEcdheGenKeyP521);
    TEST(rotGCM);
    TEST(rotGCMPairwise);
    TEST(rotGCMKAT1);
    TEST(rotGCMKAT2);
    TEST(rotHmacKAT1);
    TEST(rotHmacKAT2);
    TEST(rotRandom);
    TEST(rotRSAVerify);
    TEST(rotECDHRSACertValidate);
    TEST(rotSha256KAT1);
    TEST(rotSha256KAT2);
    TEST(rotSha256KAT3);
    TEST(rotRSAKeyTransport);
    TEST(rotSha384KAT1);
    TEST(rotSha512KAT1);

    psCryptoClose();

    printf("%d failures in %d tests\n", num_fails, num_tests);
    if (num_fails == 0)
    {
        printf("All OK\n");
        return 0;
    }
    else
    {
        printf("Some tests failed\n");
        return EXIT_FAILURE;
    }
}
# else
int main(int argc, char **argv)
{
    printf("This test requires USE_ROT_CRYPTO and USE_ROT_ECC\n");

    return EXIT_FAILURE;
}
# endif
