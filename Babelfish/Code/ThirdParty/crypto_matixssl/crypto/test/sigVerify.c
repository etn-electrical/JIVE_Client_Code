/**
 *      @file    sigVerify.c
 *
 *
 *      Test sign and verify with RSA and ECC keys.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "osdep_stdio.h"
#include "crypto/cryptoImpl.h"

#ifdef USE_CERT_GEN
/******************************************************************************/
/*
    Main
 */

# define KEY_ITER    100 /* Number of keys to generate/try per keysize */
# define SIG_ITER    100 /* Number of signatures per key */
/* #define MD5SHA1_HASH_ONLY */

int main(int argc, char **argv)
{
    psPool_t *pool;
    psRsaKey_t *privkey;
    psRsaKey_t pubkey;
    psSize_t hashlen, siglen, keysize;
    uint32_t i, j;
    unsigned char hash[MAX_HASH_SIZE];
    unsigned char hashout[MAX_HASH_SIZE];
    unsigned char sig[512];     /* 4096 bits */
    int32_t rc;

    pool = NULL;
    if (psCryptoOpen(PSCRYPTO_CONFIG) < PS_SUCCESS)
    {
        _psTrace("Failed to initialize library:  psCryptoOpen failed\n");
        return -1;
    }

    _psTrace("STARTING SIGVERIFY\n");

    for (keysize = 1024; keysize <= 2048; keysize *= 2)
    {
        _psTraceInt("Testing %d bit RSA signatures\n", keysize);
        for (i = 0; i < KEY_ITER; i++)
        {
            _psTrace("K");
            if (psRsaMakeKey(pool, keysize, 65537, &privkey) < 0)
            {
                _psTrace("psRsaMakeKey FAILED\n");
                goto err;
            }
            if (psRsaInitKey(pool, &pubkey) < 0 ||
                pstm_init_copy(pool, &pubkey.N, &privkey->N, 0) != PSTM_OKAY ||
                pstm_init_copy(pool, &pubkey.e, &privkey->e, 0) != PSTM_OKAY)
            {
                _psTrace("psRsaInitKey FAILED\n");
                goto err;
            }
            pubkey.size = pstm_unsigned_bin_size(&pubkey.N);
            siglen = keysize / 8;
            for (j = 0; j < SIG_ITER; j++)
            {
                for (hashlen = MD5SHA1_HASHLEN; hashlen <= SHA384_HASHLEN; )
                {
                    if (psGetEntropy(hash, hashlen, NULL) != hashlen)
                    {
                        _psTrace("psGetEntropy FAILED\n");
                        goto err;
                    }
                    if (hashlen != MD5SHA1_HASHLEN)
                    {
                        /* TLS 1.2 style signature */
                        rc = privRsaEncryptSignedElement(pool, privkey,
                            hash, hashlen, sig, siglen, NULL);
                    }
                    else
                    {
                        /* Older TLS style signature */
                        rc = psRsaEncryptPriv(pool, privkey,
                            hash, hashlen, sig, siglen, NULL);
                    }
                    if (rc < 0)
                    {
                        _psTraceInt("privRsaEncryptSignedElement %d FAILED\n", rc);
                        goto err;
                    }
                    if (hashlen != MD5SHA1_HASHLEN)
                    {
                        rc = pubRsaDecryptSignedElement(pool, &pubkey,
                            sig, siglen, hashout, hashlen, NULL);
                    }
                    else
                    {
                        rc = psRsaDecryptPub(pool, &pubkey,
                            sig, siglen, hashout, hashlen, NULL);
                    }
                    if (rc < 0)
                    {
                        _psTraceInt("privRsaDecryptSignedElement %d FAILED\n", rc);
                        goto err;
                    }
                    if (memcmpct(hash, hashout, hashlen) != 0)
                    {
                        _psTrace("Signature compare FAILED\n");
                        goto err;
                    }
                    memzero_s(sig, sizeof(sig));
                    memzero_s(hash, sizeof(hash));
                    memzero_s(hashout, sizeof(hashout));
                    if (hashlen == MD5SHA1_HASHLEN)
                    {
                        _psTrace("5");
# ifdef MD5SHA1_HASH_ONLY
                        break;
# else
                        hashlen = SHA1_HASHLEN;
# endif
                    }
                    else if (hashlen == SHA1_HASHLEN)
                    {
                        _psTrace("1");
                        hashlen = SHA256_HASHLEN;
                    }
                    else if (hashlen == SHA256_HASHLEN)
                    {
                        _psTrace("2");
                        hashlen = SHA384_HASHLEN;
                    }
                    else
                    {
                        _psTrace("3");
                        break;
                    }
                } /* hashlen */
            }     /* SIG_ITER */
            psRsaClearKey(privkey);
            psFree(privkey, pool);
            psRsaClearKey(&pubkey);
            Fflush(stdout);
        } /* KEY_ITER */
        _psTrace("\n");
    }     /* keysize */
err:
    _psTraceInt("Tested %d Keys for each key size and ", i);
    _psTraceInt("%d Signatures in each hash size\n", j);
    _psTraceStr("FINISHED SIGVERIFY\n", NULL);

    psCryptoClose();
    return 0;

}

#else

# include "osdep_stdio.h"
int main(void)
{
    Fprintf(stderr, "Enable USE_CERT_GEN!\n");
    return 2;
}

#endif
