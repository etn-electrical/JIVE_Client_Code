/**
 *      @file    prfRot.c
 *
 *
 *      TLS 1.2 PRF implementation using RoT.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "matrixsslImpl.h"

# ifdef USE_ROT_TLS12_PRF

# ifndef DEBUG_PRF_ROT
/* #  define DEBUG_PRF_ROT */ /* Enable debug prints. */
# endif

 /* Maximal seed is: "server finished" || client_random || server_random */
# define MAX_SEED_LEN 79

int32_t prf2(
        const unsigned char *sec,
        psSize_t secLen,
        const unsigned char *seed,
        psSize_t seedLen,
        unsigned char *out,
        psSize_t outLen,
        uint32_t flags)
{
    unsigned char prevA[MAX_SEED_LEN];
    unsigned char currA[SHA384_HASH_SIZE + MAX_SEED_LEN];
    unsigned char *pOut = out;
    unsigned char *hmacKey;
    psSize_t hmacKeyLen;
    unsigned char hmacOut[SHA384_HASH_SIZE];
    int32_t rc;
    psSize_t lenA, hashOutSize, neededNBytes, copyNBytes;
    psHmac_t ctx;

    Memset(&ctx, 0, sizeof(ctx));

# ifdef DEBUG_PRF_ROT
    psTraceBytes("prf2 sec", sec, secLen);
    psTraceBytes("prf2 seed", seed, seedLen);
# endif

    if (outLen > SSL_MAX_KEY_BLOCK_SIZE)
    {
        psTraceErrr("Too large outLen in prf2\n");
        return PS_ARG_FAIL;
    }
    if (seedLen > MAX_SEED_LEN)
    {
        psTraceErrr("Too large seed in prf2\n");
        return PS_ARG_FAIL;
    }

    /* Setup the parameters of the hash algorithm. */
    hashOutSize = SHA256_HASH_SIZE;
    ctx.type = HMAC_SHA256;
# ifdef USE_HMAC_SHA384
    if (flags & CRYPTO_FLAGS_SHA3)
    {
        hashOutSize = SHA384_HASH_SIZE;
        ctx.type = HMAC_SHA384;
    }
# endif /* USE_HMAC_SHA384 */

    /* The input secret is const, so make a copy.*/
    hmacKey = psMalloc(NULL, secLen);
    if (hmacKey == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memcpy(hmacKey, sec, secLen);
    hmacKeyLen = secLen;

# ifdef DEBUG_PRF_ROT
    psTraceBytes("prf2 hmac key", hmacKey, hmacKeyLen);
# endif

    /*
      P_hash(secret, seed) = HMAC_hash(secret, A(1) || seed) ||
                             HMAC_hash(secret, A(2) || seed) ||
                             HMAC_hash(secret, A(3) || seed) || ...
      A(0) = seed
      A(i) = HMAC_hash(secret, A(i-1))
    */

    /* A(0) = seed */
    Memcpy(prevA, seed, seedLen);
    lenA = seedLen;
# ifdef DEBUG_PRF_ROT
    psTraceBytes("A(0)", prevA, seedLen);
# endif

    while (pOut - out < outLen)
    {
        /*
          For this iteration:
          Precond: prevA == A(i-1)
          Postconds:
          prevA == A(i)
          out = out || HMAC_hash(secret, A(i) || seed)
          Where in the last step, we append as many bytes as are
          still needed.
        */

        /* A(i) = HMAC_hash(secret, A(i-1)) */
        rc = psHmacSingle(&ctx,
                ctx.type,
                hmacKey,
                hmacKeyLen,
                prevA,
                lenA,
                currA);
        if (rc < 0)
        {
            psFree(hmacKey, NULL);
            return rc;
        }

# ifdef DEBUG_PRF_ROT
        psTraceBytes("A(i)", currA, hashOutSize);
# endif

        /* Compute A(i) || seed. */
        Memcpy(currA + hashOutSize, seed, seedLen);

        /* Compute HMAC_hash(secret, A(i) || seed) */
        rc = psHmacSingle(&ctx,
                ctx.type,
                hmacKey,
                hmacKeyLen,
                currA,
                hashOutSize + seedLen,
                hmacOut);
        if (rc < 0)
        {
            psFree(hmacKey, NULL);
            return rc;
        }

        /* Append result to out. */
        neededNBytes = outLen - (pOut - out);
        if (hashOutSize < neededNBytes)
        {
            copyNBytes = hashOutSize;
        }
        else
        {
            copyNBytes = neededNBytes;
        }
        Memcpy(pOut, hmacOut, copyNBytes);
        pOut += copyNBytes;

        /* prevA := currA. */
        Memcpy(prevA, currA, hashOutSize);
        lenA = hashOutSize;
    }

# ifdef DEBUG_PRF_ROT
    psTraceBytes("prf2 out", out, outLen);
# endif

    psFree(hmacKey, NULL);

    return outLen;
}
# endif
