/**
 *      @file    psmalloc.c
 *
 *
 *      Highly optimised malloc implementation designed for low memory environments.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "coreApi.h"
#include "osdep.h"

# ifdef PSTM_64BIT
/** Round addresses up to nearest 32 byte boundary, sizes to 16 bytes */
#  define ROUNDUPADDR(x)  (void *) (((uint64) (x) + 31) & ~(uint64) 31)
#  define ROUNDUPSIZE(x)  (uint32) (((uint32) (x) + 15) & ~(uint32) 15)
# else
/** Round addresses up to nearest 32 byte boundary, sizes to 8 bytes */
#  define ROUNDUPADDR(x)  (void *) (((uint32) (x) + 31) & ~(uint32) 31)
#  define ROUNDUPSIZE(x)  (uint32) (((uint32) (x) + 7) & ~(uint32) 7)
# endif

# ifndef MEM_CAPTURE
#  define psFreeInternal  psFree
# else
static void psFreeInternal(void *ptr, psPool_t *allocPool);

void psFree(void *ptr, psPool_t *allocPool)
{
    psMemHeader_t *hdr;
    psPool_t *pool;

    if (ptr == NULL)
    {
        return;
    }
    hdr = ptr;
    hdr--;
    /* pPrev is overloaded to hold the pool pointer in allocated blocks */
    pool = (psPool_t *) hdr->List.pPrev;
    if (pool != MATRIX_NO_POOL && pool->flags & POOL_FLAGS_CAPTURE)
    {
        psTraceIntCore("F %lu\n", (char *) ptr - (char *) pool);
    }

    psAssert(pool == allocPool);

    psFreeInternal(ptr, pool);
}
# endif

/******************************************************************************/
/*
    Allocates memory aligned and sized to 32 bytes, with 32 bytes of trailing
        padding.
    Similar to the 'memalign()' api on some systems
    Typically this is used to allocate memory buffers that must be cache
        aligned for use across DMA or SMP processors.
    'memptr' returns an aligned pointer into the allocated memory.
    'trueptr' returns a ptr to the actual malloc'd address that free or realloc
        is to be called with.
    On success, the actual number of bytes allocated is returned
    On failure (rc < 0), PS_MEM_FAIL is returned and *memptr = NULL
 */
int32 psMallocAlign(psPool_t *pool, unsigned char **memptr,
    unsigned char **trueptr, size_t size)
{
    unsigned char *p;
    int32 newsize;

    psAssert(size > 0);
    newsize = size + 64;
    if ((p = psMalloc(pool, (uint32) newsize)) == NULL)
    {
        *memptr = NULL;
        return PS_MEM_FAIL;
    }
    *memptr = ROUNDUPADDR(p);
    *trueptr = p;
    return newsize;
}

int32 psReallocAlign(unsigned char **memptr, unsigned char **trueptr,
    size_t size, psPool_t *pool)
{
    unsigned char *p;
    uint32 newoffset, oldoffset;

    oldoffset = *memptr - *trueptr;
    if ((p = psRealloc(*trueptr, size + 64, pool)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    *memptr = ROUNDUPADDR(p);
    newoffset = *memptr - p;
    *trueptr = p;
    /* Unfortunately, we may have to move the memory to the apparent mem loc */
    if (newoffset != oldoffset)
    {
        Memmove(*memptr, *trueptr + oldoffset, size);
    }
    return size;
}

# ifdef USE_MATRIX_MEMORY_MANAGEMENT
/******************************************************************************/

#  ifdef MEM_STATS
static void memStrDebugMsg(int32 level, char *message, char *arg);
static void memIntDebugMsg(int32 level, char *message, int32 arg);
static void memPtrDebugMsg(int32 level, char *message, void *value);
#  else
#   define memStrDebugMsg(l, x, y)
#   define memIntDebugMsg(l, x, y)
#   define memPtrDebugMsg(l, x, y)
#  endif /* MEM_STATS */

#  define GETNEXTBLOCK(p) (p->nlen > 0 ? \
                           (psMemHeader_t *) ((unsigned char *) p + p->nlen) : NULL)
#  define GETPREVBLOCK(p) (p->plen > 0 ? \
                           (psMemHeader_t *) ((unsigned char *) p - p->plen) : NULL)

static void *g_heap = NULL;
static unsigned int g_heapLimit = 0;
static psPool_t *g_pool = NULL;

/******************************************************************************/
/*
    Define a heap pointer and size, from which to allocate pools and memory
    Useful on systems with no malloc implementation
    If a heap is defined, system malloc, et al. are not referenced
    Should be called before psOpenMalloc if system malloced pools are
        not to be used
    'heap' is a pointer to static or dynamic memory to be used for all allocs
    'bytes' is maximum total heap size in bytes (including psMalloc overhead)
    We could have added these to psOpenMalloc, but that would require a
        subsequent change in the matrixSslOpen API, which we avoid
 */
void psDefineHeap(void *heap, int32 bytes)
{
    /* Assert initial conditions, and that we are not called twice */
    psAssert(g_heap == NULL && g_pool == NULL && g_heapLimit == 0);
    g_heap = heap;
    g_heapLimit = bytes;
}

/******************************************************************************/
/*
    Initialize memory allocation module
 */
int32 psOpenMalloc(void)
{
    if (g_heap)
    {
        psAssert(g_heapLimit > 0);
        if ((g_pool = psOpenPool("G_HEAP", g_heapLimit, POOL_TYPE_STATIC,
                 g_heap, NULL)) == NULL)
        {
            return PS_MEM_FAIL;
        }
    }
    return PS_SUCCESS;
}

/******************************************************************************/
/*
    One time close.
 */
void psCloseMalloc(void)
{
    if (g_pool)
    {
        psAssert(g_heap != NULL && g_heapLimit != 0);
        psClosePool(g_pool);
    }
    return;
}

/******************************************************************************/
/*
    Create a new memory pool.  Uses the system malloc unless otherwise
    modified to gather pools from

    type
        0 or POOL_TYPE_MALLOC for standard use
        POOL_TYPE_STATIC for static pool with valid staticAddr
 */
psPool_t *psOpenPool(char *name, uint32 size, int32 type, void *staticAddr,
    void *userPtr)
{
    psPool_t *pool;
    psMemHeader_t *p;
    uint32 psPoolTypeSize, i;

    memIntDebugMsg(3, "Called psOpenPool(%d)\n", (int32) size);
    memStrDebugMsg(1, "Called psOpenPool(%s)\n", name);


    psPoolTypeSize = ROUNDUPSIZE(sizeof(psPool_t));
    if (size < MIN_BLOCK_SIZE)
    {
        size = MIN_BLOCK_SIZE;
    }
    else
    {
        size = ROUNDUPSIZE(size);
    }
#  ifndef USE_LARGE_POOLS
    /* Enforce 64K size limit if not using large pools */
    if (size > 0xFFFF)
    {
        psError("Define USE_LARGE_POOLS to enable pools larger than 64KB\n");
        return NULL;
    }
#  endif
    /* Pool must be large enough to hold overhead and a minimal block */
    if (size <= (psPoolTypeSize + sizeof(psMemHeader_t) + MIN_BLOCK_SIZE))
    {
        psErrorInt("New memory pools must be larger than %d\n",
            (int32) (psPoolTypeSize + sizeof(psMemHeader_t) + MIN_BLOCK_SIZE));
        return NULL;
    }
    if (g_pool)
    {
        /* Enforce maximum of one static pool if we have a global pool */
        /* Other pools should be defined within g_pool in this case */
        if (type == POOL_TYPE_STATIC)
        {
            psError("Cannot define multiple static pools.\n");
            return NULL;
        }
        /* Make sure we can fit this new pool in the heap */
        if ((int) size > g_pool->remaining)
        {
            psErrorInt("Out of memory for new pool, %d needed\n",
                (int) size - g_pool->remaining);
            return NULL;
        }
    }

    if (type == POOL_TYPE_MALLOC)
    {
        if (g_pool)
        {
            /* If a heap is defined, carve the pool off it */
            if ((pool = psMalloc(g_pool, size)) == NULL)
            {
                psError("Platform memory allocation failed\n");
                return NULL;
            }
            Memset(pool, 0x0, psPoolTypeSize);
            pool->type = POOL_TYPE_HEAP;
        }
        else
        {
#  ifdef USE_SYSTEM_MALLOC
            /* Allocate the pool from system memory */
            if ((pool = sysMalloc(size)) == NULL)
            {
                psError("Platform memory allocation failed\n");
                return NULL;
            }
            Memset(pool, 0x0, psPoolTypeSize);
            pool->type = POOL_TYPE_MALLOC;
#  else
            /* Can't get a pool without a heap or system malloc! */
            psError("USE_SYSTEM_MALLOC or psSetHeap Undefined\n");
            return NULL;
#  endif
        }
    }
    else
    {
        if (staticAddr == NULL)
        {
            psTraceCore("POOL_TYPE_STATIC passed as type with NULL staticAddr\n");
            return NULL;
        }
        pool = (psPool_t *) staticAddr;
        Memset(pool, 0x0, psPoolTypeSize);
        pool->type = POOL_TYPE_STATIC;
    }

    for (i = 0; i < MAX_CACHE_TYPES; i++)
    {
        DLListInit(&pool->cache[i]);
        DLListInit(&pool->heap[i]);
    }

    pool->size = (size - psPoolTypeSize);

    /* We need to have a cache size == to the minimum block size because of
       the way the greater-than heaps are managed */
    psAddPoolCache(pool, MIN_BLOCK_SIZE);
    p = (psMemHeader_t *) ((unsigned char *) pool + psPoolTypeSize);
    p->size = (size - psPoolTypeSize) - sizeof(psMemHeader_t);
    p->plen = p->nlen = 0;
    p->pad = PS_MAGIC_FREED;
    if (p->size > MIN_BLOCK_SIZE)
    {
        DLListInsertHead(&pool->heap[0], &p->List);
    }
    else
    {
        DLListInsertHead(&pool->cache[0], &p->List);
    }
    pool->remaining = p->size + sizeof(psMemHeader_t);
#  ifdef MEM_STATS
    pool->maxRemainder = p->size;
    if (name)
    {
        Strncpy(pool->name, name, sizeof(pool->name));
        pool->name[sizeof(pool->name) - 1] = '\0';
    }
    else
    {
        Snprintf(pool->name, sizeof(pool->name) - 1, "POOL_%p", pool);
    }
#  endif /* MEM_STATS */
    pool->userPtr = userPtr;
    return pool;
}

/******************************************************************************/
/*
    Close an open pool.  Does the system free unless otherwise modified.
 */
void psClosePool(psPool_t *pool)
{
    if (pool == NULL)
    {
        psTraceCore("NULL pool passed to psClosePool\n");
        return;
    }
    psAssert(pool->remaining == (int32) pool->size);
    if (pool->remaining != (int32) pool->size)
    {
        psTraceIntCore("!!! Not all pool memory freed: %d !!!\n",
            (pool->size - pool->remaining));
    }

#  ifdef MEM_STATS
    psShowPoolStats(pool);
    psAssert(pool->memAlloced == 0);
    pool->name[0] = '\0';
#  endif /* MEM_STATS */

    if (pool->type == POOL_TYPE_MALLOC)
    {
#  ifdef USE_SYSTEM_MALLOC
        sysFree(pool);
#  else
        /* Can't get a pool without a heap or system malloc! */
        psError("USE_SYSTEM_MALLOC or psSetHeap Undefined\n");
#  endif
    }
    else if (pool->type == POOL_TYPE_HEAP)
    {
        psFreeInternal(pool, pool);
    }
    else     /* POOL_TYPE_STATIC */
    {
        pool->size = 0;
    }
}

/******************************************************************************/
/*
    The type value passed in psOpenPool is not actually stored, and is actually
    one of POOL_TYPE_* values. This is due to a legacy issue where 0 may be
    passed in to indicate a pool type, precluding any other complementary
    flags to be set. This API allow setting of the actual pool->flags element
 */
void psSetPoolFlags(psPool_t *pool, int flags)
{
    if (pool == MATRIX_NO_POOL)
    {
        if (!g_pool)
        {
            return;
        }
        pool = g_pool;
    }
    pool->flags = flags;
#  ifdef MEM_CAPTURE
    if (flags & POOL_FLAGS_CAPTURE)
    {
        psTracePtrCore("MEM_CAPTURE %p\n", pool);
    }
#  endif
}

/******************************************************************************/
/*
    Note: we allow the same cache size to be added multiple times
    because the caller of this api may need this cache size, but
    be unaware it already exists.

    We return an error if we've reached the limit of MAX_CACHE_TYPES and
    a new cache cannot be added.
 */
int32 psAddPoolCache(psPool_t *pool, uint32 size)
{
    psMemHeader_t *h;
    DLListEntry *pList;
    int32 i, j;

    if (pool == MATRIX_NO_POOL)
    {
        if (!g_pool)
        {
            return PS_SUCCESS;
        }
        pool = g_pool;
    }

    memIntDebugMsg(3, "Called psAddPoolCache(%d)\n", (int32) size);
    if (size < MIN_BLOCK_SIZE)
    {
        size = MIN_BLOCK_SIZE;
    }
    else
    {
        size = ROUNDUPSIZE(size);
    }
    psAssert(size > 0);

    if (size > pool->size)
    {
        memIntDebugMsg(1, "Requested cache size %d > pool size\n",
            (int32) size);
        return PS_FAILURE;
    }

    if (pool->cacheSize[MAX_CACHE_TYPES - 1] != 0)
    {
        memIntDebugMsg(1, "MAX_CACHE_TYPES %d exceeded", MAX_CACHE_TYPES);
        return PS_FAILURE;
    }
    for (i = 0; i < MAX_CACHE_TYPES; i++)
    {
        if (pool->cacheSize[i] == 0)
        {
            break;
        }
        if (size < pool->cacheSize[i])
        {
            for (j = MAX_CACHE_TYPES - 1; j > i; j--)
            {
                pool->cacheSize[j] = pool->cacheSize[j - 1];
                if (DLListIsEmpty(&pool->cache[j - 1]))
                {
                    DLListInit(&pool->cache[j]);
                }
                else
                {
                    pool->cache[j] = pool->cache[j - 1];
                    pool->cache[j].pNext->pPrev = &pool->cache[j];
                    pool->cache[j].pPrev->pNext = &pool->cache[j];
                }
                if (DLListIsEmpty(&pool->heap[j - 1]))
                {
                    DLListInit(&pool->heap[j]);
                }
                else
                {
                    pool->heap[j] = pool->heap[j - 1];
                    pool->heap[j].pNext->pPrev = &pool->heap[j];
                    pool->heap[j].pPrev->pNext = &pool->heap[j];
                }
            }
            break;
        }
        if (pool->cacheSize[i] == size)
        {
            memIntDebugMsg(2, "Cache size already in pool: %d\n", (int32) size);
            return PS_SUCCESS;
        }
    }
    if (i == MAX_CACHE_TYPES)
    {
        i--;
    }
    pool->cacheSize[i] = size;
    DLListInit(&pool->cache[i]);
    DLListInit(&pool->heap[i]);
    /* The previous heap may have items that are >= this new cache size */
    if (i > 0)
    {
REHEAP:
        for (pList = pool->heap[i - 1].pNext; pList != &pool->heap[i - 1];
             pList = pList->pNext)
        {
            h = DLListGetContainer(pList, psMemHeader_t, List);
            if (h->size >= size)
            {
                DLListRemove(&h->List);
                h->List.pNext = NULL;
                h->List.pPrev = (void *) pool;
                h->pad = PS_MAGIC_SPLIT;     /* Indicate we're re-freeing */
                psFreeInternal(h + 1, pool); /* re-insert into the proper free list */
                /*      We do this goto here, rather than continue because removing
                    the item can cause the list to be modified in a way that
                    we can't just continue in the loop, but must start over */
                goto REHEAP;
            }
        }
    }
#  ifdef DEBUG
    for (i = 0; i < MAX_CACHE_TYPES; i++)
    {
        memIntDebugMsg(3, "Cache[%d]: ", i);
        memIntDebugMsg(3, "%4d\n", (int32) pool->cacheSize[i]);
    }
#  endif
    return PS_SUCCESS;
}

/******************************************************************************/
/*
    Matrix Malloc() Implementation

    Note: psMalloc can fail with a NULL return if no memory
    is available.  This deviates from standard malloc behavior,
    and must be handled by all callers.
 */
/*      coverity[+alloc] */
void *psMalloc(psPool_t *pool, size_t size)
{
    psMemHeader_t *p, *h = NULL, *hh;
    DLListEntry *pList;
    int32 i;

    if (size < MIN_BLOCK_SIZE)
    {
        size = MIN_BLOCK_SIZE;
    }
    else
    {
        size = ROUNDUPSIZE(size);
    }
    if (pool == MATRIX_NO_POOL)
    {
        if (g_pool)
        {
            pool = g_pool;
        }
        else
        {
#  ifdef USE_SYSTEM_MALLOC
            if ((p = sysMalloc(size + sizeof(psMemHeader_t))) == NULL)
            {
                psError("System malloc failure\n");
                return NULL;
            }
            p->List.pPrev = MATRIX_NO_POOL;
            p->size = (int32) size;
            p->plen = p->nlen = 0;
            return p + 1;
#  else
            /* Can't get a pool without a heap or system malloc! */
            psError("USE_SYSTEM_MALLOC or psSetHeap Undefined\n");
            return NULL;
#  endif
        }
    }
    /* Enforce 64K limit per pool alloc b/c defrag uses 16 bit offsets */
/*
    if (size + sizeof(psMemHeader_t) > 0xFFFF) {
        return NULL;
    }
 */
/*
    We make several attempts to allocate the memory
    1.  If there is an exact matching block size in cache[], use it
    2.  Search for the closest matching block size in sorted heap[]. Only return
        blocks smaller than the next cache size
    3.  Search all larger blocks of memory for one that fits, and if found,
        split the larger block in two.
    4.  De-fragment free memory, and if there were any block merges to >= the
        requested size, goto 1
 */
    p = NULL;
    for (i = 0; i < MAX_CACHE_TYPES; i++)
    {
        /* Is there a block on the exact-size free list?  */
        if (pool->cacheSize[i] >= size && !DLListIsEmpty(&pool->cache[i]))
        {
            pList = DLListGetHead(&pool->cache[i]);
            p = DLListGetContainer(pList, psMemHeader_t, List);
            memIntDebugMsg(3, "C memAlloced=%d", pool->memAlloced);
            break;
        }
        /* Is there a block on the larger-size free list? */
        if (pool->cacheSize[i] > size || pool->cacheSize[i] == 0)
        {
            psAssert(i > 0);
            /* First match on the sorted heap will be the best */
            for (pList = pool->heap[i - 1].pNext; pList != &pool->heap[i - 1];
                 pList = pList->pNext)
            {
                p = DLListGetContainer(pList, psMemHeader_t, List);
                if (p->size >= size)
                {
                    DLListRemove(&p->List);
                    memIntDebugMsg(3, "H memAlloced=%d", pool->memAlloced);
                    break;
                }
                p = NULL;
            }
            if (p || pool->cacheSize[i] == 0)
            {
                break;
            }
        }
    }
    /* If we don't have a valid pointer here, we're out of memory */
    if (!p)
    {
#  ifdef MEM_STATS
        psShowPoolStats(pool);
#  endif
        psErrorInt("Memory allocation failure %d bytes. Pool is full.\n",
            (int32) size);
        return NULL;
    }
/*
    If the block we got was larger than we requested, split it.
 */
    if ((p->size - size) >= (sizeof(psMemHeader_t) + MIN_BLOCK_SIZE))
    {
        h = (psMemHeader_t *) ((unsigned char *) p + sizeof(psMemHeader_t) + size);
        h->size = (p->size - size) - sizeof(psMemHeader_t);
        h->plen = size + sizeof(psMemHeader_t);
        psAssert(h->plen <= pool->size);
        if (p->nlen)
        {
            h->nlen = h->size + sizeof(psMemHeader_t);
            if ((hh = GETNEXTBLOCK(h)) != NULL)
            {
                hh->plen = h->size + sizeof(psMemHeader_t);
                psAssert(hh->plen <= pool->size);
            }
        }
        else
        {
            h->nlen = 0;
#  ifdef MEM_STATS
            /* Track the largest size of the last memory block */
            if (h->size < pool->maxRemainder)
            {
                pool->maxRemainder = h->size;
            }
#  endif
        }
        h->List.pNext = NULL;
        h->List.pPrev = (void *) pool;
        h->pad = PS_MAGIC_SPLIT;     /* Special flag to indicate split */
        psFreeInternal(h + 1, pool); /* Put the remainder block back on the free list */
        /* p is the memory we're returning to the caller */
        p->size = size;
        /* Don't need to update p->plen */
        p->nlen = p->size + sizeof(psMemHeader_t);
        memIntDebugMsg(3, "S memAlloced=%d", pool->memAlloced);
    }
    memPtrDebugMsg(3, " pool %p ", pool);
    memIntDebugMsg(3, "(+ %d)\n", (int32) size);
#  ifdef MEM_STATS
    for (i = 0; i < pool->numTypes; i++)
    {
        if (pool->blockSize[i] == size)
        {
            pool->blockCount[i]++;
            pool->blockCurr[i]++;
            if (pool->blockCurr[i] > pool->blockWater[i])
            {
                pool->blockWater[i]++;
            }
            if (h)
            {
                pool->blockSplit[i]++;
            }
            break;
        }
    }
    if (i == pool->numTypes)
    {
        if (pool->numTypes < MAX_BLOCK_STATS)
        {
            pool->blockSize[i] = size;
            pool->blockCount[i]++;
            pool->blockCurr[i]++;
            if (pool->blockCurr[i] > pool->blockWater[i])
            {
                pool->blockWater[i]++;
            }
            pool->numTypes++;
        }
        else
        {
            psAssert(pool->numTypes < MAX_BLOCK_STATS);
        }
    }
/*
    We do not count the split remainder block (h) as a block size, as it was
    not explicitly requested. We just bump up the numSplit stat.
 */
    if (h)
    {
        pool->numSplit++;
    }
    pool->memAlloced += (int32) (p->size + sizeof(psMemHeader_t));
    if (pool->memAlloced > pool->highWater)
    {
        pool->highWater = pool->memAlloced;
    }
#  endif /* MEM_STATS */
    pool->remaining -= (p->size + sizeof(psMemHeader_t));
    p->List.pNext = NULL;
    /* pPrev is overloaded to store the pool pointer for the allocated mem */
    p->List.pPrev = (void *) pool;
    p->pad = PS_MAGIC_ALLOCED;
#  ifdef MEM_CAPTURE
    if (pool->flags & POOL_FLAGS_CAPTURE)
    {
        psTraceIntCore("M %u\n", size);
    }
#  endif
    return p + 1;
}

/******************************************************************************/
/*
    Provide a single parameter, 1:1 mapping for system malloc.
    If a heap is defined via psDefineHeap, the memory will be allocated from
        the single global heap pool
    If a heap is undefined, the Malloc() system call will be used
 */
void *psMallocNoPool(size_t size)
{
    return psMalloc(MATRIX_NO_POOL, size);
}

/******************************************************************************/
/*
    Mirrors Free() functionality
    Returns immediately if ptr is NULL

    We don't need the allocPool for our implementation because we hide it
    in the memory itself.  Others who implement the interface may need it
 */
#  ifndef MEM_CAPTURE
/* coverity[+free: arg-0] */
void psFree(void *ptr, psPool_t *allocPool)
#  else
/* coverity[+free: arg-0] */
static void psFreeInternal(void *ptr, psPool_t *allocPool)
#  endif
{
    psMemHeader_t *hdr, *h;
    DLListEntry *pList;
    psPool_t *pool;
    int32 i;

    if (ptr == NULL)
    {
        return;
    }

    hdr = ptr;
    hdr--;

    /* pPrev is overloaded to hold the pool pointer in allocated blocks */
    pool = (psPool_t *) hdr->List.pPrev;

    if (g_pool == NULL)
    {
        psAssert(allocPool == pool);
    }

    if (pool == MATRIX_NO_POOL)
    {
#  ifdef USE_SYSTEM_MALLOC
        sysFree(hdr);
#  else
        /* Can't get a pool without a heap or system malloc! */
        psError("USE_SYSTEM_MALLOC or psSetHeap Undefined\n");
#  endif
        return;
    }
    psAssert(hdr->List.pNext == NULL);
    hdr->List.pNext = hdr->List.pPrev = NULL;
/*
    SPLIT indicates we're "freeing" a remainder of an allocation, so
    really we're just re-queueing a free block based on its new size,
    and we can skip a lot of work.
 */
    if (hdr->pad != PS_MAGIC_SPLIT)
    {
/*
    The pad value should indicate the block is marked as allocated
    If the value doesn't match, it may be because it was freed previously
    Alternately, if the value is neither magic flag, then either the
    pointer is invalid, or the memory block was corrupted.
    Either way, just return and "leak" the memory into the pool - don't want
    to use it again if it's being corrupted.
 */
        if (hdr->pad != PS_MAGIC_ALLOCED)
        {
            if (hdr->pad == PS_MAGIC_FREED)
            {
                psAssert(hdr->pad != PS_MAGIC_FREED);   /* Double free */
            }
            else
            {
                psAssert(hdr->pad == PS_MAGIC_ALLOCED); /* Invalid memory header */
            }
            return;
        }
#  ifdef MEM_STATS
        pool->memAlloced -= (int32) (hdr->size + sizeof(psMemHeader_t));
#  endif
        pool->remaining += (hdr->size + sizeof(psMemHeader_t));
/*
        Forward defrag by attempting to re-join the following block, if free
 */
        if ((h = GETNEXTBLOCK(hdr)) != NULL && h->pad == PS_MAGIC_FREED)
        {
            DLListRemove(&h->List);
            hdr->size += h->size + sizeof(psMemHeader_t);
            if (h->nlen)
            {
                hdr->nlen = hdr->size + sizeof(psMemHeader_t);
            }
            else
            {
                hdr->nlen = 0;
            }
            Memset(h, 0x0, sizeof(psMemHeader_t));
            /* Reset the magic value to catch double frees */
            h->pad = PS_MAGIC_FREED;
            if ((h = GETNEXTBLOCK(hdr)) != NULL)
            {
                h->plen = hdr->nlen;
                psAssert(h->plen <= pool->size);
            }
#  ifdef MEM_STATS
            pool->numMerge++;
            for (i = 0; i < pool->numTypes; i++)
            {
                if (pool->blockSize[i] == hdr->size)
                {
                    pool->blockSplit[i]--;
                    break;
                }
            }
#  endif
        }
/*
        Reverse defrag by attempting to re-join the previous block, if free
 */
        if ((h = GETPREVBLOCK(hdr)) != NULL && h->pad == PS_MAGIC_FREED &&
            GETNEXTBLOCK(h) == hdr)
        {
            h->size += hdr->size + sizeof(psMemHeader_t);
            if (hdr->nlen)
            {
                h->nlen = h->size + sizeof(psMemHeader_t);
            }
            else
            {
                h->nlen = 0;
            }
            Memset(hdr, 0x0, sizeof(psMemHeader_t));
            /* Reset the magic value to catch double frees */
            hdr->pad = PS_MAGIC_FREED;
            hdr = h;
            DLListRemove(&hdr->List);
            if ((h = GETNEXTBLOCK(hdr)) != NULL)
            {
                h->plen = hdr->size + sizeof(psMemHeader_t);
                psAssert(h->plen <= pool->size);
            }
#  ifdef MEM_STATS
            pool->numMerge++;
            for (i = 0; i < pool->numTypes; i++)
            {
                if (pool->blockSize[i] == hdr->size)
                {
                    pool->blockSplit[i]--;
                    break;
                }
            }
#  endif
        }
#  ifdef MEM_STATS
        for (i = 0; i < pool->numTypes; i++)
        {
            if (pool->blockSize[i] == hdr->size)
            {
                pool->blockCurr[i]--;
                break;
            }
        }
#  endif /* MEM_STATS */
        memPtrDebugMsg(3, " pool %p ", pool);
        memIntDebugMsg(3, "(- %d)\n", (int32) hdr->size);
    } /* !PS_MAGIC_SPLIT */
/*
    Quick lookup for cached blocks, structured for loop unrolling
    Keep CACHE_TYPES small, as this look affects all mallocs
 */
    for (i = 0; i < MAX_CACHE_TYPES; i++)
    {
        /* Push the block on the exact-size free list */
        if (pool->cacheSize[i] == hdr->size)
        {
            DLListInsertHead(&pool->cache[i], &hdr->List);
            memIntDebugMsg(3, "C memAlloced=%d", pool->memAlloced);
            break;
        }
        /* Push the block on the larger-size free list */
        if (pool->cacheSize[i] > hdr->size || pool->cacheSize[i] == 0)
        {
            psAssert(i > 0);
            /* Insert sorted from smallest to largest */
            for (pList = pool->heap[i - 1].pNext; pList != &pool->heap[i - 1];
                 pList = pList->pNext)
            {
                h = DLListGetContainer(pList, psMemHeader_t, List);
                if (h->size >= hdr->size)
                {
                    break;
                }
            }
            DLListInsertTail(pList, &hdr->List);
            memIntDebugMsg(3, "H memAlloced=%d", pool->memAlloced);
            break;
        }
    }
    psAssert(i < MAX_CACHE_TYPES);
    hdr->pad = PS_MAGIC_FREED;
}

/******************************************************************************/
/*
    Mirrors Calloc() functionality
 */
void *psCalloc(psPool_t *pool, size_t n, size_t size)
{
    void *p;

    p = psMalloc(pool, n * size);
    if (p == NULL)
    {
        return NULL;
    }
    Memset(p, 0x0, n * size);
    return p;
}

/******************************************************************************/
/*
    Mirrors Realloc() functionality, and adds zeroing the original memory
    block for better security.  Calling realloc with a null pointer will
    mirror malloc
 */
void *psRealloc(void *ptr, size_t n, psPool_t *allocPool)
{
    psMemHeader_t *hdr;
    void *p;

    if (ptr == NULL)
    {
        return psMalloc(allocPool, n);
    }
    hdr = ptr;
    hdr--;
    p = psMalloc((psPool_t *) hdr->List.pPrev, n);
    if (p == NULL)
    {
        return NULL;
    }
    Memcpy(p, ptr, min(n, hdr->size));
/*      SECURITY - We zero the old memory block here, before reuse */
    Memset(ptr, 0x0, hdr->size);

    psFree(ptr, allocPool);
    return p;
}

#  ifdef MEM_STATS
/******************************************************************************/
/*
   Standalone snapshot of pool statistics for debugging and memory profiling
 */
void psShowPoolStats(psPool_t *pool)
{
    psMemHeader_t *h;
    DLListEntry *pList;
    int32 i, j, waste;

    if (pool == NULL)
    {
        if (!g_pool)
        {
            return;
        }
        pool = g_pool;
    }
    /*  Sort the block stats by size ascending */
    for (i = pool->numTypes - 1; i > 0; i--)
    {
        for (j = i - 1; j >= 0; j--)
        {
            if (pool->blockSize[i] < pool->blockSize[j])
            {
                waste = pool->blockSize[i];
                pool->blockSize[i] = pool->blockSize[j];
                pool->blockSize[j] = waste;
                waste = pool->blockCount[i];
                pool->blockCount[i] = pool->blockCount[j];
                pool->blockCount[j] = waste;
                waste = pool->blockWater[i];
                pool->blockWater[i] = pool->blockWater[j];
                pool->blockWater[j] = waste;
                waste = pool->blockCurr[i];
                pool->blockCurr[i] = pool->blockCurr[j];
                pool->blockCurr[j] = waste;
            }
        }
    }

    if (pool->name)
    {
        memStrDebugMsg(1, "\nPool %s:\n", pool->name);
    }
    else
    {
        memPtrDebugMsg(1, "\nPool %p:\n", pool);
    }
    memIntDebugMsg(1, "  size %d\n", (int32) pool->size);
    memIntDebugMsg(1, "  remaining %d\n", pool->remaining);
    memIntDebugMsg(1, "  highWater %d\n", pool->highWater);
    memIntDebugMsg(1, "  totalUsed %d\n", (int32) pool->size - pool->remaining);
    memIntDebugMsg(1, "  numSplit %d\n", pool->numSplit);
    memIntDebugMsg(1, "  numMerge %d\n", pool->numMerge);
/*
    Display the entire free memory structure and lists.
    Blocks sizes with a ~ indicate that the size was never actually requested,
    but was the unused remainder of a split block.
    Buck coding standard a little for compactness :)
 */
    for (i = 0; i < MAX_CACHE_TYPES && pool->cacheSize[i] > 0; i++)
    {
        for (j = 0; j < pool->numTypes; j++)
        {
            if (pool->blockSize[j] == pool->cacheSize[i])
            {
                break;
            }
            if (pool->blockSize[j] > pool->cacheSize[i])
            {
                j = pool->numTypes;
            }
        }
        if (j < pool->numTypes)
        {
            psTraceIntCore("\n  Cache[%d]=", (int) pool->cacheSize[i]);
        }
        else
        {
            psTraceIntCore("\n  Cache[%d~]=", (int) pool->cacheSize[i]);
        }
        for (pList = pool->cache[i].pNext; pList != &pool->cache[i]; pList = pList->pNext)
        {
            h = DLListGetContainer(pList, psMemHeader_t, List);
            psTraceIntCore("->[%d]", (int) h->size);
        }
        psTraceIntCore("\n  Heap[>%d]=", (int) pool->cacheSize[i]);
        for (pList = pool->heap[i].pNext; pList != &pool->heap[i]; pList = pList->pNext)
        {
            h = DLListGetContainer(pList, psMemHeader_t, List);
            for (j = 0; j < pool->numTypes; j++)
            {
                if (pool->blockSize[j] == h->size)
                {
                    break;
                }
                if (pool->blockSize[j] > h->size)
                {
                    j = pool->numTypes;
                }
            }
            if (j < pool->numTypes)
            {
                psTraceIntCore("->[%d]", (int) h->size);
            }
            else
            {
                psTraceIntCore("->[%d~]", (int) h->size);
            }
        }
    }
    psTraceCore("\n");

    memStrDebugMsg(1, "                Size Split  Count  Water  \n", NULL);
    for (i = 0; i < pool->numTypes; i++)
    {
        for (j = 0; j < MAX_CACHE_TYPES; j++)
        {
            if (pool->cacheSize[j] == pool->blockSize[i])
            {
                break;
            }
        }
        waste = -1;
        if (j < MAX_CACHE_TYPES)
        {
            memIntDebugMsg(1, "  C block[%02d] ", i);
        }
        else if (pool->blockCount[i] != pool->blockWater[i])
        {
            memIntDebugMsg(1, "    block[%02d] ", i);
        }
        else
        {
            memIntDebugMsg(1, "    block[%02d] ", i);
        }
        memIntDebugMsg(1, " %5d", (int32) pool->blockSize[i]);
        memIntDebugMsg(1, " %5d", (int32) pool->blockSplit[i]);
        memIntDebugMsg(1, "  %5d", pool->blockCount[i]);
        memIntDebugMsg(1, "   %4d\n", pool->blockWater[i]);
    }
    memStrDebugMsg(1, "\nC - Cached block\n", NULL);
    memIntDebugMsg(1, "%d %% Memory in Use\n",
        100 * (int32) ((pool->size - pool->remaining) / pool->size));

    memIntDebugMsg(1, "Memory Currently In-use:  %d bytes\n", pool->memAlloced);
    memIntDebugMsg(1, "Pool potentially can be shrunk by:  %d bytes\n",
        pool->maxRemainder);
    return;
}

/******************************************************************************/
/*
   Memory trace routines supporting level parameter
 */
/* message should contain one %s if value != NULL*/
static void memStrDebugMsg(int32 level, char *message, char *value)
{
    if (level <= MEM_STATS_LEVEL)
    {
        if (value)
        {
            _psTraceStr(message, value);
        }
        else
        {
            _psTrace(message);
        }
    }
}

/* message should contain one %d */
static void memIntDebugMsg(int32 level, char *message, int32 value)
{
    if (level <= MEM_STATS_LEVEL)
    {
        _psTraceInt(message, value);
    }
}

/* message should contain one %p */
static void memPtrDebugMsg(int32 level, char *message, void *value)
{
    if (level <= MEM_STATS_LEVEL)
    {
        _psTracePtr(message, value);
    }
}
#  else
void psShowPoolStats(psPool_t *pool)
{
}
#  endif /* MEM_STATS */

# endif  /* USE_MATRIX_MEMORY_MANAGEMENT */

/******************************************************************************/

