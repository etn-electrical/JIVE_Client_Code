/**
 *      @file    rsakeygen.c
 *
 *
 *      Command line utility for PKCS#1 private key file generation..
 *
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "crypto/cryptoApi.h"
/* Currently this example uses _psTrace for tracing, so osdep.h is needed: */
#include "core/osdep.h"
#include "core/psUtil.h"

# define CL_IS_FIPS() 0

#if defined(USE_CERT_GEN) && defined(MATRIX_USE_FILE_SYSTEM)

/******************************************************************************/

const static char pemExt[4] = ".pem";
const static char derExt[4] = ".der";

/******************************************************************************/

static void usage()
{
    _psTrace("usage 1: matrixRSAkeygen -out file [-keysize bit] [-pass password]\n");
    _psTrace("usage 2: matrixRSAkeygen -out file -outform DER [-keysize bit]\n");
}

/******************************************************************************/
/*
    Main
 */
int32 main(int32 argc, char **argv)
{
    psPool_t *pool;
    const char *keyfile, *password, *outform;
    char otfKeyFile[32];
    psRsaKey_t *privkey;
    int32 keysize, tryagain, len, poolSize;
    int32 rc = PS_SUCCESS;
    uint8_t pemFlag;

    /* PEM default */
    outform = pemExt;
    pemFlag = 1;

    /* command line parse */
    keyfile = password = NULL;
    keysize = 0;
    argv++;  argc--; /* skip exe name */

    while (*argv)
    {
        if (Strcmp(*argv, "-out") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                keyfile = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-outform") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                if (Strncmp(*argv, "PEM", 3) == 0)
                {
                    outform = pemExt;
                    pemFlag = 1;
                }
                else if (Strncmp(*argv, "DER", 3) == 0)
                {
                    outform = derExt;
                    pemFlag = 0;
                }
                else
                {
                    usage();
                    return EXIT_FAILURE;
                }
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-keysize") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                keysize = atoi(*argv);
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-pass") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                password = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else
        {
            usage();
            return EXIT_FAILURE;
        }
        argv++; argc--;
    }

    /* Command line verification */
    if (!pemFlag && password != NULL)
    {
        _psTrace("Can't password protect PKCS#1 key in DER format\n");
        usage();
        return EXIT_FAILURE;
    }

    if (psCryptoOpen(PSCRYPTO_CONFIG) < PS_SUCCESS)
    {
        _psTrace("Failed to initialize library:  psCryptoOpen failed\n");
        return EXIT_FAILURE;
    }

    if (keyfile == NULL)
    {
/*
        If no file name provided, prompt for one and add the correct
        file extension if not given
 */
        tryagain = 1;
        Memset(otfKeyFile, 0x0, 32);
        while (tryagain)
        {
            _psTrace("Private key file name: ");
            if (fgets(otfKeyFile, 28, stdin) != NULL)
            {
                len = (int32) Strlen(otfKeyFile);
                if (Memcmp(&otfKeyFile[len - 5], outform, 4) != 0)
                {
                    Memcpy(&otfKeyFile[--len], outform, 4);
                }
                else
                {
                    otfKeyFile[--len] = '\0';
                }
                tryagain = 0;
            }
        }
        keyfile = otfKeyFile;
    }

    if (keysize == 0)
    {
        if (CL_IS_FIPS())
        {
            _psTrace("No key size given. Defaulting to 2048 bits\n");
            keysize = 2048;
        }
        else
        {
            _psTrace("No key size given. Defaulting to 1024 bits\n");
            keysize = 1024;
        }
    }

    pool = NULL;
    poolSize = 0;
    if (keysize == 512)
    {
        poolSize = 4 * 1024;
    }
    else if (keysize == 1024)
    {
        poolSize = 10 * 1024;
    }
    else if (keysize == 2048)
    {
        poolSize = 16 * 1024;
    }
    else if (keysize == 4096)
    {
        poolSize = 32 * 1024;
    }
    else
    {
        _psTrace("Invalid key size.  Must be 512, 1024, 2048, or 4096\n");
        rc = PS_FAILURE;
        goto err;
    }
# ifdef  USE_MATRIX_MEMORY_MANAGEMENT
    pool = psOpenPool("keygen", poolSize, 0, NULL, NULL);
# else
    /* Avoid warning regarding unused variable. */
    PS_VARIABLE_SET_BUT_UNUSED(poolSize);
# endif

    _psTraceInt("Generating %d bit RSA private key... ", keysize);
    if (psRsaMakeKey(pool, keysize, 65537, &privkey) < 0)
    {
        _psTrace("FAILED\n");
        rc = PS_FAILURE;
        goto err;
    }
    else
    {
        _psTrace("SUCCESS\n");
    }

    /* Check key length. */
    if (CL_IS_FIPS() && keysize < 2048)
    {
        _psTrace("WARNING: Generated key is below FIPS required minimum key size 2048.\n");
    }

    if (password)
    {
        _psTrace("Writing password protected private key file... ");
    }
    else
    {
        _psTrace("Writing unencrypted private key file... ");
    }
    if (psRsaWritePrivKeyFile(pool, privkey, keyfile, password, pemFlag) < 0)
    {
        _psTrace("FAILED\n");
        rc = PS_FAILURE;
        psRsaClearKey(privkey);
        psFree(privkey, pool);
        goto err;
    }
    else
    {
        _psTrace("SUCCESS\n");
    }

    psRsaClearKey(privkey);
    psFree(privkey, pool);

# ifdef TESTING
    {
        psRsaKey_t outKey;
        if (pemFlag)
        {
            if (psPkcs1ParsePrivFile(pool, keyfile, password, &outKey) < 0)
            {
                Printf("Unable to parse created key\n");
                rc = PS_FAILURE;
            }
            else
            {
                Printf("Successfully parsed created key\n");
            }
            psRsaClearKey(&outKey);
        }
    }
# endif

err:
# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
# endif
    psCryptoClose();
    if (rc == PS_SUCCESS)
    {
        return 0;
    }
    else
    {
        return EXIT_FAILURE;
    }
}

#else

/******************************************************************************/
/*
    Stub main for compiling without features enabled
 */
int32 main(int32 argc, char **argv)
{
    Printf("USE_CERT_GEN && MATRIX_USE_FILE_SYSTEM must be enabled "
        "to run this application.\n");
    return EXIT_FAILURE;
}

#endif /* USE_CERT_GEN && MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/

