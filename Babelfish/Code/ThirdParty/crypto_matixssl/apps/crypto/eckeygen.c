/**
 *      @file    eckeygen.c
 *
 *
 *      Command line utility for PKCS#1 private key file generation..
 *
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "crypto/cryptoApi.h"
/* Currently this example uses _psTrace for tracing, so osdep.h is needed: */
#include "core/osdep.h"

#if defined(USE_ECC) && defined(USE_CERT_GEN) && defined(MATRIX_USE_FILE_SYSTEM)

/******************************************************************************/

static char pemExt[4] = ".pem";
static char derExt[4] = ".der";

/******************************************************************************/

static void usage()
{
    _psTrace("usage 1: matrixECkeygen -out file -curve secp384r1 [-pass password]\n");
    _psTrace("usage 2: matrixECkeygen -out file -curve secp384r1 -outform DER\n");
}

int32 main(int32 argc, char **argv)
{
    psPool_t *pool;
    const psEccCurve_t *params;
    char *keyfile, *password, *outform, *curve;
    char otfKeyFile[32];
    psEccKey_t *privkey;
    int32 tryagain, len;
    int32 rc = PS_SUCCESS;

# ifdef  USE_MATRIX_MEMORY_MANAGEMENT
    int32 poolSize;
# endif
    uint8_t pemFlag;

    /* PEM default */
    outform = pemExt;
    pemFlag = 1;

/*
    command line parse
 */
    keyfile = password = curve = NULL;
    argv++;  argc--; /* skip exe name */

    while (*argv)
    {
        if (Strcmp(*argv, "-out") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                keyfile = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-outform") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                if (Strncmp(*argv, "PEM", 3) == 0)
                {
                    outform = pemExt;
                    pemFlag = 1;
                }
                else if (Strncmp(*argv, "DER", 3) == 0)
                {
                    outform = derExt;
                    pemFlag = 0;
                }
                else
                {
                    usage();
                    return EXIT_FAILURE;
                }
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-curve") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                curve = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-pass") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                password = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else
        {
            usage();
            return EXIT_FAILURE;
        }
        argv++; argc--;
    }

/*
    Command line verification
 */
    if (!pemFlag && password != NULL)
    {
        _psTrace("Can't password protect key in DER format\n");
        usage();
        return EXIT_FAILURE;
    }
    if (curve == NULL)
    {
        _psTrace("Must provide the -curve option (secp256r1, secp384r1...)\n");
        usage();
        return EXIT_FAILURE;
    }
    if (getEccParamByName(curve, &params) < 0)
    {
        _psTrace("Must provide the -curve option (secp256r1, secp384r1...)\n");
        usage();
        return EXIT_FAILURE;
    }
/*
    Get it going
 */
    if (psCryptoOpen(PSCRYPTO_CONFIG) < PS_SUCCESS)
    {
        _psTrace("Failed to initialize library:  psCryptoOpen failed\n");
        return EXIT_FAILURE;
    }

    if (keyfile == NULL)
    {
/*
        If no file name provided, prompt for one and add the correct
        file extension if not given
 */
        tryagain = 1;
        Memset(otfKeyFile, 0x0, 32);
        while (tryagain)
        {
            _psTrace("Private key file name: ");
            if (fgets(otfKeyFile, 28, stdin) != NULL)
            {
                len = (int32) Strlen(otfKeyFile);
                if (Memcmp(&otfKeyFile[len - 5], outform, 4) != 0)
                {
                    Memcpy(&otfKeyFile[--len], outform, 4);
                }
                else
                {
                    otfKeyFile[--len] = '\0';
                }
                tryagain = 0;
            }
        }
        keyfile = otfKeyFile;
    }

# ifdef  USE_MATRIX_MEMORY_MANAGEMENT
    poolSize = 1024 * 12;
    pool = psOpenPool("keygen", poolSize, 0, NULL, NULL);
# else
    pool = NULL;
# endif


    _psTraceStr("Generating %s ECC private key... ", curve);

    psEccNewKey(pool, &privkey, params);
    if (psEccGenKey(pool, privkey, params, NULL) < 0)
    {
        _psTrace("FAILED\n");
        rc = PS_FAILURE;
        goto err;
    }
    else
    {
        _psTrace("SUCCESS\n");
    }

    if (password)
    {
        _psTrace("Writing password protected private key file... ");
    }
    else
    {
        _psTrace("Writing unencrypted private key file... ");
    }
    if (psEccWritePrivKeyFile(pool, privkey, keyfile, password, pemFlag) < 0)
    {
        _psTrace("FAILED\n");
        psEccDeleteKey(&privkey);
        rc = PS_FAILURE;
        goto err;
    }
    else
    {
        _psTrace("SUCCESS\n");
    }

    psEccDeleteKey(&privkey);

    /* Test the key with our parser */
    {
        psEccKey_t outKey;
        if (pemFlag)
        {
            if (psEccParsePrivFile(pool, keyfile, password, &outKey) < 0)
            {
                _psTrace("Unable to parse the resulting key\n");
                psEccClearKey(&outKey);
                rc = PS_FAILURE;
                goto err;
            }
            else
            {
                _psTrace("Successfully parsed the resulting key\n");
            }
            psEccClearKey(&outKey);
        }
    }

err:
# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
# endif
    psCryptoClose();
    if (rc == PS_SUCCESS)
    {
        return 0;
    }
    else
    {
        return EXIT_FAILURE;
    }
}

#else

/******************************************************************************/
/*
    Stub main for compiling without features enabled
 */
int32 main(int32 argc, char **argv)
{
    Printf("USE_ECC && USE_CERT_GEN && MATRIX_USE_FILE_SYSTEM must be enabled "
        "to run this application.\n");
    return EXIT_FAILURE;
}

#endif /* USE_ECC && USE_CERT_GEN && MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/





