/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT! */

/* Copyright (c) 2013-2014 Yoran Heling

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "yxml.h"
#include <string.h>

// typedef enum
// {
static const uint32_t YXMLS_string = 0;
static const uint32_t YXMLS_attr0 = 1;
static const uint32_t YXMLS_attr1 = 2;
static const uint32_t YXMLS_attr2 = 3;
static const uint32_t YXMLS_attr3 = 4;
static const uint32_t YXMLS_attr4 = 5;
static const uint32_t YXMLS_cd0 = 6;
static const uint32_t YXMLS_cd1 = 7;
static const uint32_t YXMLS_cd2 = 8;
static const uint32_t YXMLS_comment0 = 9;
static const uint32_t YXMLS_comment1 = 10;
static const uint32_t YXMLS_comment2 = 11;
static const uint32_t YXMLS_comment3 = 12;
static const uint32_t YXMLS_comment4 = 13;
static const uint32_t YXMLS_dt0 = 14;
static const uint32_t YXMLS_dt1 = 15;
static const uint32_t YXMLS_dt2 = 16;
static const uint32_t YXMLS_dt3 = 17;
static const uint32_t YXMLS_dt4 = 18;
static const uint32_t YXMLS_elem0 = 19;
static const uint32_t YXMLS_elem1 = 20;
static const uint32_t YXMLS_elem2 = 21;
static const uint32_t YXMLS_elem3 = 22;
static const uint32_t YXMLS_enc0 = 23;
static const uint32_t YXMLS_enc1 = 24;
static const uint32_t YXMLS_enc2 = 25;
static const uint32_t YXMLS_enc3 = 26;
static const uint32_t YXMLS_etag0 = 27;
static const uint32_t YXMLS_etag1 = 28;
static const uint32_t YXMLS_etag2 = 29;
static const uint32_t YXMLS_init = 30;
static const uint32_t YXMLS_le0 = 31;
static const uint32_t YXMLS_le1 = 32;
static const uint32_t YXMLS_le2 = 33;
static const uint32_t YXMLS_le3 = 34;
static const uint32_t YXMLS_lee1 = 35;
static const uint32_t YXMLS_lee2 = 36;
static const uint32_t YXMLS_leq0 = 37;
static const uint32_t YXMLS_misc0 = 38;
static const uint32_t YXMLS_misc1 = 39;
static const uint32_t YXMLS_misc2 = 40;
static const uint32_t YXMLS_misc2a = 41;
static const uint32_t YXMLS_misc3 = 42;
static const uint32_t YXMLS_pi0 = 43;
static const uint32_t YXMLS_pi1 = 44;
static const uint32_t YXMLS_pi2 = 45;
static const uint32_t YXMLS_pi3 = 46;
static const uint32_t YXMLS_pi4 = 47;
static const uint32_t YXMLS_std0 = 48;
static const uint32_t YXMLS_std1 = 49;
static const uint32_t YXMLS_std2 = 50;
static const uint32_t YXMLS_std3 = 51;
static const uint32_t YXMLS_ver0 = 52;
static const uint32_t YXMLS_ver1 = 53;
static const uint32_t YXMLS_ver2 = 54;
static const uint32_t YXMLS_ver3 = 55;
static const uint32_t YXMLS_xmldecl0 = 56;
static const uint32_t YXMLS_xmldecl1 = 57;
static const uint32_t YXMLS_xmldecl2 = 58;
static const uint32_t YXMLS_xmldecl3 = 59;
static const uint32_t YXMLS_xmldecl4 = 60;
static const uint32_t YXMLS_xmldecl5 = 61;
static const uint32_t YXMLS_xmldecl6 = 62;
static const uint32_t YXMLS_xmldecl7 = 63;
// } yxml_state_t;

#define yxml_isChar( c ) 1
/* 0xd should be part of SP, too, but yxml_parse() already normalizes that into 0xa */
#define yxml_isSP( c ) ( c == 0x20 || c == 0x09 || c == 0x0a )
#define yxml_isAlpha( c ) ( ( c | 32 ) - 'a' < 26 )
#define yxml_isNum( c ) ( c - '0' < 10 )
#define yxml_isHex( c ) ( yxml_isNum( c ) || ( c | 32 ) - 'a' < 6 )
#define yxml_isEncName( c ) ( yxml_isAlpha( c ) || yxml_isNum( c ) || c == '.' || c == '_' || c == '-' )
#define yxml_isNameStart( c ) ( yxml_isAlpha( c ) || c == ':' || c == '_' || c >= 128 )
#define yxml_isName( c ) ( yxml_isNameStart( c ) || yxml_isNum( c ) || c == '-' || c == '.' )
/* XXX: The valid characters are dependent on the quote char, hence the access to x->quote */
#define yxml_isAttValue( c ) ( yxml_isChar( c ) && c != x->quote && c != '<' && c != '&' )
/* Anything between '&' and ';', the yxml_ref* functions will do further
 * validation. Strictly speaking, this is "yxml_isName(c) || c == '#'", but
 * this parser doesn't understand entities with '.', ':', etc, anwyay.  */
#define yxml_isRef( c ) ( yxml_isNum( c ) || yxml_isAlpha( c ) || c == '#' )

#define INTFROM5CHARS( a, b, c, d, \
					   e ) ( ( ( ( uint64_t )( a ) ) << 32 ) | ( ( ( uint64_t )( b ) ) << 24 ) | \
							 ( ( ( uint64_t )( c ) ) << 16 ) | \
							 ( ( ( uint64_t )( d ) ) << 8 ) | ( uint64_t )( e ) )

/* Set the given char value to ch (0<=ch<=255).
 * This can't be done with simple assignment because char may be signed, and
 * unsigned-to-signed overflow is implementation defined in C. This function
 * /looks/ inefficient, but gcc compiles it down to a single movb instruction
 * on x86, even with -O0. */
static inline void yxml_setchar( char_t* dest, uint32_t ch )
{
	uint32_t _ch = ch;

	memcpy( dest, &_ch, 1 );
}

/* Similar to yxml_setchar(), but will convert ch (any valid unicode point) to
 * UTF-8 and appends a '\0'. dest must have room for at least 5 bytes. */
static void yxml_setutf8( char_t* dest, uint32_t ch )
{
	if ( ch <= 0x007F )
	{
		yxml_setchar( dest++, ch );
	}
	else if ( ch <= 0x07FF )
	{
		yxml_setchar( dest++, 0xC0 | ( ch >> 6 ) );
		yxml_setchar( dest++, 0x80 | ( ch & 0x3F ) );
	}
	else if ( ch <= 0xFFFF )
	{
		yxml_setchar( dest++, 0xE0 | ( ch >> 12 ) );
		yxml_setchar( dest++, 0x80 | ( ( ch >> 6 ) & 0x3F ) );
		yxml_setchar( dest++, 0x80 | ( ch & 0x3F ) );
	}
	else
	{
		yxml_setchar( dest++, 0xF0 | ( ch >> 18 ) );
		yxml_setchar( dest++, 0x80 | ( ( ch >> 12 ) & 0x3F ) );
		yxml_setchar( dest++, 0x80 | ( ( ch >> 6 ) & 0x3F ) );
		yxml_setchar( dest++, 0x80 | ( ch & 0x3F ) );
	}
	*dest = 0;
}

static inline int32_t yxml_datacontent( yxml_t* x, uint32_t ch )
{
	yxml_setchar( x->data, ch );
	x->data[1] = 0;
	return ( YXML_CONTENT );
}

static inline int32_t yxml_datapi1( yxml_t* x, uint32_t ch )
{
	yxml_setchar( x->data, ch );
	x->data[1] = 0;
	return ( YXML_PICONTENT );
}

static inline int32_t yxml_datapi2( yxml_t* x, uint32_t ch )
{
	x->data[0] = '?';
	yxml_setchar( x->data + 1, ch );
	x->data[2] = 0;
	return ( YXML_PICONTENT );
}

static inline int32_t yxml_datacd1( yxml_t* x, uint32_t ch )
{
	x->data[0] = ']';
	yxml_setchar( x->data + 1, ch );
	x->data[2] = 0;
	return ( YXML_CONTENT );
}

static inline int32_t yxml_datacd2( yxml_t* x, uint32_t ch )
{
	x->data[0] = ']';
	x->data[1] = ']';
	yxml_setchar( x->data + 2, ch );
	x->data[3] = 0;
	return ( YXML_CONTENT );
}

static inline int32_t yxml_dataattr( yxml_t* x, uint32_t ch )
{
	/* Normalize attribute values according to the XML spec section 3.3.3. */
	yxml_setchar( x->data, ch == 0x9 || ch == 0xa ? 0x20 : ch );
	x->data[1] = 0;
	return ( YXML_ATTRVAL );
}

static int32_t yxml_pushstack( yxml_t* x, char_t** res, uint32_t ch )
{

	int32_t return_val = YXML_OK;

	if ( x->stacklen + 2 >= x->stacksize )
	{
		return_val = YXML_ESTACK;
	}
	else
	{
		x->stacklen++;
		*res = ( char_t* )x->stack + x->stacklen;
		x->stack[x->stacklen] = ( uint8_t )( ch );
		x->stacklen++;
		x->stack[x->stacklen] = 0;

		return_val = YXML_OK;
	}
	return ( return_val );
}

static int32_t yxml_pushstackc( yxml_t* x, uint32_t ch )
{

	int32_t return_val = YXML_OK;

	if ( x->stacklen + 1 >= x->stacksize )
	{
		return_val = YXML_ESTACK;
	}
	else
	{
		x->stack[x->stacklen] = ( uint8_t )( ch );
		x->stacklen++;
		x->stack[x->stacklen] = 0;
		return_val = YXML_OK;
	}
	return ( return_val );
}

static void yxml_popstack( yxml_t* x )
{
	do
	{
		x->stacklen--;
	}while ( x->stack[x->stacklen] );
}

static inline int32_t yxml_elemstart( yxml_t* x, uint32_t ch )
{
	return ( yxml_pushstack( x, &x->elem, ch ) );
}

static inline int32_t yxml_elemname( yxml_t* x, uint32_t ch )
{
	return ( yxml_pushstackc( x, ch ) );
}

static inline int32_t yxml_elemnameend( yxml_t* x, uint32_t ch )
{
	return ( YXML_ELEMSTART );
}

/* Also used in yxml_elemcloseend(), since this function just removes the last
 * element from the stack and returns ELEMEND. */
static int32_t yxml_selfclose( yxml_t* x, uint32_t ch )
{

	int32_t return_val = YXML_OK;

	yxml_popstack( x );
	if ( x->stacklen )
	{
		x->elem = ( char_t* )x->stack + x->stacklen - 1;
		while ( *( x->elem - 1 ) )
		{
			x->elem--;
		}
		return_val = YXML_ELEMEND;
	}
	else
	{
		x->elem = ( char_t* )x->stack;
		x->state = YXMLS_misc3;
		return_val = YXML_ELEMEND;
	}
	return ( return_val );
}

static inline int32_t yxml_elemclose( yxml_t* x, uint32_t ch )
{

	int32_t return_val = YXML_OK;

	if ( *( ( uint8_t* )x->elem ) != ch )
	{
		return_val = YXML_ECLOSE;
	}
	else
	{
		x->elem++;
		return_val = YXML_OK;
	}
	return ( return_val );
}

static inline int32_t yxml_elemcloseend( yxml_t* x, uint32_t ch )
{
	int32_t return_val = YXML_OK;

	if ( *x->elem )
	{
		return_val = YXML_ECLOSE;
	}
	else
	{
		return_val = yxml_selfclose( x, ch );
	}
	return ( return_val );
}

static inline int32_t yxml_attrstart( yxml_t* x, uint32_t ch )
{
	return ( yxml_pushstack( x, &x->attr, ch ) );
}

static inline int32_t yxml_attrname( yxml_t* x, uint32_t ch )
{
	return ( yxml_pushstackc( x, ch ) );
}

static inline int32_t yxml_attrnameend( yxml_t* x, uint32_t ch )
{
	return ( YXML_ATTRSTART );
}

static inline int32_t yxml_attrvalend( yxml_t* x, uint32_t ch )
{
	yxml_popstack( x );
	return ( YXML_ATTREND );
}

static inline int32_t yxml_pistart( yxml_t* x, uint32_t ch )
{
	return ( yxml_pushstack( x, &x->pi, ch ) );
}

static inline int32_t yxml_piname( yxml_t* x, uint32_t ch )
{
	return ( yxml_pushstackc( x, ch ) );
}

static inline int32_t yxml_pinameend( yxml_t* x, uint32_t ch )
{
	return ( ( x->pi[0] | 32 ) == 'x' && ( x->pi[1] | 32 ) == 'm' &&
			 ( x->pi[2] | 32 ) == 'l' && !x->pi[3] ? YXML_ESYN : YXML_PISTART );
}

static inline int32_t yxml_pivalend( yxml_t* x, uint32_t ch )
{
	yxml_popstack( x );
	x->pi = ( char_t* )x->stack;
	return ( YXML_PIEND );
}

static inline int32_t yxml_refstart( yxml_t* x, uint32_t ch )
{
	memset( x->data, 0, sizeof ( x->data ) );
	x->reflen = 0;
	return ( YXML_OK );
}

static int32_t yxml_ref( yxml_t* x, uint32_t ch )
{

	int32_t return_val = YXML_OK;

	if ( x->reflen >= sizeof ( x->data ) - 1 )
	{
		return_val = YXML_EREF;
	}
	else
	{
		yxml_setchar( x->data + x->reflen, ch );
		x->reflen++;
		return_val = YXML_OK;
	}
	return ( return_val );
}

static int32_t yxml_refend( yxml_t* x, int32_t ret )
{

	int32_t return_val = YXML_OK;
	uint8_t* r = ( uint8_t* )x->data;
	uint32_t ch = 0;

	if ( *r == '#' )
	{
		if ( r[1] == 'x' )
		{
			for ( ( r += 2 ); yxml_isHex( ( uint32_t )( *r ) ); r++ )
			{
				ch = ( ch << 4 )
					+ ( ( *r <= '9' ) ? ( *r - '0' ) : ( ( ( *r | 32 ) - 'a' ) + 10 ) );
			}
		}
		else
		{
			for ( r++; yxml_isNum( ( uint32_t )( *r ) ); r++ )
			{
				ch = ( ch * 10 ) + ( *r - '0' );
			}
		}
		if ( 0 != *r )
		{
			ch = 0;
		}
	}
	else
	{
		uint64_t i = INTFROM5CHARS( r[0], r[1], r[2], r[3], r[4] );
		ch = ( i == INTFROM5CHARS( 'l', 't', 0, 0, 0 ) ) ? '<' :
			( i == INTFROM5CHARS( 'g', 't', 0, 0, 0 ) ) ? '>' :
			( i == INTFROM5CHARS( 'a', 'm', 'p', 0, 0 ) ) ? '&' :
			( i == INTFROM5CHARS( 'a', 'p', 'o', 's', 0 ) ) ? '\'' :
			( i == INTFROM5CHARS( 'q', 'u', 'o', 't', 0 ) ) ? '"' : 0;
	}

	/* Codepoints not allowed in the XML 1.1 definition of a Char */
	if ( 0 !=
		 ( ( 0 != ch ) || ( ch > 0x10FFFF ) || ( ch == 0xFFFE ) || ( ch == 0xFFFF ) ||
		   ( ( ch - 0xDFFF ) < 0x7FF ) ) )
	{
		return_val = YXML_EREF;
	}
	else
	{
		yxml_setutf8( x->data, ch );
		return_val = ( int32_t )ret;
	}
	return ( return_val );
}

static inline int32_t yxml_refcontent( yxml_t* x, uint32_t ch )
{
	return ( yxml_refend( x, YXML_CONTENT ) );
}

static inline int32_t yxml_refattrval( yxml_t* x, uint32_t ch )
{
	return ( yxml_refend( x, YXML_ATTRVAL ) );
}

void yxml_init( yxml_t* x, size_t stacksize )
{
	memset( x, 0, sizeof ( *x ) );
	x->stacksize = ( uint16_t )( stacksize );
	*x->stack = 0;
	x->elem = x->pi = x->attr = ( char_t* )x->stack;
	x->state = YXMLS_init;
}

int32_t yxml_parse( yxml_t* x, int32_t _ch )
{

	int32_t return_val = YXML_OK;
	/* Ensure that characters are in the range of 0..255 rather than -126..125.
	 * All character comparisons are done with positive integers. */
	uint32_t ch = ( uint32_t )( _ch + 256 ) & 0xff;

	if ( !ch )
	{
		return_val = YXML_ESYN;
	}
	else
	{
		x->total++;

		/* End-of-Line normalization, "\rX", "\r\n" and "\n" are recognized and
		 * normalized to a single '\n' as per XML 1.0 section 2.11. XML 1.1 adds
		 * some non-ASCII character sequences to this list, but we can only handle
		 * ASCII here without making assumptions about the input encoding. */
		if ( x->ignore == ch )
		{
			x->ignore = 0;
			return_val = YXML_OK;
		}
		else
		{
			x->ignore = ( ( ch == 0xd ) * 0xa );
			if ( ( ch == 0xa ) || ( ch == 0xd ) )
			{
				ch = 0xa;
				x->byte = 0;
			}
			x->byte++;

			switch ( x->state )
			{
				case YXMLS_string:
					if ( ch == *x->string )
					{
						x->string++;
						if ( !*x->string )
						{
							x->state = x->nextstate;
						}
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_attr0:
					if ( 0 != yxml_isName( ch ) )
					{
						return_val = yxml_attrname( x, ch );
					}
					else if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_attr1;
						return_val = yxml_attrnameend( x, ch );
					}
					else if ( ch == ( uint8_t )'=' )
					{
						x->state = YXMLS_attr2;
						return_val = yxml_attrnameend( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_attr1:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'=' )
					{
						x->state = YXMLS_attr2;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_attr2:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ( ch == ( uint8_t )'\'' ) || ( ch == ( uint8_t )'"' ) )
					{
						x->state = YXMLS_attr3;
						x->quote = ch;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_attr3:
					if ( 0 != yxml_isAttValue( ch ) )
					{
						return_val = yxml_dataattr( x, ch );
					}
					else if ( ch == ( uint8_t )'&' )
					{
						x->state = YXMLS_attr4;
						return_val = yxml_refstart( x, ch );
					}
					else if ( x->quote == ch )
					{
						x->state = YXMLS_elem2;
						return_val = yxml_attrvalend( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_attr4:
					if ( 0 != yxml_isRef( ch ) )
					{
						return_val = yxml_ref( x, ch );
					}
					else if ( ch == ( uint8_t )'\x3b' )
					{
						x->state = YXMLS_attr3;
						return_val = yxml_refattrval( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_cd0:
					if ( ch == ( uint8_t )']' )
					{
						x->state = YXMLS_cd1;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						return_val = yxml_datacontent( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_cd1:
					if ( ch == ( uint8_t )']' )
					{
						x->state = YXMLS_cd2;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						x->state = YXMLS_cd0;
						return_val = yxml_datacd1( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_cd2:
					if ( ch == ( uint8_t )']' )
					{
						return_val = yxml_datacontent( x, ch );
					}
					else if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc2;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						x->state = YXMLS_cd0;
						return_val = yxml_datacd2( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_comment0:
					if ( ch == ( uint8_t )'-' )
					{
						x->state = YXMLS_comment1;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_comment1:
					if ( ch == ( uint8_t )'-' )
					{
						x->state = YXMLS_comment2;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_comment2:
					if ( ch == ( uint8_t )'-' )
					{
						x->state = YXMLS_comment3;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_comment3:
					if ( ch == ( uint8_t )'-' )
					{
						x->state = YXMLS_comment4;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						x->state = YXMLS_comment2;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_comment4:
					if ( ch == ( uint8_t )'>' )
					{
						x->state = x->nextstate;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_dt0:
					if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc1;
						return_val = YXML_OK;
					}
					else if ( ( ch == ( uint8_t )'\'' ) || ( ch == ( uint8_t )'"' ) )
					{
						x->state = YXMLS_dt1;
						x->quote = ch;
						x->nextstate = YXMLS_dt0;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'<' )
					{
						x->state = YXMLS_dt2;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_dt1:
					if ( x->quote == ch )
					{
						x->state = x->nextstate;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_dt2:
					if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_pi0;
						x->nextstate = YXMLS_dt0;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'!' )
					{
						x->state = YXMLS_dt3;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_dt3:
					if ( ch == ( uint8_t )'-' )
					{
						x->state = YXMLS_comment1;
						x->nextstate = YXMLS_dt0;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						x->state = YXMLS_dt4;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_dt4:
					if ( ( ch == ( uint8_t )'\'' ) || ( ch == ( uint8_t )'"' ) )
					{
						x->state = YXMLS_dt1;
						x->quote = ch;
						x->nextstate = YXMLS_dt4;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_dt0;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_elem0:
					if ( 0 != yxml_isName( ch ) )
					{
						return_val = yxml_elemname( x, ch );
					}
					else if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_elem1;
						return_val = yxml_elemnameend( x, ch );
					}
					else if ( ch == ( uint8_t )'/' )
					{
						x->state = YXMLS_elem3;
						return_val = yxml_elemnameend( x, ch );
					}
					else if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc2;
						return_val = yxml_elemnameend( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_elem1:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'/' )
					{
						x->state = YXMLS_elem3;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc2;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isNameStart( ch ) )
					{
						x->state = YXMLS_attr0;
						return_val = yxml_attrstart( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_elem2:
					if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_elem1;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'/' )
					{
						x->state = YXMLS_elem3;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc2;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_elem3:
					if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc2;
						return_val = yxml_selfclose( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_enc0:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'=' )
					{
						x->state = YXMLS_enc1;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_enc1:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ( ch == ( uint8_t )'\'' ) || ( ch == ( uint8_t )'"' ) )
					{
						x->state = YXMLS_enc2;
						x->quote = ch;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_enc2:
					if ( 0 != yxml_isAlpha( ch ) )
					{
						x->state = YXMLS_enc3;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_enc3:
					if ( 0 != yxml_isEncName( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( x->quote == ch )
					{
						x->state = YXMLS_xmldecl4;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_etag0:
					if ( 0 != yxml_isNameStart( ch ) )
					{
						x->state = YXMLS_etag1;
						return_val = yxml_elemclose( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_etag1:
					if ( 0 != yxml_isName( ch ) )
					{
						return_val = yxml_elemclose( x, ch );
					}
					else if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_etag2;
						return_val = yxml_elemcloseend( x, ch );
					}
					else if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc2;
						return_val = yxml_elemcloseend( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_etag2:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc2;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_init:
					if ( ch == ( uint8_t )'\xef' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_misc0;
						x->string = ( uint8_t* )"\xbb\xbf";
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_misc0;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'<' )
					{
						x->state = YXMLS_le0;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_le0:
					if ( ch == ( uint8_t )'!' )
					{
						x->state = YXMLS_lee1;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_leq0;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isNameStart( ch ) )
					{
						x->state = YXMLS_elem0;
						return_val = yxml_elemstart( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_le1:
					if ( ch == ( uint8_t )'!' )
					{
						x->state = YXMLS_lee1;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_pi0;
						x->nextstate = YXMLS_misc1;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isNameStart( ch ) )
					{
						x->state = YXMLS_elem0;
						return_val = yxml_elemstart( x, ch );
					}
					else if ( ch == ( uint8_t )'/' )
					{
						x->state = YXMLS_etag0;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_le2:
					if ( ch == ( uint8_t )'!' )
					{
						x->state = YXMLS_lee2;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_pi0;
						x->nextstate = YXMLS_misc2;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'/' )
					{
						x->state = YXMLS_etag0;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isNameStart( ch ) )
					{
						x->state = YXMLS_elem0;
						return_val = yxml_elemstart( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_le3:
					if ( ch == ( uint8_t )'!' )
					{
						x->state = YXMLS_comment0;
						x->nextstate = YXMLS_misc3;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_pi0;
						x->nextstate = YXMLS_misc3;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_lee1:
					if ( ch == ( uint8_t )'-' )
					{
						x->state = YXMLS_comment1;
						x->nextstate = YXMLS_misc1;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'D' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_dt0;
						x->string = ( uint8_t* )"OCTYPE";
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_lee2:
					if ( ch == ( uint8_t )'-' )
					{
						x->state = YXMLS_comment1;
						x->nextstate = YXMLS_misc2;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'[' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_cd0;
						x->string = ( uint8_t* )"CDATA[";
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_leq0:
					if ( ch == ( uint8_t )'x' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_xmldecl0;
						x->string = ( uint8_t* )"ml";
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isNameStart( ch ) )
					{
						x->state = YXMLS_pi1;
						x->nextstate = YXMLS_misc1;
						return_val = yxml_pistart( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_misc0:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'<' )
					{
						x->state = YXMLS_le0;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_misc1:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'<' )
					{
						x->state = YXMLS_le1;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_misc2:
					if ( ch == ( uint8_t )'<' )
					{
						x->state = YXMLS_le2;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'&' )
					{
						x->state = YXMLS_misc2a;
						return_val = yxml_refstart( x, ch );
					}
					else if ( ch == ( unsigned char )'\n' )
					{
						x->state = YXMLS_misc1;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'>' )
					{
						return_val = YXML_ESYN;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						return_val = yxml_datacontent( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_misc2a:
					if ( 0 != yxml_isRef( ch ) )
					{
						return_val = yxml_ref( x, ch );
					}
					else if ( ch == ( uint8_t )'\x3b' )
					{
						x->state = YXMLS_misc2;
						return_val = yxml_refcontent( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_misc3:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ( ch == ( uint8_t )'>' ) && ( x->stacklen == 0 ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'<' )
					{
						x->state = YXMLS_le3;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_pi0:
					if ( 0 != yxml_isNameStart( ch ) )
					{
						x->state = YXMLS_pi1;
						return_val = yxml_pistart( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_pi1:
					if ( 0 != yxml_isName( ch ) )
					{
						return_val = yxml_piname( x, ch );
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_pi4;
						return_val = yxml_pinameend( x, ch );
					}
					else if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_pi2;
						return_val = yxml_pinameend( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_pi2:
					if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_pi3;
						return_val = YXML_OK;
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						return_val = yxml_datapi1( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_pi3:
					if ( ch == ( uint8_t )'>' )
					{
						x->state = x->nextstate;
						return_val = yxml_pivalend( x, ch );
					}
					else if ( 0 != yxml_isChar( ch ) )
					{
						x->state = YXMLS_pi2;
						return_val = yxml_datapi2( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_pi4:
					if ( ch == ( uint8_t )'>' )
					{
						x->state = x->nextstate;
						return_val = yxml_pivalend( x, ch );
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_std0:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'=' )
					{
						x->state = YXMLS_std1;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_std1:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ( ch == ( uint8_t )'\'' ) || ( ch == ( uint8_t )'"' ) )
					{
						x->state = YXMLS_std2;
						x->quote = ch;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_std2:
					if ( ch == ( uint8_t )'y' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_std3;
						x->string = ( uint8_t* )"es";
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'n' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_std3;
						x->string = ( uint8_t* )"o";
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_std3:
					if ( x->quote == ch )
					{
						x->state = YXMLS_xmldecl6;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_ver0:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'=' )
					{
						x->state = YXMLS_ver1;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_ver1:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ( ch == ( uint8_t )'\'' ) || ( ch == ( uint8_t )'"' ) )
					{
						x->state = YXMLS_string;
						x->quote = ch;
						x->nextstate = YXMLS_ver2;
						x->string = ( uint8_t* )"1.";
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_ver2:
					if ( 0 != yxml_isNum( ch ) )
					{
						x->state = YXMLS_ver3;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_ver3:
					if ( 0 != yxml_isNum( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( x->quote == ch )
					{
						x->state = YXMLS_xmldecl2;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_xmldecl0:
					if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_xmldecl1;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_xmldecl1:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'v' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_ver0;
						x->string = ( uint8_t* )"ersion";
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_xmldecl2:
					if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_xmldecl3;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_xmldecl7;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_xmldecl3:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_xmldecl7;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'e' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_enc0;
						x->string = ( uint8_t* )"ncoding";
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'s' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_std0;
						x->string = ( uint8_t* )"tandalone";
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_xmldecl4:
					if ( 0 != yxml_isSP( ch ) )
					{
						x->state = YXMLS_xmldecl5;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_xmldecl7;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_xmldecl5:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_xmldecl7;
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'s' )
					{
						x->state = YXMLS_string;
						x->nextstate = YXMLS_std0;
						x->string = ( uint8_t* )"tandalone";
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_xmldecl6:
					if ( 0 != yxml_isSP( ch ) )
					{
						return_val = YXML_OK;
					}
					else if ( ch == ( uint8_t )'?' )
					{
						x->state = YXMLS_xmldecl7;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}

					break;

				case YXMLS_xmldecl7:
					if ( ch == ( uint8_t )'>' )
					{
						x->state = YXMLS_misc1;
						return_val = YXML_OK;
					}
					else
					{
						return_val = YXML_ESYN;
					}
					break;

				default:
					return_val = YXML_ESYN;
					break;
			}
			// return YXML_ESYN;
		}
	}
	return ( return_val );
}

int32_t yxml_eof( yxml_t* x )
{

	int32_t return_val = YXML_OK;

	if ( x->state != YXMLS_misc3 )
	{
		return_val = YXML_EEOF;
	}
	else
	{
		return_val = YXML_OK;
	}
	return ( return_val );
}

/* vim: set noet sw=4 ts=4: */
