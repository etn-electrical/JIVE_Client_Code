/**
 *      @file    test.c
 *
 *
 *      Testing for some of the APIs implemented in core.
 */
/*
 *      Copyright (c) 2017-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#define _GNU_SOURCE         /* Get vasprintf when including stdio.h */

/* Note: This program is intended to run with all logging messages on. */

#ifndef _h_PS_CORECONFIG
# ifdef MATRIX_CONFIGURATION_INCDIR_FIRST
#  include <coreConfig.h> /* Must be first included */
# else
#  include "coreConfig.h" /* Must be first included */
# endif
#endif /* _h_PS_CORECONFIG */

/* Override any possible disabled logging.
   This is neccessary, because the program is dependent on
   messages working as expected as the program is testing the facility.
   Note: Normally do this setting via "coreConfig.h" */
#undef PS_NO_LOGF_FATAL
#undef PS_NO_LOGF_ERROR
#undef PS_NO_LOGF_WARNING
#undef PS_NO_LOGF_INFO
#undef PS_NO_LOGF_VERBOSE
#undef PS_NO_LOGF_DEBUG
#undef PS_NO_LOGF_TRACE
#undef PS_NO_LOGF_CALL_TRACE

#include "coreApi.h"
#include "psUtil.h"

#include "osdep_stdio.h"
#include "osdep_stdlib.h"
#include "osdep_limits.h"
#include "psPrnf.h"
#include "sfzcl/sfzclsnprintf.h"
#include "cf_impldefs.h"
#include "psStat.h"

/* Enable following if you wish to test effect of flags to
   PS_NO_LOGF processing.
#undef PS_NO_LOGF_FILELINE
#define PS_NO_LOGF_FILELINE
#undef PS_NO_LOGF_PRINT_UNIT
#define PS_NO_LOGF_PRINT_UNIT
*/

#define PS_LOGF_WITH_PRNF
#include "psLog.h" /* SafeZone/Matrix common logging framework */

#include "osdep_sys_types.h"
#include "osdep_sys_socket.h"
#include "osdep_netdb.h"

/* Select psPool_t used in this test */
#define DEFAULT_POOL NULL
#define TEST_TAG CORE_TEST
#include "testsupp.h"

int staticbufcheck(psBuf_t *b, const char *expect)
{
    size_t len = 0;
    char *buf = psBufDetach(DEFAULT_POOL, b, &len);

    if (buf)
    {
        debugf("%.*s\n", (int) len, buf);
    }
    if (buf && expect && (Strlen(expect) != len ||
                          Memcmp(buf, expect, len)))
    {
        buf = NULL;
    }
    psFreeN(buf);
    return buf != NULL;
}

/* Implement NZ and Z handy checkers for function results.
   As these terminate handling immediately, avoid their use on
   functions where return values are not mandatorily Z or NZ. */
static int res = 0;
static int check[1];
static int check_f(int *res_p, const char *f, int l)
{
    static int prev_res;

    if (prev_res != *res_p)
    {
        Fprintf(stderr, "Unexpected result at %s:%d\n", f, l);
        prev_res = *res_p;
        Abort();
    }
    return 0;
}

#define NZ check[check_f(&res, __FILE__, __LINE__)] = res += 0 ==
#define Z check[check_f(&res, __FILE__, __LINE__)] = res += 0 !=

#define STATICBUFCHECK(x, y) FAIL_IF(staticbufcheck((x), (y)) == 0)

int psSbufprintf(psBuf_t *buf, const char *format, ...);
int psSnprintf(char *str, size_t size, const char *format, ...);
int psVsnprintf(char *str, size_t size, const char *format, va_list ap);

/* Returns NULL: One of inputs is NULL or mismatch.
   Returns one of strings: If the strings are equal and not NULL. */
static inline const char *myStrnsame(const char *s1, const char *s2, size_t n)
{
    if (s1 == NULL || s2 == NULL)
    {
        return NULL;
    }
    if (Strncmp(s1, s2, n) == 0)
    {
        return s1;
    }
    Printf("MISMATCH: \"%.*s\" vs \"%.*s\"\n", (int)n, s1, (int)n, s2);
    return NULL;
}

#ifdef NO_SFZCL_SNPRINTF
/* No sfzcl_snprintf implemented. Emulate the function for purposes of
   the test below. */
int
sfzcl_snprintf(char *str, size_t size, const char *format, ...)
{
    va_list ap;
    int len;

    /* Always return 0 if there is no room for formatting. */
    if (size == 0)
    {
        return 0;
    }
    
    va_start(ap, format);
    len = psVsnprintf(str, size, format, ap);
    va_end(ap);
    if (len < 0 || (size_t) len < size)
    {
        return len;
    }

    /* Truncated: Return at most size - 1. */
    return size - 1;
}
#endif /* NO_SFZCL_SNPRINTF */

TEST_RESULT TEST_PsSnprintf(void)
{
    int c75 = 75;
    psBuf_t buf;
    void *p;
    char buf1[160];
    char buf2[160];
    char buf3[160];
    int res1;
    int res2;
    int res3;
    int i;
    const char *str = "Hello, World!\n";
    const int debug_this_function = 0;
    
    p = psBufInit(NULL, &buf, 10);
    FAIL_IF(p == NULL);
    FAIL_IF(psSbufprintf(&buf, "%d", c75) != 2);
    FAIL_IF(myStrnsame(buf.start, "75", 10) == NULL);
    psBufUninit(NULL, &buf);
    p = psBufInit(NULL, &buf, 10);
    FAIL_IF(p == NULL);
    FAIL_IF(psSbufprintf(&buf, "%4d", c75) != 4);
    FAIL_IF(myStrnsame(buf.start, "  75", 10) == NULL);
    psBufUninit(NULL, &buf);
    p = psBufInit(NULL, &buf, 10);
    FAIL_IF(p == NULL);
    FAIL_IF(psSbufprintf(&buf, "%10d", c75) != 10);
    FAIL_IF(myStrnsame(buf.start, "        75", 10) == NULL);
    psBufUninit(NULL, &buf);
    p = psBufInit(NULL, &buf, 10);
    FAIL_IF(p == NULL);
    FAIL_IF(psSbufprintf(&buf, "%12d", c75) != 12);
    FAIL_IF(myStrnsame(buf.start, "          ", 10) == NULL);
    psBufUninit(NULL, &buf);

#if __STDC_VERSION__ >= 199901L
    /* Assume Sprintf has C99 semantics. */

#define TEST_PRINTF3(min, max, sz, ...)                           \
    do                                                            \
    {                                                             \
        for(i = min; i < max; i++)                                \
        {                                                         \
            memset(buf1, '_', sizeof buf1);                       \
            memset(buf2, '_', sizeof buf2);                       \
            memset(buf3, '_', sizeof buf3);                       \
            res1 = psSnprintf(buf1, sz, __VA_ARGS__);            \
            res2 = Snprintf(buf2, sz, __VA_ARGS__);               \
            res3 = sfzcl_snprintf(buf3, sz, __VA_ARGS__);         \
            FAIL_IF(myStrnsame(buf1, buf2, sz+10) == NULL);       \
            FAIL_IF(myStrnsame(buf2, buf3, sz+10) == NULL);       \
            if (debug_this_function) { printf("i=%d sz=%d res1: %d res2: %d res3: %d\n", i, sz, res1, res2, res3); }  \
            FAIL_IF(res1 != res2);                                \
            /* sfzcl_snprintf semantics: large res3 is truncated at sz - 1. */ \
            FAIL_IF(res2 < (sz) ? res2 != res3 : res3 != ((sz) > 0 ? (sz) - 1 : 0)); \
        }                                                               \
        /* Check the range included full output. */                     \
        FAIL_IF(res1 >= max);                                           \
    } while(0)

#define TEST_PRINTF2(min, max, sz, ...)                           \
    do                                                            \
    {                                                             \
        for(i = min; i < max; i++)                                \
        {                                                         \
            memset(buf1, '_', sizeof buf1);                       \
            memset(buf2, '_', sizeof buf2);                       \
            res1 = psSnprintf(buf1, sz, __VA_ARGS__);            \
            res2 = Snprintf(buf2, sz, __VA_ARGS__);               \
            FAIL_IF(myStrnsame(buf1, buf2, sz+10) == NULL);       \
            if (debug_this_function) { printf("i=%d sz=%d res1: %d res2: %d\n", i, sz, res1, res2); }  \
            FAIL_IF(res1 != res2);                                \
        }                                                         \
    } while(0)

    /* Using a simple integer and small buffer as the test case,
       check the return values and truncation behavior. */
    
    TEST_PRINTF3(0, 12, 8, "%*d", i, c75);
    /* Ensure truncation behavior: last character is \000. */
    FAIL_IF(myStrnsame(buf1, "       ", 16) == NULL);
    TEST_PRINTF3(0, 9, 8, "%*d", i, c75);
    /* Ensure truncation behavior: last character is \000. */
    FAIL_IF(myStrnsame(buf1, "      7", 16) == NULL);

    TEST_PRINTF3(0, 12, 7, "%*d", i, c75);
    TEST_PRINTF3(0, 12, 6, "%*d", i, c75);
    TEST_PRINTF3(0, 12, 5, "%*d", i, c75);
    TEST_PRINTF3(0, 12, 4, "%*d", i, c75);
    TEST_PRINTF3(0, 12, 3, "%*d", i, c75);
    TEST_PRINTF3(0, 12, 2, "%*d", i, c75);
    TEST_PRINTF3(0, 12, 1, "%*d", i, c75);
    TEST_PRINTF3(0, 12, 0, "%*d", i, c75);

    /* Other integer formatting letters. */
    TEST_PRINTF3(0, 12, 0, "%*i", i, c75);
    TEST_PRINTF3(0, 12, 0, "%*o", i, c75);
    TEST_PRINTF3(0, 12, 0, "%*x", i, c75);
    TEST_PRINTF3(0, 12, 0, "%*X", i, c75);

    /* How integers too large to fit in field are truncated. */
    TEST_PRINTF3(0, 12, i, "%2d", 1984);
    FAIL_IF(myStrnsame(buf1, "1984", 5) == NULL);

    /* Printing negative numbers with extra zeroes. */
    TEST_PRINTF3(0, 12, i, "%04d", -30);
    FAIL_IF(myStrnsame(buf1, "-030", 5) == NULL);

    /* How base-16 integers too large to fit in field are truncated. */
    TEST_PRINTF3(0, 12, i, "%2x", 1984);

    /* Printing integers (no truncation). */
    TEST_PRINTF3(0, 256, 4, "%x", (unsigned int) i);

    /* Printing characters with truncation. */
    TEST_PRINTF3(1, 255, i % 5, "%c", (int) i);

    /* testing character 0 as a special case. */
    TEST_PRINTF3(0, 8, i, "%c", 0);
    
    /* Printing strings with truncation. */
    TEST_PRINTF3(0, 16, i, "%s", str);

    /* Printing pointers. */
    TEST_PRINTF2(0, 40, i, "%p", (const void *)(uintptr_t)0x734FFABCL);
    /* Note: Omitted sfzcl_snprintf, because its format for %p may vary. */

    /* Quoting formatting. */
    TEST_PRINTF3(0, 16, i, "%%%%%%%%");

    /* Some miscellaneous test cases (for date formatting) */
    TEST_PRINTF3(0, 20, i, "%02d" /* year */
                 "%02d"                                    /* month */
                 "%02d"                                    /* day */
                 "%02d"                                    /* hour */
                 "%02d"                                    /* minute */
                 "%02d",                                   /* second */
                 1984 % 100,
                 5, 1,
                 23, 59, 59);

    TEST_PRINTF3(0, 20, i / 2, "%c"
                 /* local difference */
                 "%02d"      /* hours */
                 "%02d",     /* minutes */
                 ((i & 1) == 1 ? '+' : '-'),
                 2, 0);

    TEST_PRINTF3(0, 10, i, "Z");

    TEST_PRINTF3(0, 40, i, "%04d"                          /* year */
                 "%02d"                                    /* month */
                 "%02d"                                    /* day */
                 "%02d"                                    /* hour */
                 "%02d"                                    /* minute */
                 "%02d"                                    /* second */
                 "%s"                                      /* msec */
                 "Z",
                 2080,
                 6, 11,
                 7, 25,
                 55, ".123456");

    TEST_PRINTF3(0, 10, i, ".%06d", 12345);

    TEST_PRINTF3(0, 40, i, "%04d %s %2d%s, %02d:%02d:%02d%s GMT", 2018,
                 "Feb", 23, "rd", 11,23,2, ".012345");

    TEST_PRINTF3(0, 40, i, "%04d%02d%02d%02d%02d%02d",
                 (int) 1997,
                 (int) 0 + 1,
                 (int) 31,
                 (int) 23,
                 (int) 59, (int) 58);

    TEST_PRINTF3(0, 10, i, " +%02d%02d",
                 (int) ((35000 / 3600) % 100),
                 (int) ((35000 / 60) % 60));

    TEST_PRINTF3(0, 10, i, " -%02d%02d",
                 (int) ((-35000 / -3600) % 100),
                 (int) ((-35000 / -60) % 60));

    TEST_PRINTF3(0, 40, i,
                 "%s %s %02d %04d %02d:%02d:%02d%s",
                 "Tue", "Jan", 19, 2038, 05, 14, 07, "+0200");
    
    /* Other miscellaneous tests. */
    TEST_PRINTF3(0, 40, i, "pbewith%sand%s", "MD5", "DES");
#else
    /* Cannot fully test when C99 standard is not available. */
    return SKIPPED;
#endif
    return OK;
}

TEST_RESULT TEST_PsBuf(void)
{
    psBuf_t b;

    NZ psBufInit(DEFAULT_POOL, &b, 3);
    NZ psBufAppendChar(&b, 'O');
    NZ psBufAppendChar(&b, 'K');
    NZ psBufAppendChar(&b, '!');
    Z psBufAppendChar(&b, 'N');
    STATICBUFCHECK(&b, "OK!");

    NZ psBufInit(DEFAULT_POOL, &b, 4);
    psBufReservePrepend(&b, 3);
    NZ psBufPrependChar(&b, '!');
    NZ psBufPrependChar(&b, 'K');
    NZ psBufPrependChar(&b, 'O');
    Z psBufPrependChar(&b, 'N');
    STATICBUFCHECK(&b, "OK!");

    NZ psBufInit(DEFAULT_POOL, &b, 8);
    psBufReservePrepend(&b, 6);
    NZ psBufPrependChar(&b, '!');
    NZ psBufPrependChar(&b, 'K');
    NZ psBufPrependChar(&b, 'O');
    STATICBUFCHECK(&b, "OK!");

    return OK;
}

/* Check dynamic buffer against expected value (only for c strings.) */
int dynbufcheck(psDynBuf_t *b, const char *expect)
{
    size_t len = 0;
    char *buf = psDynBufDetach(b, &len);

    if (buf)
    {
        debugf("%.*s\n", (int) len, buf);
    }
    if (buf && expect && (Strlen(expect) != len ||
                          Memcmp(buf, expect, len)))
    {
        Printf("Comparison failure, got: %.*s instead of %s\n",
            (int) len, buf, expect);
        buf = NULL;
    }
    if (buf && !expect)
    {
        Printf("Expect not set, got: %.*s\n", (int) len, buf);
    }
    psFreeN(buf);
    return buf != NULL;
}

static char *BinToHex(char *hexstr, const unsigned char *hex, size_t sz)
{
    size_t i;

    hexstr[0] = 0;
    for (i = 0; i < sz; i++)
    {
        Sprintf(hexstr + i * 2, "%02x", hex[i]);
    }
    return hexstr;
}

static char *hexbuf(void *in, size_t *sz_p)
{
    void *out;

    if (in == NULL)
    {
        return NULL;
    }
    out = psMalloc(DEFAULT_POOL, *sz_p * 2 + 1);
    if (out)
    {
        BinToHex(out, in, *sz_p);
    }
    psFreeN(in);
    *sz_p *= 2;
    return out;
}

/* Check dynamic buffer against expected value (only for c strings.) */
int dynbufcheck_hex(psDynBuf_t *b, const char *expect_hex)
{
    size_t len = 0;
    char *buf = hexbuf(psDynBufDetach(b, &len), &len);

    if (buf)
    {
        debugf("%.*s\n", (int) len, buf);
    }
    if (buf && expect_hex && (Strlen(expect_hex) != len ||
                              Memcmp(buf, expect_hex, len)))
    {
        Printf("Comparison failure, got: %.*s instead of %s\n",
            (int) len, buf, expect_hex);
        buf = NULL;
    }
    if (buf && !expect_hex)
    {
        Printf("Expect not set, got: %.*s\n", (int) len, buf);
    }
    psFreeN(buf);
    return buf != NULL;
}

#define DYNBUFCHECK(x, y) FAIL_IF(dynbufcheck((x), (y)) == 0)
#define DYNBUFCHECK_HEX(x, y) FAIL_IF(dynbufcheck_hex((x), (y)) == 0)

TEST_RESULT TEST_PsDynBuf(void)
{
    psDynBuf_t b;
    int res = 0;

    NZ psDynBufInit(DEFAULT_POOL, &b, 2);
    NZ psDynBufAppendChar(&b, 'O');
    NZ psDynBufAppendChar(&b, 'K');
    NZ psDynBufAppendChar(&b, '!');
    DYNBUFCHECK(&b, "OK!");

    NZ psDynBufInit(DEFAULT_POOL, &b, 10);
    NZ psDynBufAppendUtf8(&b, 'a');
    NZ psDynBufAppendUtf8(&b, 0xE4);
    NZ psDynBufAppendUtf8(&b, 0x2603);
    NZ psDynBufAppendUtf8(&b, 0x1F468);
    DYNBUFCHECK(&b, "\x61\xc3\xa4\xe2\x98\x83\xf0\x9f\x91\xa8");

    NZ psDynBufInit(DEFAULT_POOL, &b, 4);
    psDynBufReservePrepend(&b, 1);
    NZ psDynBufPrependChar(&b, '!');
    NZ psDynBufPrependChar(&b, 'K');
    NZ psDynBufPrependChar(&b, 'O');
    DYNBUFCHECK(&b, "OK!");

    NZ psDynBufInit(DEFAULT_POOL, &b, 8);
    psDynBufReservePrepend(&b, 6);
    NZ psDynBufPrependChar(&b, '!');
    NZ psDynBufPrependChar(&b, 'K');
    NZ psDynBufPrependChar(&b, 'O');
    DYNBUFCHECK(&b, "OK!");

    NZ psDynBufInit(DEFAULT_POOL, &b, 1);
    NZ psDynBufAppendChar(&b, 'O');
    NZ psDynBufAppendChar(&b, 'K');
    NZ psDynBufAppendChar(&b, '!');
    DYNBUFCHECK(&b, "OK!");

    NZ psDynBufInit(DEFAULT_POOL, &b, 2);
    psDynBufReservePrepend(&b, 1);
    NZ psDynBufPrependChar(&b, '!');
    NZ psDynBufPrependChar(&b, 'K');
    NZ psDynBufPrependChar(&b, 'O');
    DYNBUFCHECK(&b, "OK!");

    NZ psDynBufInit(DEFAULT_POOL, &b, 5);
    NZ psDynBufAppendStr(&b, "pieces ");
    NZ psDynBufPrependStr(&b, "from ");
    NZ psDynBufAppendStr(&b, "put ");
    NZ psDynBufAppendStr(&b, "in the ");
    NZ psDynBufAppendStr(&b, "end ");
    NZ psDynBufPrependStr(&b, "string ");
    NZ psDynBufAppendStr(&b, "and the ");
    NZ psDynBufAppendStr(&b, "beginning.");
    NZ psDynBufPrependStr(&b, "Collecting ");
    DYNBUFCHECK(&b, "Collecting string from pieces put in the end and "
        "the beginning.");

    NZ psDynBufInit(DEFAULT_POOL, &b, 5);
    NZ psDynBufAppendStr(&b, "pieces ");
    NZ psDynBufPrependStr(&b, "from ");
    NZ psDynBufPrependStr(&b, "string ");
    {
        psDynBuf_t sub;
        NZ psDynBufSubInit(&b, &sub, 3);
        NZ psDynBufPrependStr(&sub, "the ");
        NZ psDynBufAppendStr(&sub, "end ");
        NZ psDynBufAppendStr(&sub, "and the ");
        NZ psDynBufPrependStr(&sub, "put in ");
        NZ psDynBufSubFinish(&sub);
    }
    NZ psDynBufAppendStr(&b, "beginning.");
    NZ psDynBufPrependStr(&b, "Collecting ");
    DYNBUFCHECK(&b, "Collecting string from pieces put in the end and "
        "the beginning.");

    NZ psDynBufInit(DEFAULT_POOL, &b, 5);
    NZ psDynBufAppendStr(&b, "middle.");
    NZ psDynBufPrependStr(&b, "Insert X ");
    {
        psDynBuf_t sub;
        NZ psDynBufSubInitAt(&b, &sub, 7, 1);
        NZ psDynBufAppendStr(&sub, "at");
        NZ psDynBufSubFinish(&sub);
    }
    DYNBUFCHECK(&b, "Insert at middle.");

    NZ psDynBufInit(DEFAULT_POOL, &b, 4);
    NZ psDynBufPrependStr(&b, "RemXXXove from middle.");
    {
        psDynBuf_t sub;
        NZ psDynBufSubInitAt(&b, &sub, 3, 3);
        NZ psDynBufSubFinish(&sub);
    }
    DYNBUFCHECK(&b, "Remove from middle.");

    NZ psDynBufInit(DEFAULT_POOL, &b, 4);
    psDynBufAppendStrf(&b, "Integer: %d", 42);
    DYNBUFCHECK(&b, "Integer: 42");

    NZ psDynBufInit(DEFAULT_POOL, &b, 3);
    NZ psDynBufPrependStr(&b, "Insert FOUR middle and remove also.");
    {
        psDynBuf_t sub;
        psDynBuf_t sub2;
        psDynBuf_t sub3;
        NZ psDynBufSubInitAt(&b, &sub, 7, 4);
        NZ psDynBufAppendStr(&sub, "twiXin");
        NZ psDynBufSubInitAt(&sub, &sub2, 3, 1);
        NZ psDynBufAppendStr(&sub2, "ceEXYDYSH ");
        NZ psDynBufSubInitAt(&sub2, &sub3, 2, 7);
        NZ psDynBufSubFinish(&sub3);
        NZ psDynBufSubFinish(&sub2);
        NZ psDynBufSubFinish(&sub);
    }
    DYNBUFCHECK(&b, "Insert twice in middle and remove also.");

    /* ASN.1 tests. */

    /* String of >=32 bytes including alphabets and digits. */
    const unsigned char *chars = (const unsigned char *)
                                 "ABCEFGHIJKLMNOPQRSTUWXYZ0123456789";
    unsigned char ones[256];
    psDynBuf_t sub;
    psDynBuf_t sub2;

    NZ psDynBufInit(DEFAULT_POOL, &b, 3);
    NZ psDynBufBeginConstructedTag(&b, &sub);
    NZ psDynBufBeginConstructedTag(&sub, &sub2);
    NZ psDynBufAppendAsn1TagGen(&sub2, 0x02, chars, 2);
    NZ psDynBufEndConstructedTag(&sub2, 0x30);
    NZ psDynBufEndConstructedTag(&sub, 0x30);
    DYNBUFCHECK_HEX(&b, "3006300402024142");

    NZ psDynBufInit(DEFAULT_POOL, &b, 3);
    NZ psDynBufAppendStr(&b, "Formattings string like it was ASN.1 DER: ");
    NZ psDynBufBeginConstructedTag(&b, &sub);
    NZ psDynBufBeginConstructedTag(&sub, &sub2);
    NZ psDynBufAppendAsn1TagGen(&sub2, 0x41, chars, 32);
    NZ psDynBufEndConstructedTag(&sub2, 0x30);
    NZ psDynBufEndConstructedTag(&sub, 0x30);
    DYNBUFCHECK(&b, "Formattings string like it was ASN.1 DER: "
        "0$0\"A ABCEFGHIJKLMNOPQRSTUWXYZ01234567");

    /* Use larger sizes. */
    Memset(ones, 1, sizeof ones);
    NZ psDynBufInit(DEFAULT_POOL, &b, 3);
    NZ psDynBufBeginConstructedTag(&b, &sub);
    NZ psDynBufBeginConstructedTag(&sub, &sub2);
    NZ psDynBufAppendAsn1TagGen(&sub2, 0x04, ones, 128);
    NZ psDynBufEndConstructedTag(&sub2, 0x30);
    NZ psDynBufEndConstructedTag(&sub, 0x30);
    DYNBUFCHECK_HEX(&b,
        "308186"
        "308183"
        "048180"
        /* "01" x 128 */
        "0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101");

    /* Use larger sizes. */
    Memset(ones, 1, sizeof ones);
    NZ psDynBufInit(DEFAULT_POOL, &b, 3);
    NZ psDynBufBeginConstructedTag(&b, &sub);
    NZ psDynBufBeginConstructedTag(&sub, &sub2);
    NZ psDynBufAppendAsn1TagGen(&sub2, 0x04, ones, 256);
    NZ psDynBufEndConstructedTag(&sub2, 0x30);
    NZ psDynBufEndConstructedTag(&sub, 0x30);
    DYNBUFCHECK_HEX(&b,
        "30820108"
        "30820104"
        "04820100"
        /* "01" x 256 */
        "01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101");

    return OK;
}

#define DYNBUFCHECK(x, y) FAIL_IF(dynbufcheck((x), (y)) == 0)
#define DYNBUFCHECK_HEX(x, y) FAIL_IF(dynbufcheck_hex((x), (y)) == 0)

#ifdef ENABLE_GLIB
#include "glib.h" /* Just for these functions currently using glib.
                     Glib has comprehensive support for UTF-8 and thus
                     allows comparison between this library and other
                     implementation. */

TEST_RESULT TEST_PsDynBufAppendUtf8(void)
{
    psDynBuf_t b;
    int res = 0;
    char *buf;
    int i;
    size_t len = 0;

    /* Go through all planes of unicode.
       This test also goes through some illegal encodings, but these seem
       to work ok. */
    for(i = 1; i <= 0x10FFFF; i++)
    {
        psRes_t rc;
        gunichar gch;
        psParseBuf_t pb;
        NZ psDynBufInit(DEFAULT_POOL, &b, 16);
        NZ psDynBufAppendUtf8(&b, i);
        NZ psDynBufAppendChar(&b, 0);
        unsigned int ch1, chz;
        buf = psDynBufDetach(&b, &len);
        FAIL_IF(buf == NULL);
        gch = g_utf8_get_char((const gchar *)buf);
        if (gch != i)
        {
            Printf("Encoding error at character %d - expect %d vs got %d\n",
                   i, i, (int) gch);
            FAIL_IF(gch != i);
        }
        FAIL_IF(g_utf8_strlen((const gchar *)buf, 16) != 1);

        rc = psParseBufFromStaticData(&pb, buf, len);
        FAIL_IF(rc != PS_SUCCESS);

        ch1 = psParseBufReadUtf8(&pb);
        chz = psParseBufReadUtf8(&pb);
        if (ch1 != (unsigned) i)
        {
            Printf("Decoding error at character %d/%x - expect %d vs got %d\n",
                   i, (unsigned int) i, i, (int) ch1);
        }
        FAIL_IF(ch1 != i);
        FAIL_IF(chz != 0);
        FAIL_IF(psParseBufFinish(&pb) != PS_SUCCESS);
        Free(buf);
    }
    return OK;
}

TEST_RESULT TEST_PsDynBufAppendUtf16(void)
{
    psDynBuf_t b;
    int res = 0;
    char *buf;
    int i;
    size_t len = 0;

    /* Go through all planes of unicode.
       This test also goes through some illegal encodings, but these seem
       to work ok. */
    for(i = 1; i <= 0x10FFFF; i++)
    {
        gunichar *gchp;
        gunichar gch;
        glong nread;
        glong nwritten;

        if (i >= 0xd800 && i <= 0xdfff)
        {
            continue; /* Illegal encodings skipped. */
        }

        NZ psDynBufInit(DEFAULT_POOL, &b, 16);
        NZ psDynBufAppendUtf16(&b, i);
        NZ psDynBufAppendUtf16(&b, 0);
        buf = psDynBufDetach(&b, &len);
        FAIL_IF(buf == NULL);
        FAIL_IF(len != 4 && len != 6);

        /* Byte order swap: first two characters. */
        buf[0] ^= buf[1];
        buf[1] ^= buf[0];
        buf[0] ^= buf[1];
        buf[2] ^= buf[3];
        buf[3] ^= buf[2];
        buf[2] ^= buf[3];
        gchp = g_utf16_to_ucs4((const gunichar2 *)buf, -1,
                               &nread, &nwritten, NULL);
        FAIL_IF(gchp == NULL);
        gch = *gchp;

        if (gch != i)
        {
            Printf("Encoding error at character %d - expect %d vs got %d\n",
                   i, i, (int) gch);
            FAIL_IF(gch != i);
        }

        FAIL_IF((len == 4 && nread != 1) || (len == 6 && nread != 2));
        FAIL_IF(nwritten != 1);

        g_free(gchp);
        Free(buf);
    }
    return OK;
}
#endif

TEST_RESULT TEST_PsDynBufAppendUtf32(void)
{
    psDynBuf_t b;
    int res = 0;
    char *buf;
    int i;
    size_t len = 0;

    /* Go through all planes of unicode and bit more
       This test also goes through some illegal encodings, but these seem
       to work ok. */
    for(i = 1; i <= 0x2FFFFF; i++)
    {
        uint32_t r = 0;
        NZ psDynBufInit(DEFAULT_POOL, &b, 16);
        NZ psDynBufAppendUtf32(&b, i);
        NZ psDynBufAppendUtf32(&b, 0);
        buf = psDynBufDetach(&b, &len);
        FAIL_IF(buf == NULL);
        FAIL_IF(len != 8);
        r = (unsigned char) buf[0];
        r <<= 8;
        r |= (unsigned char) buf[1];
        r <<= 8;
        r |= (unsigned char) buf[2];
        r <<= 8;
        r |= (unsigned char) buf[3];
        if (r != i)
        {
            Printf("Encoding error at character %d - expect %d vs got %d\n",
                   i, i, (int) r);
            FAIL_IF(r != i);
        }
        psFreeN(buf);
    }
    return OK;
}

/* ASN.1 DER input representing OCSP request used in TEST_PsParseBuf. */
static const unsigned char req0_der[] = {
    0x30, 0x68, 0x30, 0x66, 0x30, 0x3f, 0x30, 0x3d, 0x30, 0x3b, 0x30, 0x09,
    0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14, 0x82,
    0x94, 0x68, 0x3e, 0xa5, 0xf1, 0x04, 0x9e, 0xc6, 0x2b, 0x2b, 0x02, 0xa5,
    0xdd, 0x04, 0x7c, 0x1a, 0xfa, 0xf8, 0x0f, 0x04, 0x14, 0x64, 0x15, 0xe2,
    0x5e, 0x3e, 0x88, 0x1a, 0xdd, 0x6d, 0x29, 0x3d, 0x1a, 0xe5, 0x74, 0xe2,
    0xdb, 0x4f, 0xf3, 0x06, 0xb4, 0x02, 0x02, 0x10, 0x04, 0xa2, 0x23, 0x30,
    0x21, 0x30, 0x1f, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30,
    0x01, 0x02, 0x04, 0x12, 0x04, 0x10, 0x81, 0x7f, 0x85, 0x0b, 0xaf, 0xdc,
    0x05, 0x4e, 0x55, 0xb7, 0x13, 0x46, 0x85, 0x13, 0x59, 0xe4
};
static unsigned int req0_der_len = 106;

/* Extra print outs of advancing in parsing. */
#ifdef PS_TEST_DEBUG_PARSING
void checkpoint(const psParseBuf_t *p, const char *s, int l, const char *f)
{
    char ch[20] = "0123456789abcdef...";
    int i;

    for (i = 0; i < 8; i++)
    {
        if (psParseCanRead(p, i + 1))
        {
            Sprintf(ch + i * 2, "%02x", p->buf.start[i]);
        }
        else
        {
            ch[i * 2] = 0;
        }
    }

    if (ch[0] == 0)
    {
        Strcpy(ch, "<EOF>");
    }

    Printf("%s:%d parsing %s at %s\n", f, l, s, ch);
}

# define CHECKPOINT(psParseBuf_t_p) \
    checkpoint(psParseBuf_t_p, #psParseBuf_t_p, __LINE__, __FILE__)
#else
# define CHECKPOINT(psParseBuf_t_p) do { } while (0)
#endif
int32_t parseOcspReq(const void *data, size_t datalen,
    psBuf_t *nonceExtension)
{
    psParseBuf_t pb;
    psParseBuf_t ocspRequest;
    psParseBuf_t tbsRequest;
    psParseBuf_t extensions;
    psParseBuf_t extension;
    psParseBuf_t requestList;
    psParseBuf_t request;
    psParseBuf_t requestCert;
    psParseBuf_t requestCertContent;
    int rc;

    rc = psParseBufFromStaticData(&pb, data, datalen);
    FAIL_IF(rc != PS_SUCCESS);
    CHECKPOINT(&pb);
    psParseBufReadSequenceSub(&pb, &ocspRequest);
    /* Ensure subbuffer is advanced and main buffer is not. */
    FAIL_IF(ocspRequest.buf.start - pb.buf.start != 2 &&
        ocspRequest.err == 0);
    CHECKPOINT(&ocspRequest);
    psParseBufReadSequenceSub(&ocspRequest, &tbsRequest);
    CHECKPOINT(&tbsRequest);
    FAIL_IF(tbsRequest.buf.start - pb.buf.start != 4 &&
        tbsRequest.err == 0);
    /* Ignore version number (v1 == 0) if present. */
    CHECKPOINT(&tbsRequest);
    psParseBufTrySkipBytes(&tbsRequest, (const unsigned char *)
        "\xA0\x03\x02\x01\x00", 5);
    CHECKPOINT(&tbsRequest);
    /* Skip requestorName if present. */
    psParseBufTrySkipTag(&tbsRequest, 0xA1);
    CHECKPOINT(&tbsRequest);
    /* Skip requestList (must be present with at least one request). */
    psParseBufReadSequenceSub(&tbsRequest, &requestList);
    CHECKPOINT(&requestList);
    psParseBufReadSequenceSub(&requestList, &request);
    CHECKPOINT(&request);
    psParseBufReadSequenceSub(&request, &requestCert);
    CHECKPOINT(&requestCert);
    psParseBufReadSequenceSub(&requestCert, &requestCertContent);
    psParseBufFinish(&requestCertContent);
    psParseBufFinish(&requestCert);
    psParseBufFinish(&request);
    psParseBufFinish(&requestList);
    CHECKPOINT(&tbsRequest);
    if (psParseBufTryReadTagSub(&tbsRequest, &extensions, 0xA2))
    {
        CHECKPOINT(&extensions);
        while (psParseBufTryReadSequenceSub(&extensions, &extension))
        {
            psParseBuf_t sub;
            CHECKPOINT(&extension);
            psParseBufReadSequenceSub(&extension, &sub);
            CHECKPOINT(&sub);
            if (psParseBufTrySkipBytes(
                    &sub,
                    (const unsigned char *)
                    "\x06\x09\x2b\x06\x01\x05"
                    "\x05\x07\x30\x01\x02", 11))
            {
                CHECKPOINT(&sub);
                psParseBufReadTagRef(
                    &sub, nonceExtension, 0x04);
            }
            psParseBufFinish(&sub);
            if (psParseBufFinish(&extension) != PS_SUCCESS)
            {
                break;
            }
        }
        psParseBufFinish(&extensions);
    }
    CHECKPOINT(&tbsRequest);
    psParseBufFinish(&tbsRequest);
    return psParseBufFinish(&ocspRequest);
}

TEST_RESULT TEST_PsParseBuf(void)
{
    unsigned char zero[256] = { 0 };
    psBuf_t nonceExtension = { NULL };
    int rc = parseOcspReq(req0_der, req0_der_len, &nonceExtension);

    FAIL_IF(rc != PS_SUCCESS);
    FAIL_IF(nonceExtension.start[0] != 0x04 ||
        nonceExtension.start[1] != 0x10 ||
        nonceExtension.start[2] != 0x81);

    /* Try parsing something that is not valid OCSPRequest. */
    nonceExtension.start = NULL;
    rc = parseOcspReq(zero, sizeof zero, &nonceExtension);
    FAIL_IF(rc == PS_SUCCESS);
    FAIL_IF(nonceExtension.start != NULL);

    /* Try parsing something that is not valid OCSPRequest. */
    nonceExtension.start = NULL;
    rc = parseOcspReq(req0_der + 2, req0_der_len - 2, &nonceExtension);
    FAIL_IF(rc == PS_SUCCESS);
    FAIL_IF(nonceExtension.start != NULL);

    return OK;
}

TEST_RESULT TEST_PsGetBrokenDownGMTime(void)
{
    /* Note: This test does not test for overflow of time. */
    int offset;
    int i;

    (void) psGetEpochTime();
    /* Try different offsets, with granularity of 10 */
    for (offset = -100; offset < 101; offset += 10)
    {
        int success = 0;
        /* Note: try this code twice, just in case seconds change. */
        for (i = 0; i < 2; i++)
        {
            char *time1;
            char tm_s[80];
            char tm2_s[80];
            char *tz;
            psBrokenDownTime_t tm;
            psBrokenDownTime_t tm2;
            time_t t;
            int32 res;

            res = psGetBrokenDownGMTime(&tm, offset);
            FAIL_IF(res != PS_SUCCESS);

            res = psGetBrokenDownGMTime(&tm2, offset);
            FAIL_IF(res != PS_SUCCESS);

            /* Set TZ to UTC so local time zone gives same results than GM. */
            tz = Getenv("TZ");
            if (tz)
            {
                tz = strdup(tz);
            }
            setenv("TZ", "", 1);
            tzset();

            t = psGetEpochTime() + offset;
            time1 = ctime(&t);
            FAIL_IF(time1 == NULL);
            time1 = strdup(time1);

            if (tz)
            {
                setenv("TZ", tz, 1);
                Free(tz);
            }
            else
            {
                unsetenv("TZ");
            }
            tzset();
            tm_s[0] = 0;
            (void) strftime(tm_s, sizeof tm_s, "%a %b %e %T %Y%n", &tm);
            (void) strftime(tm2_s, sizeof tm2_s, "%a %b %e %T %Y%n", &tm);
            success += (Strcmp(time1, tm_s) == 0) && (Strcmp(tm_s, tm2_s) == 0);
            Free(time1);
        }
        FAIL_IF(success == 0);
    }
    return OK;
}

TEST_RESULT TEST_PsBrokenDownTimeAdd(void)
{
    int i;
    time_t start = psGetEpochTime();
    psBrokenDownTime_t tm_start;
    int32 res;
    psBrokenDownTime_t tm_prev;

    /* Note: also includes some testing for psBrokenDownTimeCmp() and
       psBrokenDownTimeStr(). */

    res = psGetBrokenDownGMTime(&tm_start, 0);
    FAIL_IF(res != PS_SUCCESS);

    /* Try offsets up-to around 10 years. */
    for (i = 0; i < 316224000; i++)
    {
        time_t t1 = start + i;
        char *time1;
        char tm_s[80];
        psBrokenDownTime_t tm;

        time1 = asctime(gmtime(&t1));
        Memcpy(&tm, &tm_start, sizeof(tm));
        res = psBrokenDownTimeAdd(&tm, i);
        FAIL_IF(res != PS_SUCCESS);

        tm_s[0] = 0;
        (void) strftime(tm_s, sizeof tm_s, "%a %b %e %T %Y%n", &tm);

        if (Strcmp(tm_s, time1) != 0)
        {
            Printf("Time comparison failure: offset=%d\n"
                "Time1: %sTime2: %s", i, time1, tm_s);
        }
        FAIL_IF(Strcmp(tm_s, time1) != 0);
        if (i > 0)
        {
            FAIL_IF(psBrokenDownTimeCmp(&tm_prev, &tm) >= 0);
            FAIL_IF(psBrokenDownTimeCmp(&tm, &tm_prev) <= 0);
        }
        /* Accelerate going through number space. */
        if (i > 100000)
        {
            i += 100000;
        }
        Memcpy(&tm_prev, &tm, sizeof(tm));
    }

    return OK;
}

TEST_RESULT TEST_PsBrokenDownTimeImport(void)
{
    char s[PS_BROKENDOWN_TIME_STR_LEN];
    int y2 = PS_BROKENDOWN_TIME_IMPORT_2DIGIT_YEAR;
    int y4 = 0;
    psBrokenDownTime_t t;
    int err;

#undef IMPORT_TEST
#define IMPORT_TEST(in, opts, res, expected)    \
    do { \
        err = psBrokenDownTimeImport(&t, in, Strlen(in), opts);         \
        Strcpy(s, "???");                                               \
        (void) psBrokenDownTimeStr(&t, &s);                             \
        /* Debugging? Printf("%s:%u => %s:%d\n", in, opts, s, err); */  \
        FAIL_IF((res) != err);                                          \
        if ((res) == PS_SUCCESS) {                                      \
            FAIL_IF(Strcmp(s, expected) != 0);                          \
        }                                                               \
    } while (0)
    IMPORT_TEST("20161108190048Z", y4, PS_SUCCESS, "20161108190048Z");
    IMPORT_TEST("20161108190048", y4, PS_SUCCESS, "20161108190048Z");
    IMPORT_TEST("161108190048Z", y2, PS_SUCCESS, "20161108190048Z");
    IMPORT_TEST("20160229111111Z", y4, PS_SUCCESS, "20160229111111Z");
    IMPORT_TEST("480229111111Z", y2, PS_SUCCESS, "20480229111111Z");
    IMPORT_TEST("861108190048Z", y2, PS_SUCCESS, "19861108190048Z");

    /* Leap second is accepted. */
    IMPORT_TEST("301108235960Z", y2, PS_SUCCESS, "20301108235960Z");

    /* Double leap second is not accepted. */
    IMPORT_TEST("301108235961Z", y2, PS_FAILURE, "20301108235961Z");
    /* Import error: Do not accept large amount of leap seconds. */
    IMPORT_TEST("301108235970Z", y2, PS_FAILURE, "");
    /* Import error: no hour/minutes/seconds */
    IMPORT_TEST("20161108", y4, PS_FAILURE, "");
    IMPORT_TEST("2016110811223", y4, PS_FAILURE, "");
    IMPORT_TEST("161108", y2, PS_FAILURE, "");
    IMPORT_TEST("16110811223", y2, PS_FAILURE, "");
    IMPORT_TEST("20160332111111Z", y4, PS_FAILURE, "");
    /* Import error: month day too large for specific month. */
    IMPORT_TEST("20160230111111Z", y4, PS_FAILURE, "");
    IMPORT_TEST("20170229111111Z", y4, PS_FAILURE, "");
    IMPORT_TEST("20180229111111Z", y4, PS_FAILURE, "");
    IMPORT_TEST("20170431111111Z", y4, PS_FAILURE, "");
    /* Test time zone is ignored. */
    IMPORT_TEST("20161108190048+0200", y4, PS_SUCCESS, "20161108190048Z");
    IMPORT_TEST("161108190048+0200", y2, PS_SUCCESS, "20161108190048Z");
    return OK;
}

TEST_RESULT TEST_PsBrokenDownTimeImportSeconds(void)
{
    char s[PS_BROKENDOWN_TIME_STR_LEN];
    psBrokenDownTime_t t;
    int err;
    int supported = 0;

    /* Note: This test assumes time_t is represented as an integer value
       rather than structure. This is true for most systems, but not all.
       You may need to disable this test on some platforms. */

#undef IMPORT_TEST
#define IMPORT_TEST(in, res, expected) \
    do { \
        err = psBrokenDownTimeImportSeconds(&t, in);                    \
        Strcpy(s, "???");                                               \
        (void) psBrokenDownTimeStr(&t, &s);                             \
        /*Debugging? Printf("%ld => %s:%d\n", (long)in, s, err); */     \
        FAIL_IF((res) != err);                                          \
        if ((res) == PS_SUCCESS) {                                      \
            /* The platform uses some other Epoch than Unix 1970. */    \
            if (!supported && Strcmp(s, expected) != 0) { return SKIPPED; } \
            FAIL_IF(Strcmp(s, expected) != 0);                          \
        }                                                               \
    } while (0)
    IMPORT_TEST(7, PS_SUCCESS, "19700101000007Z");
    IMPORT_TEST(1000000000, PS_SUCCESS, "20010909014640Z");
    supported = 1; /* Previous tests show this is likely Unix date. */
    IMPORT_TEST(2000000001, PS_SUCCESS, "20330518033321Z");
    /* Overflow of 32-bit Unix date. */
    IMPORT_TEST((psTimeSeconds_t) 2147483647, PS_SUCCESS, "20380119031407Z");
    IMPORT_TEST((psTimeSeconds_t) 2147483648U, PS_SUCCESS, "20380119031408Z");
    IMPORT_TEST((psTimeSeconds_t) 3000000000U, PS_SUCCESS, "20650124052000Z");
    return OK;
}

TEST_RESULT TEST_PsToUtf8String(void)
{
    unsigned char *uc_string;
    size_t uc_string_len;
    int32 err;

#undef CONVERT_TEST
#define CONVERT_TEST(in, ch, opt, res, expected)                        \
    do {                                                                \
        uc_string = NULL;                                               \
        err = psToUtf8String(DEFAULT_POOL,                              \
                             (const unsigned char *) in,                \
                             sizeof(in) - 1,                            \
                             ch, &uc_string, &uc_string_len, opt);      \
        /* If debugging you can uncomment next printf. */               \
        /* Printf("%s => %s:%d\n", in, uc_string ?                      \
           (const char *) uc_string : "(null)", err); */                \
        FAIL_IF((res) != err);                                          \
        if ((res) == PS_SUCCESS) {                                      \
            FAIL_IF(uc_string_len != Strlen(expected) ||                \
                    Strcmp((char *) uc_string, expected) != 0);         \
        }                                                               \
        psFree(uc_string, DEFAULT_POOL);                                \
    } while (0)

    CONVERT_TEST("100", PS_STRING_NUMERIC_STRING, 0, PS_SUCCESS, "100");
    CONVERT_TEST("\0A\0B", PS_STRING_BMP_STRING, PS_STRING_DUAL_NIL,
        PS_SUCCESS, "AB");
    CONVERT_TEST("ABC", PS_STRING_PRINTABLE_STRING, 0, PS_SUCCESS, "ABC");
    CONVERT_TEST("\0\xE4\x08\0\xFE\xFF\0b\0C",
        PS_STRING_BMP_STRING, 0, PS_SUCCESS,
        "\xC3\xA4" "\xE0\xA0\x80" "\xEF\xBB\xBF" "bC");
    CONVERT_TEST("\xD8\x3E\xDD\x20",
                 PS_STRING_UTF16_STRING, 0, PS_SUCCESS, "\xF0\x9F\xA4\xA0");
    CONVERT_TEST("100", PS_STRING_UTF8_STRING, 0, PS_SUCCESS, "100");
    CONVERT_TEST("ABC", PS_STRING_TELETEX_STRING, 0, PS_SUCCESS, "ABC");
    CONVERT_TEST("ABC\xE0", PS_STRING_TELETEX_STRING, 0, PS_SUCCESS, "ABC\xE2\x84\xA6");
    /* Error cases. */
    CONVERT_TEST("\0A\0B\0", PS_STRING_BMP_STRING, 0, PS_FAILURE, "");
    CONVERT_TEST("foo.com\0bar.com", PS_STRING_PRINTABLE_STRING, 0,
        PS_LIMIT_FAIL, "");
    CONVERT_TEST("f\xC3\xA4.com", PS_STRING_PRINTABLE_STRING, 0,
        PS_LIMIT_FAIL, "");
    CONVERT_TEST("$", PS_STRING_TELETEX_STRING, 0, PS_LIMIT_FAIL, "$");
    CONVERT_TEST("\0a\xD8\x00", PS_STRING_BMP_STRING, 0, PS_LIMIT_FAIL, "");
    /* The following cases may be enabled if psToUtf8String() gets new
       features. */
    CONVERT_TEST("100", PS_STRING_NUMERIC_STRING, PS_STRING_STRICT,
        PS_UNSUPPORTED_FAIL, "100");
    CONVERT_TEST("100", (psStringType_t) 255, 0, PS_UNSUPPORTED_FAIL, "100");
    return OK;
}

TEST_RESULT TEST_PsToUtf16String(void)
{
    unsigned char *uc_string;
    size_t uc_string_len;
    int32 err;

#undef CONVERT_TEST
#undef Z1
#define Z1 "\000"
#undef Z2
#define Z2 "\000\000"
#undef Z4
#define Z4 "\000\000\000\000"
#define CONVERT_TEST(in, ch, opt, res, expected)                        \
    do {                                                                \
        uc_string = NULL;                                               \
        err = psToUtf16String(DEFAULT_POOL,                             \
                              (const unsigned char *) in,               \
                              sizeof(in) - 1,                           \
                              ch, &uc_string, &uc_string_len, opt);     \
        uc_string_len += (opt & PS_STRING_DUAL_NIL) ? 4 : 2;            \
        /* If debugging you may uncomment next three lines. */          \
        /* PS_PRNF_CTX; */                                              \
        /* psPrnf("%s => %s:%d\n", in, uc_string ? */                   \
        /* (const char *) PSA_SSTR(uc_string, uc_string_len) : "(null)", err); */ \
        FAIL_IF((res) != err);                                          \
        if ((res) == PS_SUCCESS) {                                      \
            FAIL_IF(uc_string_len != sizeof(expected) - 1 ||            \
                    Memcmp((char *) uc_string, expected, sizeof(expected) - 1) != 0); \
        }                                                               \
        psFree(uc_string, DEFAULT_POOL);                                \
    } while (0)

    CONVERT_TEST("100", PS_STRING_NUMERIC_STRING, 0, PS_SUCCESS, Z1"1"Z1"0"Z1"0"Z2);
    CONVERT_TEST("\0A\0B", PS_STRING_BMP_STRING, PS_STRING_DUAL_NIL,
        PS_SUCCESS, Z1"A"Z1"B"Z4);
    CONVERT_TEST("ABC", PS_STRING_PRINTABLE_STRING, 0, PS_SUCCESS, Z1"A"Z1"B"Z1"C"Z2);
    CONVERT_TEST("\0\xE4\x08\0\xFE\xFF\0b\0C",
        PS_STRING_BMP_STRING, 0, PS_SUCCESS,
                 "\0\xE4" "\x08\x00" "\xFE\xFF" "\000b" "\000C" Z2);
    CONVERT_TEST("\xC3\xA4" "\xE0\xA0\x80" "\xEF\xBB\xBF" "\xF0\x9F\xA4\xA0" "bC",
                 PS_STRING_UTF8_STRING, 0, PS_SUCCESS,
                 "\0\xE4\x08\0\xFE\xFF\xD8\x03E\xDD\x20\0b\0C"Z2);
    CONVERT_TEST("100", PS_STRING_UTF8_STRING, 0, PS_SUCCESS, Z1"1"Z1"0"Z1"0"Z2);

    /* Error cases. */
    CONVERT_TEST("\0A\0B\0", PS_STRING_BMP_STRING, 0, PS_FAILURE, "");
    CONVERT_TEST("foo.com\0bar.com", PS_STRING_PRINTABLE_STRING, 0,
        PS_LIMIT_FAIL, "");
    CONVERT_TEST("f\xC3\xA4.com", PS_STRING_PRINTABLE_STRING, 0,
        PS_LIMIT_FAIL, "");
    CONVERT_TEST("\0a\xD8\x00", PS_STRING_BMP_STRING, 0, PS_LIMIT_FAIL, "");
    /* The following cases may be enabled if psToUtf32String() gets new
       features. */
    CONVERT_TEST("100", PS_STRING_NUMERIC_STRING, PS_STRING_STRICT,
        PS_UNSUPPORTED_FAIL, Z1"1"Z1"0"Z1"0"Z2);
    CONVERT_TEST("100", (psStringType_t) 255, 0, PS_UNSUPPORTED_FAIL, Z1"1"Z1"0"Z1"0"Z2);
    return OK;
}

TEST_RESULT TEST_PsToUtf32String(void)
{
    unsigned char *uc_string;
    size_t uc_string_len;
    int32 err;

#undef CONVERT_TEST
#undef Z3
#define Z3 "\000\000\000"
#undef Z4
#define Z4 "\000\000\000\000"
#undef Z8
#define Z8 "\000\000\000\000\000\000\000\000"
#define CONVERT_TEST(in, ch, opt, res, expected)                        \
    do {                                                                \
        uc_string = NULL;                                               \
        err = psToUtf32String(DEFAULT_POOL,                             \
                              (const unsigned char *) in,               \
                              sizeof(in) - 1,                           \
                              ch, &uc_string, &uc_string_len, opt);     \
        uc_string_len += (opt & PS_STRING_DUAL_NIL) ? 8 : 4;            \
        /* If debugging you may uncomment next three lines. */          \
        /* PS_PRNF_CTX; */                                              \
        /* psPrnf("%s => %s:%d\n", in, uc_string ? */                   \
        /* (const char *) PSA_SSTR(uc_string, uc_string_len) : "(null)", err); */ \
        FAIL_IF((res) != err);                                          \
        if ((res) == PS_SUCCESS) {                                      \
            FAIL_IF(uc_string_len != sizeof(expected) - 1 ||            \
                    Memcmp((char *) uc_string, expected, sizeof(expected) - 1) != 0); \
        }                                                               \
        psFree(uc_string, DEFAULT_POOL);                                \
    } while (0)

    CONVERT_TEST("100", PS_STRING_NUMERIC_STRING, 0, PS_SUCCESS, Z3"1"Z3"0"Z3"0"Z4);
    CONVERT_TEST("\0A\0B", PS_STRING_BMP_STRING, PS_STRING_DUAL_NIL,
        PS_SUCCESS, Z3"A"Z3"B"Z8);
    CONVERT_TEST("ABC", PS_STRING_PRINTABLE_STRING, 0, PS_SUCCESS, Z3"A"Z3"B"Z3"C"Z4);
    CONVERT_TEST("\0\xE4\x08\0\xFE\xFF\0b\0C",
        PS_STRING_BMP_STRING, 0, PS_SUCCESS,
                 "\0\0\0\xE4" "\0\0\x08\x00" "\0\0\xFE\xFF" "\0\0\000b" "\0\0\000C" Z4);
    CONVERT_TEST("100", PS_STRING_UTF8_STRING, 0, PS_SUCCESS, Z3"1"Z3"0"Z3"0"Z4);

    /* Error cases. */
    CONVERT_TEST("\0A\0B\0", PS_STRING_BMP_STRING, 0, PS_FAILURE, "");
    CONVERT_TEST("foo.com\0bar.com", PS_STRING_PRINTABLE_STRING, 0,
        PS_LIMIT_FAIL, "");
    CONVERT_TEST("f\xC3\xA4.com", PS_STRING_PRINTABLE_STRING, 0,
        PS_LIMIT_FAIL, "");
    CONVERT_TEST("\0a\xD8\x00", PS_STRING_BMP_STRING, 0, PS_LIMIT_FAIL, "");
    /* The following cases may be enabled if psToUtf32String() gets new
       features. */
    CONVERT_TEST("100", PS_STRING_NUMERIC_STRING, PS_STRING_STRICT,
        PS_UNSUPPORTED_FAIL, Z3"1"Z3"0"Z3"0"Z4);
    CONVERT_TEST("100", (psStringType_t) 255, 0, PS_UNSUPPORTED_FAIL, Z3"1"Z3"0"Z3"0"Z4);
    return OK;
}

#include "osdep_errno.h"

/* Define new psSocket functions with static predefined response(s).
   I.e. stub/mock of underlying implementation of psSocket. */
typedef struct
{
    enum { ERROR, READ, WRITE, WRITE_IGNORE_DATA, ACCEPT, DONE } op;
    void *buf;
    size_t len;
} response_t;

response_t *current_response = { ERROR };

#include "osdep_stdarg.h"

void trace_func(const char *function, ...)
{
    va_list valist;
    char *addr;
    const char *beg = "";

    Printf("%s(", function);
    va_start(valist, function);
    do
    {
        addr = va_arg(valist, char *);
        if (addr)
        {
            Printf("%s%s", beg, addr);
            Free(addr);
            beg = ", ";
        }
    }
    while (addr != NULL);
    Printf(")\n");
    va_end(valist);
}

#ifdef USE_TRACE_FUNC /* Note: Only possible with GNU C library due to use of vasprintf. */

/* Get newly allocate string for the result. */
char *mallocPrintf(const char *fmt, ...)
{
    char *addr = NULL;

    va_list valist;

    va_start(valist, fmt);
    (void) vasprintf(&addr, fmt, valist);
    va_end(valist);
    return addr;
}

char *mallocBinaryString(void *in, size_t sz)
{
    unsigned char *s = in;
    char *mem;
    char *o;
    size_t sza;

    sza = sz + 1;
    if (sza == 0)
    {
        return strdup("{size-overflow}");
    }

    mem = Calloc(sza, 4); /* Multiplier 4 is always enough for all, including the worst case "\111" */
    if (!mem)
    {
        return NULL;
    }
    o = mem;
    *(o++) = '"';
    while (sz)
    {
        unsigned char ch = *(s++);
        if (ch == '\n' || ch == '\r')
        {
            *(o++) = '\\';
            *(o++) = ch == '\n' ? 'n' : 'r';
        }
        else if (ch >= 32 && ch <= 126 && ch != '"' && ch != '\\')
        {
            *(o++) = ch;
        }
        else
        {
            /* Octal */
            Sprintf(o, "\\%03o", ch);
            o += 4;
        }
        sz--;
    }
    *(o++) = '"';
    *(o++) = 0;
    return mem;
}

# define TRACE_FUNC trace_func
# define PTR(x) mallocPrintf("%p", (x))
# define CSTRING(x) mallocPrintf("\"%s\"", (const char *) (x))
# define STRING(x, len) mallocBinaryString(x, len)
# define SIZE(x) mallocPrintf("%zu", (x))
# define ULONG(x) mallocPrintf("%lu", (x))
# define INT(x) mallocPrintf("%d", (x))

#else
/* No tracing enabled. */
# define TRACE_FUNC(...) do { /* __VA_ARGS__ */ } while (0)
#endif

static ssize_t write_adaptor(psSocket_t *sock, const void *buf, size_t len)
{
    /* Note: This function needs to not cause signals if possible. */
    TRACE_FUNC(__func__, PTR(sock), STRING(buf, len), NULL);

    if (len > PS_MAX_SOCKET_SIZE)
    {
        len = PS_MAX_SOCKET_SIZE;
    }

    /* Produce output according to responses if available. */
    if (current_response->op == WRITE_IGNORE_DATA)
    {
        current_response++;
        return (ssize_t) len; /* Ignore */
    }
    if (current_response->op == WRITE)
    {
        if (len > current_response->len)
        {
            len = current_response->len;
        }
        if (Memcmp(buf, current_response->buf, len) != 0)
        {
            /* comparison mismatch. */
            current_response->op = ERROR; /* Mark operation as error. */
            errno = EIO;
            return (ssize_t) -1;
        }
        current_response->buf = len + (char *) current_response->buf;
        current_response->len -= len;
        if (current_response->len == 0)
        {
            current_response++;
        }
        return (ssize_t) len;
    }
    Printf("Unexpected IO command: Write\n");
    /* Generic IO error. */
    errno = EIO;
    return (ssize_t) -1;
}

static ssize_t read_adaptor(psSocket_t *sock, void *buf, size_t len)
{
    TRACE_FUNC(__func__, PTR(sock), PTR(buf), SIZE(len), NULL);

    /* This function needs to not cause signals if possible. */
    if (len > PS_MAX_SOCKET_SIZE)
    {
        len = PS_MAX_SOCKET_SIZE;
    }

    /* Produce output according to responses if available. */
    if (current_response->op == READ)
    {
        if (len > current_response->len)
        {
            len = current_response->len;
        }
        Memcpy(buf, current_response->buf, len);
        current_response->buf = len + (char *) current_response->buf;
        current_response->len -= len;
        if (current_response->len == 0)
        {
            current_response++;
        }
        return (ssize_t) len;
    }
    Printf("Unexpected IO command: Read\n");
    /* Generic IO error. */
    errno = EIO;
    return (ssize_t) -1;
}

static int isconnected_adaptor(psSocket_t *sock)
{
    TRACE_FUNC(__func__, PTR(sock), NULL);
    /* Consider always connected, for now. */
    return 1;
}

static int ioctl_adaptor(psSocket_t *sock, unsigned long request,
    void *opt_argp)
{
    TRACE_FUNC(__func__, PTR(sock), ULONG(request), PTR(opt_argp), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(request);
    PS_PARAMETER_UNUSED(opt_argp);
    return 0;
}

static int setsockopt_adaptor(psSocket_t *sock, int level, int optname,
    const void *optval, size_t optlen)
{
    TRACE_FUNC(__func__, PTR(sock), INT(level), INT(optname), PTR(optval), SIZE(optlen), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(level);
    PS_PARAMETER_UNUSED(optname);
    PS_PARAMETER_UNUSED(optval);
    PS_PARAMETER_UNUSED(optlen);
    return 0;
}

static int getsockopt_adaptor(psSocket_t *sock, int level, int optname,
    void *optval, size_t *optlen)
{
    TRACE_FUNC(__func__, PTR(sock), INT(level), INT(optname), PTR(optval), SIZE(*optlen), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(level);
    PS_PARAMETER_UNUSED(optname);
    PS_PARAMETER_UNUSED(optval);
    *optlen = 0;
    return 0;
}

static int fcntl_adaptor(psSocket_t *sock, int cmd, int opt_arg)
{
    TRACE_FUNC(__func__, PTR(sock), INT(cmd), INT(opt_arg), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(cmd);
    PS_PARAMETER_UNUSED(opt_arg);
    return 0;
}

static int socket_adaptor(psSocket_t *sock,
    int domain, psSocketType_t type, int protocol,
    void *typespecific)
{
    TRACE_FUNC(__func__, PTR(sock), INT(domain), INT(type), INT(protocol), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(domain);
    PS_PARAMETER_UNUSED(type);
    PS_PARAMETER_UNUSED(protocol);
    PS_PARAMETER_UNUSED(typespecific);
    return 65537; /* The identifier used as file descriptor. */
}

static int shutdown_adaptor(psSocket_t *sock, int how)
{
    TRACE_FUNC(__func__, PTR(sock), INT(how), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(how);
    return 0;
}

static int close_adaptor(psSocket_t *sock)
{
    TRACE_FUNC(__func__, PTR(sock), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    return 0;
}

static int connect_adaptor(psSocket_t *sock, const struct sockaddr *addr,
    size_t addrlen)
{
    TRACE_FUNC(__func__, PTR(sock), PTR(addr), SIZE(addrlen), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(addr);
    PS_PARAMETER_UNUSED(addrlen);
    return 0;
}

static int bind_adaptor(psSocket_t *sock, const struct sockaddr *addr,
    size_t addrlen)
{
    TRACE_FUNC(__func__, PTR(sock), PTR(addr), SIZE(addrlen), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(addr);
    PS_PARAMETER_UNUSED(addrlen);
    return 0;
}

static int listen_adaptor(psSocket_t *sock, int backlog)
{
    TRACE_FUNC(__func__, PTR(sock), INT(backlog), NULL);
    /* Stub implementation. */
    PS_PARAMETER_UNUSED(sock);
    PS_PARAMETER_UNUSED(backlog);
    return 0;
}

static int accept_adaptor(psSocket_t *listen_sock,
    struct sockaddr *addr, size_t *addrlen)
{
    TRACE_FUNC(__func__, PTR(listen_sock), PTR(addr), SIZE(addrlen), NULL);
    PS_PARAMETER_UNUSED(listen_sock);
    PS_PARAMETER_UNUSED(addr);
    PS_PARAMETER_UNUSED(addrlen);
    /* Currently unimplemented. */
    Abort();
    return 0;
}

static int getaddrinfo_adaptor(const char *node, const char *service,
    const struct addrinfo *hints,
    struct addrinfo **res)
{
    int err;

    TRACE_FUNC(__func__, CSTRING(node), CSTRING(service), PTR(hints), PTR(res), NULL);
    /* Stub version. */
    struct addrinfo hints_new;
    Memset(&hints_new, 0, sizeof(struct addrinfo));
    hints_new.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints_new.ai_socktype = SOCK_STREAM;
    hints_new.ai_flags = AI_NUMERICHOST;

    /* Ignore all input to address resolution, use static predefined values instead. */
    PS_PARAMETER_UNUSED(node);
    PS_PARAMETER_UNUSED(service);
    PS_PARAMETER_UNUSED(hints);

    err = getaddrinfo("127.0.0.1", "80", &hints_new, res);
    if (err != 0)
    {
        Abort(); /* With these parameters getaddrinfo works always. */
    }
    return 0;
}

static void freeaddrinfo_adaptor(struct addrinfo *res)
{
    TRACE_FUNC(__func__, PTR(res));
    freeaddrinfo(res);
}

static int getfd_adaptor(const psSocket_t *sock)
{
    TRACE_FUNC(__func__, PTR(sock));
    return sock->internal_fd; /* Intentionally use internal value here. */
}

const psSocketFunctions_t psSocketFunctions_static =
{
    &write_adaptor,
    &read_adaptor,
    &isconnected_adaptor,
    &ioctl_adaptor,
    &setsockopt_adaptor,
    &getsockopt_adaptor,
    &fcntl_adaptor,
    &socket_adaptor,
    &shutdown_adaptor,
    &close_adaptor,
    &connect_adaptor,
    &bind_adaptor,
    &listen_adaptor,
    &accept_adaptor,
    &getaddrinfo_adaptor,
    &freeaddrinfo_adaptor,
    &getfd_adaptor
};

#define RESPONSE_WRITE_TEXT(x){ WRITE, x, sizeof(x) - 1 }
#define RESPONSE_READ_TEXT(x) { READ, x, sizeof(x) - 1 }

response_t TEST_PsUrlInteract_responses1[] = {
    RESPONSE_WRITE_TEXT("GET / HTTP/"),
    { WRITE_IGNORE_DATA },
    RESPONSE_READ_TEXT(
        "HTTP/1.0 302 Found\r\n"
        "Cache-Control: private\r\n"
        "Content-Type: text/html; charset=UTF-8\r\n"
        "Location: https://www.example.com/\r\n"
        "Content-Length: 18\r\n"
        "\r\n"
        "<H1>302 Moved</H1>"),
    { READ,                            "", 0 },
    { DONE }
};

response_t TEST_PsUrlInteract_responses2[] = {
    RESPONSE_WRITE_TEXT("GET / HTTP/"),
    { WRITE_IGNORE_DATA },
    RESPONSE_READ_TEXT(
        "HTTP/1.0 302 Found\r\n"
        "Cache-Control: private\r\n"
        "Content-Type: text/html; charset=UTF-8\r\n"
        "Location: https://www.example.com/\r\n"
        "\r\n"
        "<H1>302 Moved</H1>"),
    { READ,                            "", 0 },
    { DONE }
};

response_t TEST_PsUrlInteract_responses3[] = {
    RESPONSE_WRITE_TEXT("GET /ok HTTP/"),
    { WRITE_IGNORE_DATA },
    RESPONSE_READ_TEXT(
        "HTTP/1.0 200 OK\r\n"
        "Content-Type: text/plain; charset=UTF-8\r\n"
        "\r\n"
        "OK"),
    { READ,                              "", 0 },
    { DONE }
};

TEST_RESULT TEST_PsUrlInteract(void)
{
    char outbuf[1024];
    size_t outbuf_sz = sizeof outbuf;
    int32 err;
    psUrlInteractState_t state;

    Memset(&state, 0, sizeof(state));
    state.type = PS_SOCKET_STREAM;
    state.func = &psSocketFunctions_static;

    current_response = TEST_PsUrlInteract_responses1;
    err = psUrlInteract("GET", "http://www.example.com/",
        NULL, NULL, 0,           /* headers in */
        NULL, 0,                 /* request */
        NULL, NULL, NULL, 0,     /* headers out */
        outbuf, &outbuf_sz, &state);
    FAIL_IF(err != 302);
    FAIL_IF(current_response->op != DONE);

    outbuf_sz = sizeof outbuf;
    current_response = TEST_PsUrlInteract_responses2;
    err = psUrlInteract("GET", "http://www.example.com/",
        NULL, NULL, 0,           /* headers in */
        NULL, 0,                 /* request */
        NULL, NULL, NULL, 0,     /* headers out */
        outbuf, &outbuf_sz, &state);
    FAIL_IF(err != 302);
    FAIL_IF(current_response->op != DONE);

    outbuf_sz = sizeof outbuf;
    current_response = TEST_PsUrlInteract_responses3;
    err = psUrlInteract("GET", "http://www.example.com/ok",
        NULL, NULL, 0,           /* headers in */
        NULL, 0,                 /* request */
        NULL, NULL, NULL, 0,     /* headers out */
        outbuf, &outbuf_sz, &state);
    FAIL_IF(err != 0);
    FAIL_IF(outbuf_sz != 2 || Memcmp(outbuf, "OK", 2) != 0);
    FAIL_IF(current_response->op != DONE);
    return OK;
}

uintptr_t next_stack_frame(void)
{
    /* Obtain approximate address of next stack frame by */
    char string_temp[128];

    psMemsetS(string_temp, 0x33, 128);
    return ((uintptr_t) &string_temp) & ~2;
}

TEST_RESULT TEST_PsMallocN(void)
{
    char *mem = psCallocN(3, 1);
    char *mem2;
    char *mem3;

    FAIL_IF(mem == NULL);
    FAIL_IF(mem[0] != 0 || mem[1] != 0 || mem[2] != 0);
    mem[0] = 'H';
    mem[1] = 'i';
    mem[2] = 0;
    FAIL_IF(psStrcmp(mem, "Hi") != 0);
    mem2 = psStrdupN(mem);
    FAIL_IF(mem2 == NULL);
    FAIL_IF(mem2 == mem);
    mem3 = psMallocN(3);
    FAIL_IF(mem3 == NULL);
    FAIL_IF(mem3 == mem || mem3 == mem2);
    Memcpy(mem3, mem, 3);
    psFreeN(mem);
    FAIL_IF(psStrcmp(mem2, "Hi") != 0);
    psFreeN(mem2);
    FAIL_IF(psStrcmp(mem3, "Hi") != 0);
    psFreeN(mem3);
    return OK;
}

TEST_RESULT TEST_PsTemp(void)
{
    char string0[128] = "Hi, ";

    PS_TEMP_ARRAYZ(char, *string, 128);
    char string1[128] = "There!";
    char *res;
    char *helper = (char *) next_stack_frame();

    /* Check overlaps. */
    FAIL_IF(*string > string0 - 128 && *string < string0);
    FAIL_IF(*string > string1 - 128 && *string < string1);
    FAIL_IF(*string > helper - 128 && *string < helper);

    if (PS_TEMP_IS_OK(*string))
    {
        /* Uncomment if debugging:
           Printf("Working with string at address: %p, copying from %p and %p\n",
               (const void *)*string,
               (const void *)string0, (const void *)string1);
         */
        Strcat((*string), string0);
        Strcat((*string), string1);
        res = PS_TEMP_RETURN_DUP(*string, psStrdupN);
        FAIL_IF(res == NULL);
        FAIL_IF(psStrcmp(res, "Hi, There!") != 0);
        psFreeN(res);
    }
    else
    {
        FAIL_IF(1); /* Unexpected memory allocation failure. */
    }
    return OK;
}

#define PS_TEMP_IS_DYNAMIC
#include "psUtil.h"

/* The same than TEST_PsTemp, but now dynamic allocation is used. */
TEST_RESULT TEST_PsTempDynamic(void)
{
    char string0[128] = "Hi, ";

    PS_TEMP_ARRAYZ(char, *string, 128);
    char string1[128] = "There!";
    char *res;
    char *helper = (char *) next_stack_frame();

    /* Check overlaps. */
    FAIL_IF(*string > string0 - 128 && *string < string0);
    FAIL_IF(*string > string1 - 128 && *string < string1);
    FAIL_IF(*string > helper - 128 && *string < helper);

    if (PS_TEMP_IS_OK(*string))
    {
        /* Uncomment if debugging:
           Printf("Working with string at address: %p, copying from %p and %p\n",
               (const void *)*string,
               (const void *)string0, (const void *)string1);
         */
        Strcat((*string), string0);
        Strcat((*string), string1);
        res = PS_TEMP_RETURN_DUP(*string, psStrdupN);
        FAIL_IF(res == NULL);
        FAIL_IF(psStrcmp(res, "Hi, There!") != 0);
        psFreeN(res);
    }
    else
    {
        FAIL_IF(1); /* Unexpected memory allocation failure. */
    }
    return OK;
}

#include "osdep_strings.h"
TEST_RESULT TEST_PsStrCaseCmp(void)
{
    int i;
    char s1[3] = { 'a', 'B', 0 };
    unsigned char s2[3];
    int r1;
    int r2;

    /* Some basic comparisons. */
    FAIL_IF(psStrCaseCmp("--Option", "--debug") == 0);
    FAIL_IF(psStrCaseCmp("--Option", "--Option-1") == 0);
    FAIL_IF(psStrCaseCmp("--Option-1", "--Option") == 0);
    FAIL_IF(psStrCaseCmp("--Option", "--option") != 0);
    FAIL_IF(psStrCaseCmp("ABC123", "abc123") != 0);
    FAIL_IF(psStrCaseCmp("AbC123", "aBc123") != 0);
    FAIL_IF(psStrCaseCmp("AbC123@", "aBc123`") == 0);

#ifdef Strcasecmp
    if (Getenv("LC_ALL") == NULL || strcmp(Getenv("LC_ALL"), "C") != 0)
#else
    if (1)
#endif
    {
        return OK_PARTIAL;
        /* The current locale could affect the results. Full test is skipped.
           To run this test in full, it is necessary to specific
           LC_ALL=C to ensure locale specific comparisons do not affect
           the results. */
    }

    /* Test against Strcasecmp. */
#ifdef Strcasecmp
    s2[2] = 0;
    for(i = 0; i < 65536; i++)
    {
        s2[0] = i & 255;
        s2[1] = (i / 256) & 255;
        r1 = Strcasecmp(s1, (const char *) s2);
        r2 = psStrCaseCmp(s1, (const char *) s2);
        if (r1 != r2)
        {
            FAIL_IF(r1 < 0 && r2 >= 0);
            FAIL_IF(r2 < 0 && r1 >= 0);
        }
    }

    s1[0] = 'A';
    s1[1] = 'b';
    for(i = 0; i < 65536; i++)
    {
        s2[0] = i & 255;
        s2[1] = (i / 256) & 255;
        r1 = Strcasecmp(s1, (const char *) s2);
        r2 = psStrCaseCmp(s1, (const char *) s2);
        if (r1 != r2)
        {
            FAIL_IF(r1 < 0 && r2 >= 0);
            FAIL_IF(r2 < 0 && r1 >= 0);
        }
    }

    s1[0] = '0';
    s1[1] = 'x';
    for(i = 0; i < 65536; i++)
    {
        s2[0] = i & 255;
        s2[1] = (i / 256) & 255;
        r1 = Strcasecmp(s1, (const char *) s2);
        r2 = psStrCaseCmp(s1, (const char *) s2);
        if (r1 != r2)
        {
            FAIL_IF(r1 < 0 && r2 >= 0);
            FAIL_IF(r2 < 0 && r1 >= 0);
        }
    }

    s1[0] = 160;
    for(i = 0; i < 65536; i++)
    {
        s2[0] = i & 255;
        s2[1] = (i / 256) & 255;
        r1 = Strcasecmp(s1, (const char *) s2);
        r2 = psStrCaseCmp(s1, (const char *) s2);
        if (r1 != r2)
        {
            FAIL_IF(r1 < 0 && r2 >= 0);
            FAIL_IF(r2 < 0 && r1 >= 0);
        }
    }

    s1[0] = 0xC3;
    s1[1] = 0xA4;
    for(i = 0; i < 65536; i++)
    {
        s2[0] = i & 255;
        s2[1] = (i / 256) & 255;
        r1 = Strcasecmp(s1, (const char *) s2);
        r2 = psStrCaseCmp(s1, (const char *) s2);
        if (r1 != r2)
        {
            FAIL_IF(r1 < 0 && r2 >= 0);
            FAIL_IF(r2 < 0 && r1 >= 0);
        }
    }

    s1[1] = 0;
    s2[1] = 0;
    for(i = 0; i < 65536; i++)
    {
        s1[0] = i & 255;
        s2[0] = (i / 256) & 255;
        r1 = Strcasecmp(s1, (const char *) s2);
        r2 = psStrCaseCmp(s1, (const char *) s2);
        if (r1 != r2)
        {
            FAIL_IF(r1 < 0 && r2 >= 0);
            FAIL_IF(r2 < 0 && r1 >= 0);
        }
    }
#endif /* Strcasecmp */

    return OK;
}

        
/* Printf("len: %d -- '%s'\n", len, buf); */
#define FAIL_UNLESS_STR(x) FAIL_IF(len != Strlen(buf) || Strcmp(buf, x) != 0)
TEST_RESULT TEST_PsPrnf(void)
{
    char buf[100];
    char buf2[100];  
    int len;
    int len2;
    char *nbuf;
    const unsigned char abchash[32] =
    {
        0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,
        0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,
        0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,
        0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad,
    };
    PS_PRNF_CTX;

    len = psSnprnf(buf, 100, PSF PSLN,
                   PSA_QSTR("hello, w\x01rld\xee!\x7F\x80\x81\xFF\n"));
    FAIL_UNLESS_STR("hello, w\\x01rld\\xEE!\\x7F\\x80\\x81\\xFF\\x0A\n");
    len = psSnprnf(buf, 100, PSF PSLN,
                   PSA_SSTR("hello, w\x01rld\xee!\x7F\x80\x81\xFF\n",
                            ~(size_t)0));
    FAIL_UNLESS_STR("hello, w.rld.!.....\n");
    len = psSnprnf(buf, 100, PSF PSF PSLN,
                   PSA_STR("hello"), PSA_STR(", world!"));
    FAIL_UNLESS_STR("hello, world!\n");
    len = psSnprnf(buf, 100, PSF PSF PSLN, PSA_STR(NULL), PSA_STR(", world!"));
    FAIL_UNLESS_STR("[null], world!\n");
    len = psSnprnf(buf, 100, PSF PSF PSLN, PSA_STR(NULL), PSA_STR(NULL));
    FAIL_UNLESS_STR("[null][null]\n");
    len = psSnprnf(buf, 100,
                   PSFX(10, 10) PSF PSLN, PSA_HEX(NULL, 3),
                   PSA_HEX((const unsigned char *)"\xDE\xAD\xB3\x3F", 4));
    FAIL_UNLESS_STR("    [null]DEADB33F\n");

    nbuf = psAsprnf(NULL, PSF PSF PSLN, PSA_STR("hello"), PSA_STR(", world!"));
    FAIL_IF(nbuf == NULL);
    Strncpy(buf, nbuf, 100);
    len = Strlen(nbuf);
    psFree(nbuf, NULL);
    FAIL_UNLESS_STR("hello, world!\n");

    /* DEBUG_printf is getting substituted with psPrnf. Test equivalent
       formats work. */
    len2 = psSnprintf(buf2, 100, "%s/%zu/%zu => %2m%.*s (rv = %d)\n",
                      "sha256",
                      (size_t)32,
                      (size_t)64,
                      32,
                      abchash,
                      0);

    len = psSnprnf(buf, 100, "%s/%zu/%zu => "PSF" (rv = %d)\n",
                   "sha256",
                   (size_t)32,
                   (size_t)64,
                   PSA_HEX(abchash, 32),
                   0);

    FAIL_IF(len != len2 || psStrCaseCmp(buf, buf2) != 0);

    len2 = psSnprintf(buf2, 100, "%s(%s)/%zu => %2m%.*s (rv = %d)\n",
                      "hmac-sha1", "a_password",
                      (size_t) 20,
                      20,
                      abchash,
                      0);

    len = psSnprnf(buf, 100, "%s(%s)/%zu => "PSF" (rv = %d)\n",
                   "hmac-sha1", "a_password",
                   (size_t) 20,
                   PSA_HEX(abchash, 20),
                   0);

    FAIL_IF(len != len2 || psStrCaseCmp(buf, buf2) != 0);

    len2 = psSnprintf(buf2, 100, "%2m%.*s", 32, abchash);
    len = psSnprnf(buf, 100, PSF, PSA_HEX(abchash, 32));

    FAIL_IF(len != len2 || psStrCaseCmp(buf, buf2) != 0);
    return OK;
}

static int check_seq_call = 0;
static int check_seq(const char *level, const char *unit)
{
    char buf[101] = { 0 };
    Snprintf(buf, 100, "%d-%s-%s", check_seq_call, level, unit);

    if (!Strcmp(buf, "0-Log_CallTrace-TEST1") ||
        !Strcmp(buf, "1-Log_Trace-TEST2") ||
        !Strcmp(buf, "2-Log_Verbose-TEST3") ||
        !Strcmp(buf, "3-Log_Debug-TEST4") ||
        !Strcmp(buf, "4-Log_Info-TEST5") ||
        !Strcmp(buf, "5-Log_Warning-TEST6") ||
        !Strcmp(buf, "6-Log_Error-TEST7") ||
        !Strcmp(buf, "7-Log_Fatal-TEST8"))
    {
        check_seq_call ++;
    }
    else
    {
        Fprintf(stderr, "check_seq problem at %s\n", buf);
        check_seq_call = -1;
    }
    return 0;
}

TEST_RESULT TEST_PsLogfSetHookEnabledCheck(void)
{
    check_seq_call = 0;
    FAIL_IF(psLogfSetHookEnabledCheck(&check_seq) != NULL);
    PS_LOGF_CALL_TRACE(TEST1, "this string should not print");
    PS_LOGF_TRACE(TEST2, "this string should not print");
    PS_LOGF_VERBOSE(TEST3, "this string should not print");
    PS_LOGF_DEBUG(TEST4, "this string should not print");
    PS_LOGF_INFO(TEST5, "this string should not print");
    PS_LOGF_WARNING(TEST6, "this string should not print");
    PS_LOGF_ERROR(TEST7, "this string should not print");
    PS_LOGF_FATAL(TEST8, "this string should not print");
    FAIL_IF(check_seq_call != 8);
    FAIL_IF(psLogfSetHookEnabledCheck(NULL) != &check_seq);
    FAIL_IF(psLogfSetHookEnabledCheck(NULL) != NULL);

    check_seq_call = 0;
    FAIL_IF(psLogfSetHookEnabledCheck(&check_seq) != NULL);
    PS_LOGF_CALL_TRACE_LN(TEST1, "this string should not print");
    PS_LOGF_TRACE_LN(TEST2, "this string should not print");
    PS_LOGF_VERBOSE_LN(TEST3, "this string should not print");
    PS_LOGF_DEBUG_LN(TEST4, "this string should not print");
    PS_LOGF_INFO_LN(TEST5, "this string should not print");
    PS_LOGF_WARNING_LN(TEST6, "this string should not print");
    PS_LOGF_ERROR_LN(TEST7, "this string should not print");
    PS_LOGF_FATAL_LN(TEST8, "this string should not print");
    FAIL_IF(check_seq_call != 8);
    FAIL_IF(psLogfSetHookEnabledCheck(NULL) != &check_seq);
    FAIL_IF(psLogfSetHookEnabledCheck(NULL) != NULL);
    return OK;
}

static int check_logf(const char *level, const char *unit,
                      const char *format_string, va_list va)
{
    /* This buffer is small, but sufficient for this simplistic test. */
    char buf[257] = { 0, };

    /* If formatting string contains unit and file:line formatting,
       strip those out.
       Note: This step could be omitted and the test would still work. */
    PS_LOGF_RAW_FMT(format_string, va);
    vsnprintf(buf, 256, format_string, va);
    /*
      Fprintf(stderr, "check_logf: printfed fmt=%s buf=%s\n",
      format_string, buf);
    */
    
    if ((check_seq_call == 0 && Strstr(format_string, "hello, world")) ||
        (check_seq_call == 1 && Strstr(buf, "DEED")))
    {
        check_seq_call++;
    }
    else
    {
        check_seq_call = -1;
        Fprintf(stderr, "check_logf: got level/unit: %s/%s: %s\n",
                level, unit, buf);
    }
    return 1;
}
    
static int never_log(const char *level, const char *unit)
{
    /* Use inputs to omit possible compiler warnings; return 0. */
    return (!!level) - (!!unit);
}

static int always_log(const char *level, const char *unit)
{
    /* Use inputs to omit possible compiler warnings; return 1. */
    return (!!level) * (!!unit);
}

TEST_RESULT TEST_PsLogfSetHookPrintf(void)
{
    const unsigned char buf[2] = { 0xDE, 0xED };
    check_seq_call = 0;
    FAIL_IF(psLogfSetHookPrintf(&check_logf) != NULL);
    FAIL_IF(psLogfSetHookEnabledCheck(&never_log) != NULL);
    FAIL_IF(PS_LOGF_IS_ENABLED(Log_Verbose, TEST0) != 0);
    PS_LOGF_CALL_TRACE(TEST1, "this string should not print");
    FAIL_IF(check_seq_call != 0);
    FAIL_IF(psLogfSetHookEnabledCheck(&always_log) != &never_log);
    FAIL_IF(PS_LOGF_IS_ENABLED(Log_Verbose, TEST0) != 1);
    PS_LOGF_CALL_TRACE(TEST2, "hello, world");
    PS_LOGF_TRACE(TEST3, "HEX: " PSF, PSA_HEX(buf, 2));
    FAIL_IF(check_seq_call != 2);
    psLogfSetHookEnabledCheck(NULL);
    FAIL_IF(psLogfSetHookPrintf(NULL) != &check_logf);
    return OK;
}

#include "osdep_math.h"
/* Print number that can be nan.
   If number is nan, always produce "NaN" as output. */
static char *printoptnan(char *buf, psStatItemFloat_t val)
{
    if (val == val)
    {
        /* Number. */
        sprintf(buf, "%.2"PR_PSSTATF, val);
    }
    else
    {
        /* Not a number. */
        memcpy(buf, "NaN", 4);
    }

    return buf;
}

static const char *p(psStat_t *s)
{
    static char out[100];
    char out2[100];
    char out3[100];

    sprintf(out,
            "Range: [%"PR_PSSTAT", %"PR_PSSTAT"] "
            "Avg: %s StdDev: %s Count: %"PR_PSSTAT"",
            psStatGetMin(s),
            psStatGetMax(s),
            printoptnan(out2, psStatGetAverage(s)),
            printoptnan(out3, psStatGetStdDeviation(s)),
            psStatGetCount(s));
    return out;
}

static int sne(const char *s1, const char *s2)
{
    if (strcmp(s1, s2) == 0)
    {
        return 0;
    }
    else
    {
        fprintf(stderr, "String comparison mismatch: \"%s\" vs. \"%s\"\n",
                s1, s2);
    }

    return 1;
}
    
TEST_RESULT TEST_PsStat(void)
{
    psStat_t *s;

    s = psStatNew();
    FAIL_IF(s == NULL);

    FAIL_IF(sne(p(s), "Range: [0, 0] Avg: NaN StdDev: NaN Count: 0"));

    psStatUpdate(s, 2);
    FAIL_IF(sne(p(s), "Range: [2, 2] Avg: 2.00 StdDev: 0.00 Count: 1"));

    psStatUpdate(s, 3);
    FAIL_IF(sne(p(s), "Range: [2, 3] Avg: 2.50 StdDev: 0.50 Count: 2"));

    psStatUpdate(s, 3);
    FAIL_IF(sne(p(s), "Range: [2, 3] Avg: 2.67 StdDev: 0.47 Count: 3"));
    psStatUpdate(s, 5);
    psStatUpdate(s, 7);
    psStatUpdate(s, 10);
    FAIL_IF(sne(p(s), "Range: [2, 10] Avg: 5.00 StdDev: 2.77 Count: 6"));

    psStatFree(s);
    return OK;
}

int main(int argc, char **argv)
{
    testsupp_start_test_program(argc, argv);

    if (argc == 2 && !Strcmp(argv[1], "--list"))
    {
        Printf("Tests available:\n");
    }
    else
    {
        Fprintf(stderr, "This test suite is work in progress.\n"
            "Currently tests only part of the functionality "
            "recently added to core.\n");
    }
    TEST(TEST_PsSnprintf);
    TEST(TEST_PsStrCaseCmp);
    TEST(TEST_PsGetBrokenDownGMTime);
    TEST(TEST_PsBrokenDownTimeAdd);
    TEST(TEST_PsBrokenDownTimeImport);
    TEST(TEST_PsBrokenDownTimeImportSeconds);
    TEST(TEST_PsBuf);
    TEST(TEST_PsDynBuf);
    TEST(TEST_PsParseBuf);
    TEST(TEST_PsToUtf8String);
    TEST(TEST_PsToUtf16String);
    TEST(TEST_PsToUtf32String);
#ifdef ENABLE_GLIB
    TEST(TEST_PsDynBufAppendUtf8);
    TEST(TEST_PsDynBufAppendUtf16);
#endif /* ENABLE_GLIB */
    TEST(TEST_PsDynBufAppendUtf32);
    TEST(TEST_PsUrlInteract);
    TEST(TEST_PsMallocN);
    TEST(TEST_PsTemp);
    TEST(TEST_PsTempDynamic);
    TEST(TEST_PsPrnf);
    TEST(TEST_PsLogfSetHookEnabledCheck);
    TEST(TEST_PsLogfSetHookPrintf);
    TEST(TEST_PsStat);
    return testsupp_summarize_results();
}

/* end of file test.c */
