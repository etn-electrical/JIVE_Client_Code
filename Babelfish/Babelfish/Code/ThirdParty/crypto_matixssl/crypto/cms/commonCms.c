/**
 *      @file    commonCms.c
 *
 *
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/
#include "matrixCmsApi.h"
#include "cryptoImpl.h"

#ifdef USE_CMS
/*
    ContentType ::= OBJECT IDENTIFIER

   Even though the syntax is defined as a SET OF AttributeValue, a
   content-type attribute MUST have a single attribute value; zero or
   multiple instances of AttributeValue are not permitted.

   The SignedAttributes and AuthAttributes syntaxes are each defined as
   a SET OF Attributes.  The SignedAttributes in a signerInfo MUST NOT
   include multiple instances of the content-type attribute.  Similarly,
   the AuthAttributes in an AuthenticatedData MUST NOT include multiple
   instances of the content-type attribute.
 */
int32 cmsParsePkcs9ContentType(const unsigned char **pp, uint32_t len,
    uint16_t *oi)
{
    return mcmsParsePkcsOid(pp, len, oi);
}

/* Just checking for valid ASN.1.  Don't really care about the time */
int32 cmsParsePkcs9SignedTime(const unsigned char **pp, uint32 len)
{
    const unsigned char *p = *pp, *end;
    uint32_t timeLen;

    end = p + len;

    if ((end - p) < 1 || ((*p != ASN_UTCTIME) && (*p != ASN_GENERALIZEDTIME)))
    {
        psTraceCrypto("Malformed Time type\n");
        return PS_PARSE_FAIL;
    }
    p++;
    if (getAsnLength32(&p, (uint32_t) (end - p), &timeLen, 0) < 0 ||
        (uint32_t) (end - p) < timeLen)
    {
        psTraceCrypto("Malformed Time type 2\n");
        return PS_PARSE_FAIL;
    }
    p += timeLen;
    *pp = (unsigned char *) p;
    return PS_SUCCESS;
}

int32 cmsParsePkcs9MessageDigest(psPool_t *pool, const unsigned char **pp,
    uint32 len, unsigned char **digest, psSize_t *digestLen)
{
    const unsigned char *p = *pp, *end;
    uint32_t l32;

    end = p + len;

    if ((*p++ != ASN_OCTET_STRING) || getAsnLength32(&p, (uint32_t) (end - p),
            &l32, 0) < 0 || (uint32_t) (end - p) < l32)
    {
        psTraceCrypto("Couldn't parse octet string encapsulated content info\n");
        return PS_FAILURE;
    }
    /* reasonable? */
    if (l32 != SHA1_HASH_SIZE && l32 != SHA256_HASH_SIZE &&
        l32 != SHA384_HASH_SIZE && l32 != SHA512_HASH_SIZE)
    {
        return PS_FAILURE;
    }
    if ((*digest = psMalloc(pool, l32)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    *digestLen = (uint16_t) l32;
    Memcpy(*digest, p, *digestLen);
    p += *digestLen;
    *pp = (unsigned char *) p;
    return PS_SUCCESS;
}

int32 cmsGetOctetString(psPool_t *pool, const unsigned char **pp, uint32 len,
    unsigned char **octetString, uint32_t *octetLen)
{
    const unsigned char *p = *pp, *end;

    end = p + len;

    if ((*p++ != ASN_OCTET_STRING) || getAsnLength32(&p, (int32) (end - p),
            octetLen, 0) < 0 || (uint32_t) (end - p) < *octetLen)
    {
        psTraceCrypto("Couldn't parse octet string encapsulated content info\n");
        return PS_FAILURE;
    }
    if ((*octetString = psMalloc(pool, *octetLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memcpy(*octetString, p, *octetLen);
    p += *octetLen;
    *pp = (unsigned char *) p;
    return PS_SUCCESS;
}
/*
    SignedAttributes ::= SET SIZE (1..MAX) OF Attribute

    Attribute ::= SEQUENCE {
        attrType OBJECT IDENTIFIER,
        attrValues SET OF AttributeValue } */
int32 mcmsMoveAttribToDER(psPool_t *pool, cmsAttributeSet_t *attribSet,
    unsigned char **out, psSize_t *outLen)
{
    int32 totalLen, subTotal, i, bufLen;
    unsigned char *p, *lenHelp, *buf;
    int32 attribLen[MCMS_MAX_ATTRIBS];
    cmsAttributeSet_t *attrib = attribSet;

    *out = NULL;
    *outLen = 0;

    totalLen = i = 0;
    /* reset and walk for length calculations */
    attrib = attribSet;
    while (attrib != NULL)
    {
        subTotal = attrib->dataLen;
        /* Even though the syntax is defined as a SET OF AttributeValue, a
            content-type attribute MUST have a single attribute value; zero or
            multiple instances of AttributeValue are not permitted. */
        subTotal += asn1TLOverhead(subTotal); /* The ASN_SET wrap */
        subTotal += attrib->oidLen;
        attribLen[i] = subTotal;
        subTotal += asn1TLOverhead(subTotal); /* The ASN_SEQUENCE */
        totalLen += subTotal;
        attrib = attrib->next;
        i++;
    }
    /* Outermost TL */
    bufLen = totalLen + asn1TLOverhead(totalLen);

    /* Ultimate destination */
    if ((buf = psMalloc(pool, bufLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }

    /* Begin the write */
    p = lenHelp = buf;
    *p = ASN_SET | ASN_CONSTRUCTED; p++; /* For hash.  For write, set to 0xA0 */
    p += asnHelpWriteLength(p, totalLen);
    /* reset and walk for writes */
    i = 0;
    attrib = attribSet;
    while (attrib != NULL)
    {
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, attribLen[i]);
        Memcpy(p, attrib->oid, attrib->oidLen);
        p += attrib->oidLen;

        *p = ASN_SET | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, attrib->dataLen);
        Memcpy(p, attrib->data, attrib->dataLen);
        p += attrib->dataLen;
        attrib = attrib->next;
        i++;
    }
    /* Sanity test */
    i = (int32) (p - lenHelp);
    psAssert(bufLen == i);

    *out = buf;
    *outLen = bufLen;
    return PS_SUCCESS;
}

void mcmsFreeSignerInfos(cmsSignerInfos_t *signers)
{
    cmsSignerInfos_t *prev, *signer = signers;

    while (signer)
    {
        if (signer->signerId)
        {
            if (signer->signerId->sn)
            {
                psFree(signer->signerId->sn, signer->pool);
            }
            psX509FreeDNStruct(&signer->signerId->dn, signer->pool);
            psFree(signer->signerId, signer->pool);
        }
        if (signer->digest)
        {
            psFree(signer->digest, signer->pool);
        }
        if (signer->sig)
        {
            psFree(signer->sig, signer->pool);
        }
        if (signer->signedAttrs)
        {
            psFree(signer->signedAttrs, signer->pool);
        }
        prev = signer;
        signer = signer->next;
        psFree(prev, prev->pool);
    }

}


void mcmsFreeAttributes(cmsAttributeSet_t *attribSet)
{
    cmsAttributeSet_t *prev, *attrib = attribSet;

    while (attrib != NULL)
    {
        if (attrib->data)
        {
            psFree(attrib->data, attrib->pool);
        }
        prev = attrib;
        attrib = attrib->next;
        psFree(prev, prev->pool);
    }
}

static void incrCounter(unsigned char *c)
{
    int i;

    for (i = 3; i >= 0; i--)
    {
        if ((int) c[i] < 0xFF)
        {
            c[i]++;
            break;
        }
        c[i] = 0;
    }
}

void psX963KeyDerivation(int32 hashSize, unsigned char *secret, int32 secretLen,
    unsigned char *out, int32 outKeyLen)
{
    unsigned char *k;
    unsigned char counter[4];
    unsigned char hash[MAX_HASH_SIZE];
    int32 i;
    psDigestContext_t ctx;


    Memset(counter, 0, sizeof(unsigned char) * 4);
    incrCounter(counter);

    k = out;
    i = 0;
    while (i < outKeyLen)
    {
        if (hashSize == SHA1_HASH_SIZE)
        {
            psSha1Init(&ctx.u.sha1);
            psSha1Update(&ctx.u.sha1, secret, secretLen);
            psSha1Update(&ctx.u.sha1, counter, 4);
            psSha1Final(&ctx.u.sha1, hash);
        }
        else if (hashSize == SHA256_HASH_SIZE)
        {
            psSha256Init(&ctx.u.sha256);
            psSha256Update(&ctx.u.sha256, secret, secretLen);
            psSha256Update(&ctx.u.sha256, counter, 4);
            psSha256Final(&ctx.u.sha256, hash);
        }
        else if (hashSize == SHA384_HASH_SIZE)
        {
            psSha384Init(&ctx.u.sha384);
            psSha384Update(&ctx.u.sha384, secret, secretLen);
            psSha384Update(&ctx.u.sha384, counter, 4);
            psSha384Final(&ctx.u.sha384, hash);
        }
        else
        {
            psSha512Init(&ctx.u.sha512);
            psSha512Update(&ctx.u.sha512, secret, secretLen);
            psSha512Update(&ctx.u.sha512, counter, 4);
            psSha512Final(&ctx.u.sha512, hash);
        }

        if ((outKeyLen - i) >= hashSize)
        {
            Memcpy(k, hash, hashSize);
            k += hashSize;
            i += hashSize;
            incrCounter(counter);
        }
        else
        {
            Memcpy(k, hash, (outKeyLen - i));
            i += (outKeyLen - i); /* take us equal */
        }
    }
}
#endif /* USE_CMS */
