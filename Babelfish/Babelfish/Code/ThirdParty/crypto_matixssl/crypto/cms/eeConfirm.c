/**
 *      @file    eeConfirm.c
 *
 *
 *      Encrypted Envelope validation.
 *      Confirm an EnvelopedData or AuthEnvelopedData type
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "matrixCmsApi.h"
#include "cryptoImpl.h"

#ifdef USE_CMS

int32 matrixCmsConfirmRecipient(psPool_t *pool,
    cmsEncryptedEnvelope_t *ee, const psX509Cert_t *originatorCert,
    const psPubKey_t *privKey)
{
    cmsRecipientInfos_t *recipient;
    const psX509Cert_t *certs, *cert;

# ifdef USE_RSA
    psRsaKey_t *key;
# endif
# ifdef USE_ECC
    psEccKey_t *eccKey;
# endif
    int32 outLen;
    uint32 ivLen, unwrapKeyLen, tmpLen;
    unsigned char out[MCMS_MAX_ECKA];
    unsigned char unwrapKey[32];       /* AES_256 max */

    Memset(out, 0, MCMS_MAX_ECKA);

    if (originatorCert != NULL)
    {
        /* FUTURE: Could need to loop through these certs if more than one */
        certs = originatorCert;
    }
    else
    {
        certs = ee->originator;
    }

    cert = NULL; /* assign if found */
    recipient = ee->recipients;
    while (recipient)
    {
    retryRecipient:
        if (recipient->originatorId == MCMS_ORIGIN_ID_ISSUERDN)
        {
            /* Find the originator public key from the cert */
            /* Remember it's the Issuer DN in the ID for some reason */
            if (certs == NULL)
            {
                psTraceCrypto("No originator certificate given\n");
                return MCMS_AED_FAIL_NO_CERT;
            }
            if ((Memcmp(certs->issuer.hash, recipient->originatorDn.hash,
                     SHA1_HASH_SIZE) == 0) && (certs->serialNumberLen ==
                                               recipient->originatorSnLen) && (Memcmp(certs->serialNumber,
                                                                                   recipient->originatorSn, certs->serialNumberLen) == 0))
            {
                cert = certs;
                break;
            }
        }
        else if (recipient->originatorId == MCMS_ORIGIN_ID_KEYID)
        {
            if (certs == NULL)
            {
                psTraceCrypto("No originator certificate given\n");
                return MCMS_AED_FAIL_NO_CERT;
            }
            if ((&certs->extensions.sk)->len != 0)
            {
                if (((&certs->extensions.sk)->len != recipient->originatorSnLen)
                    || Memcmp((&certs->extensions.sk)->id,
                        recipient->originatorSn,
                        (&certs->extensions.sk)->len) == 0)
                {
                    cert = certs;
                    break;
                }
            }
        }
        else
        {
            /* Raw key.  It's an ephemeral key so we can't exactly match
                it up with any certificate.  */
            /* psTraceCrypto("WARNING: anonymous public key\n"); */
            cert = certs;
            break;
        }
        recipient = recipient->next;
    }
    if (recipient == NULL)
    {
        psTraceCrypto("Orginator cert not found\n");
        return MCMS_AED_FAIL_NO_CERT;
    }

    if (recipient->originatorId == MCMS_ORIGIN_ID_KEYID ||
        recipient->originatorId == MCMS_ORIGIN_ID_ISSUERDN)
    {
        if (cert == NULL)
        {
            psTraceCrypto("Orginator cert not found\n");
            return MCMS_AED_FAIL_NO_CERT;
        }
    }

    if (recipient->version == 0 || recipient->version == 2)
    {
        /* Key Transport */
        ivLen = 0;
        switch (ee->algId)
        {
        case OID_DES_EDE3_CBC:
            outLen = DES3_KEYLEN;
            ivLen = DES3_IVLEN;
            break;
        case OID_AES_128_CBC:
            outLen = 16;
            ivLen = 16;
            break;
        default:
            psTraceCrypto("Unsupported encryption algorithm\n");
            return PS_UNSUPPORTED_FAIL;
        }

        if (ivLen)
        {
            psTraceCrypto("Only Key Agreement currently supported\n");
        }

        /* Find the key type and run the decryption */
        if (privKey->type == PS_RSA)
        {
# ifdef USE_RSA
            int32 rc;
            key = (psRsaKey_t *) &privKey->key.rsa;
            rc = psRsaDecryptPriv(pool, key, recipient->eKey,
                recipient->eKeyLen, out, outLen, NULL);
            if (rc < PS_SUCCESS)
            {
                return rc;
            }
# else
            return PS_UNSUPPORTED_FAIL;
# endif
        }
        else if (privKey->type == PS_ECC)
        {
            return PS_UNSUPPORTED_FAIL;
        }

    }
    else if (recipient->version == 3)
    {
        /* Key agreement */

        /* Where is the originator public key coming from? */
        if (recipient->originatorId == MCMS_ORIGIN_ID_RAWPUB)
        {
            /* That's nice of them to send it */
            eccKey = &recipient->originatorPubKey.key.ecc;
        }
        else if (recipient->originatorId == MCMS_ORIGIN_ID_ISSUERDN ||
                 recipient->originatorId == MCMS_ORIGIN_ID_KEYID)
        {
            eccKey = (psEccKey_t *) &cert->publicKey.key.ecc;
        }
        else
        {
            return PS_UNSUPPORTED_FAIL; /* can't hit */
        }

        /* Outlen must be set (also due to downcast!) */
        outLen = MCMS_MAX_ECKA;
        if (privKey->type == PS_ECC)
        {
            if (psEccGenSharedSecret(pool, &privKey->key.ecc, eccKey,
                    out, (uint16_t *) &outLen, NULL) < 0)
            {
                /* If establishing shared secret failed, try possible
                   other recipient infos. */
                if (recipient->next)
                {
                    recipient = recipient->next;
                    goto retryRecipient;
                }
                
                return MCMS_AED_FAIL_KEY_AGREE;
                
            }
        }
        else
        {
            psTraceCrypto("FAILURE: Expected private key type PS_ECC\n");
            return PS_UNSUPPORTED_FAIL;
        }
        if (recipient->keyWrapAlgId == OID_AES_256_WRAP)
        {
            unwrapKeyLen = 32;
        }
        else if (recipient->keyWrapAlgId == OID_AES_128_WRAP)
        {
            unwrapKeyLen = 16;
        }
        else if (recipient->keyWrapAlgId == OID_AES_192_WRAP)
        {
            unwrapKeyLen = 24;
        }
        else
        {
            return PS_UNSUPPORTED_FAIL;
        }
        Memset(unwrapKey, 0, 32);

        /* Not aware of any differences between these two scheme variations */
        if (recipient->keyEncryptAlgId ==
            OID_DHSINGLEPASS_STDDH_SHA1KDF_SCHEME)
        {
            tmpLen = SHA1_HASH_SIZE;
        }
        else if (recipient->keyEncryptAlgId == OID_ECKA_EG_X963KDF_SHA256 ||
                 recipient->keyEncryptAlgId ==
                 OID_DHSINGLEPASS_STDDH_SHA256KDF_SCHEME)
        {
            tmpLen = SHA256_HASH_SIZE;
        }
        else if (recipient->keyEncryptAlgId == OID_ECKA_EG_X963KDF_SHA384 ||
                 recipient->keyEncryptAlgId ==
                 OID_DHSINGLEPASS_STDDH_SHA384KDF_SCHEME)
        {
            tmpLen = SHA384_HASH_SIZE;
        }
        else if (recipient->keyEncryptAlgId == OID_ECKA_EG_X963KDF_SHA512 ||
                 recipient->keyEncryptAlgId ==
                 OID_DHSINGLEPASS_STDDH_SHA512KDF_SCHEME)
        {
            tmpLen = SHA512_HASH_SIZE;
        }
        else
        {
            return PS_UNSUPPORTED_FAIL;
        }

        psX963KeyDerivation(tmpLen, out, outLen, unwrapKey, unwrapKeyLen);

        /* writing back out over top */
        if (psAesUnwrap(unwrapKey, unwrapKeyLen, recipient->eKey,
                recipient->eKeyLen, ee->unwrappedKey,
                &unwrapKeyLen) < 0 || unwrapKeyLen > 0xFFFF)
        {
            /* most likely the wrong private key */
            return MCMS_AED_FAIL_KEY_UNWRAP;
        }
        ee->unwrappedKeyLen = (uint16_t) unwrapKeyLen;
    }

    return PS_SUCCESS;
}

# ifdef USE_MCMS_ATOMIC_AED_PARSE
int32 matrixCmsDecryptAED(psPool_t *pool, cmsEncryptedEnvelope_t *ee,
    unsigned char **content, int32 *contentLen, int32 flags)
{
    unsigned char tag[16];

    /* The parameter of the AlgorithimIdentifer should hold this */
    if (ee->encKeyIvLen == 0)
    {
        psTraceCrypto("No IV supplied in encrypted envelope\n");
        return PS_UNSUPPORTED_FAIL;
    }

    /* Writing to dedicated buffer or overwriting (insitu) given buffer? */
    if (!(flags & MCMS_FLAGS_EE_OVERWRITE_CT))
    {
        if ((*content = psMalloc(pool, ee->encryptedContentLen)) == NULL)
        {
            return PS_MEM_FAIL;
        }
    }
    else
    {
        *content = ee->encryptedContent;
    }

    /* Derive encryption and authentication keys now */
    if (ee->algId == OID_AES_128_CBC || ee->algId == OID_AES_192_CBC ||
        ee->algId == OID_AES_256_CBC)
    {
        psPkcs5Pbkdf2(ee->unwrappedKey, ee->unwrappedKeyLen,
            (unsigned char *) "encryption", 10, 1, ee->encKey, ee->encKeyLen);
        /* psTraceBytes("parse derived key", ee->encKey, ee->encKeyLen); */
        psPkcs5Pbkdf2(ee->unwrappedKey, ee->unwrappedKeyLen,
            (unsigned char *) "authentication", 14, 1, ee->authKey,
            ee->authKeyLen);
        /* psTraceBytes("parse derived auth", ee->authKey, ee->authKeyLen); */
    }
    else if (ee->algId == OID_AES_CBC_CMAC_128 ||
             ee->algId == OID_AES_CBC_CMAC_192 ||
             ee->algId == OID_AES_CBC_CMAC_256)
    {
        /* By definition CMAC key length is same length as encryption key
            which we already have handy */
        psAssert(ee->unwrappedKeyLen == (ee->encKeyLen * 2));
        ee->authKeyLen = ee->encKeyLen;
        /* Wrapped key material is encryption || mac */
        Memcpy(ee->encKey, ee->unwrappedKey, ee->encKeyLen);
        Memcpy(ee->authKey, ee->unwrappedKey + ee->encKeyLen, ee->authKeyLen);


        psCmacInit(ee->authKey, ee->authKeyLen, &ee->cmacCtx);
        psCmacUpdate(&ee->cmacCtx, ee->encryptedContent,
            ee->encryptedContentLen);
        psCmacUpdate(&ee->cmacCtx, ee->authAttribs, ee->authAttribsLen);
        psCmacFinal(&ee->cmacCtx, tag);

        psAesInitCBC(&ee->ctx.aes, ee->encKeyIv, ee->encKey, ee->encKeyLen,
            PS_AES_DECRYPT);

        psAesDecryptCBC(&ee->ctx.aes, ee->encryptedContent, *content,
            ee->encryptedContentLen);

        if (Memcmp(tag, ee->mac, ee->macLen) != 0)
        {
            psTraceCrypto("AES_CMAC mismatch!!\n");
            if (!(flags & MCMS_FLAGS_EE_OVERWRITE_CT))
            {
                psFree(*content, pool);
            }
            return MCMS_AED_KEY_AGREED_BUT_AUTH_FAILED;
        }

        /* Unpad */
        ee->encryptedContentLen -=
            (int32) (*content)[ee->encryptedContentLen - 1];


    }
    else if (ee->algId == OID_AES_128_GCM ||
             ee->algId == OID_AES_192_GCM ||
             ee->algId == OID_AES_256_GCM)
    {
        /* The key is just the unwrapped key directly */
        psAssert(ee->unwrappedKeyLen == ee->encKeyLen);
        Memcpy(ee->encKey, ee->unwrappedKey, ee->encKeyLen);

        psAesInitGCM(&ee->ctx.aesgcm, ee->encKey, ee->encKeyLen);
        psAesReadyGCM(&ee->ctx.aesgcm, ee->encKeyIv, ee->authAttribs,
            ee->authAttribsLen);
#  ifdef USE_CMS_GCM_DECRYPT_TAGLESS
        psAesDecryptGCMtagless(&ee->ctx.aesgcm, ee->encryptedContent,
            *content, ee->encryptedContentLen);
        psAesGetGCMTag(&ee->ctx.aesgcm, ee->macLen, tag);
        if (Memcmp(tag, ee->mac, ee->macLen) != 0)
        {
            psTraceCrypto("AES_GCM mismatch!!\n");
            if (!(flags & MCMS_FLAGS_EE_OVERWRITE_CT))
            {
                psFree(*content, pool);
            }
            return MCMS_AED_KEY_AGREED_BUT_AUTH_FAILED;
        }
#  else
        if (psAesDecryptGCM2(&ee->ctx.aesgcm, ee->encryptedContent,
                *content, ee->encryptedContentLen,
                ee->mac, ee->macLen) != PS_SUCCESS)
        {
            psTraceCrypto("AES_GCM mismatch!!\n");
            if (!(flags & MCMS_FLAGS_EE_OVERWRITE_CT))
            {
                psFree(*content, pool);
            }
            return MCMS_AED_KEY_AGREED_BUT_AUTH_FAILED;
        }
#  endif

    }
    else
    {
        if (!(flags & MCMS_FLAGS_EE_OVERWRITE_CT))
        {
            psFree(*content, pool);
        }
        return PS_UNSUPPORTED_FAIL;
    }

    *contentLen = ee->encryptedContentLen;

    return PS_SUCCESS;
}
# endif

#endif /* USE_CMS*/
