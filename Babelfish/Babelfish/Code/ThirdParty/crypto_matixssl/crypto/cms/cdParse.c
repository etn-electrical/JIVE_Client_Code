/**
 *      @file    cdParse.c
 *
 *
 *      Compressed-Data parse.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/
#include "matrixCmsApi.h"
#include "cryptoImpl.h"

#ifdef USE_CMS

# if defined(USE_MCMS_ATOMIC_CD_PARSE) || defined(USE_MCMS_STREAMING_CD_PARSE)

/* Compressed Data parse */
#  ifdef USE_MCMS_ATOMIC_CD_PARSE
#   ifdef MATRIX_USE_FILE_SYSTEM
int32 matrixCmsParseCompressedDataFile(psPool_t *pool, char *file,
    cmsCompressedData_t **compressedData)
{
    unsigned char *sdBuf, *DERout;
    unsigned char *start;
    psSizeL_t sdBufLen;
    psRes_t rc;
    psSize_t BASElen, DERlen;

    if (file == NULL)
    {
        psTraceCrypto("No file passed to matrixCmsParseCompressedDataFile\n");
        return PS_ARG_FAIL;
    }
    if ((rc = psGetFileBuf(pool, file, &sdBuf, &sdBufLen)) < PS_SUCCESS)
    {
        return rc;
    }
    start = NULL;

    BASElen = sdBufLen;
    start = sdBuf;

    /* Base64 decode */
    DERout = psMalloc(pool, BASElen);
    if (DERout == NULL)
    {
        psFree(sdBuf, pool);
        psError("Memory allocation error in matrixParseSignedDataFile\n");
        return PS_MEM_FAIL;
    }
    DERlen = BASElen;
    if ((rc = psBase64decode((unsigned char *) start, BASElen, DERout,
             &DERlen)) != 0)
    {
        psTraceCrypto("Error base64 decode of signed data file\n");
        psFree(DERout, pool);
        psFree(sdBuf, pool);
        return rc;
    }
    psFree(sdBuf, pool);

    if ((rc = matrixCmsParseCompressedData(pool, DERout, DERlen,
             compressedData, 0)) < 0)
    {
        psFree(DERout, pool);
        return rc;
    }

    psFree(DERout, pool);

    return 0;
}
#   endif /* USE_MCMS_ATOMIC_CD_PARSE */
#  endif  /* MATRIX_USE_FILE_SYSTEM */


static int32 commonCompressedHeaderParse(psPool_t *pool, const unsigned char **c,
    const unsigned char *end, int32 stream, uint32_t *contentLen,
    cmsCompressedData_t **cd, int32 *encapIndef, int32 *cdIndef,
    int32 *contentIndef, int32 flags)
{
    cmsCompressedData_t *compressedData;
    const unsigned char *p, *tmpLenPtr;
    int32 prc, rc, intOut;
    psSize_t paramLen;
    uint32_t len, l32;

    *encapIndef = *cdIndef = *contentIndef = 0;
    prc = PS_PARSE_FAIL;
    p = *c;

    if (!(flags & MCMS_FLAGS_NO_CONTENT_INFO))
    {
        if ((rc = mcmsParsePkcsOid(&p, (uint32) (end - p), &paramLen)) < 0)
        {
            psTraceCrypto("Error parsing OID for compressed data type\n");
            return rc;
        }
        /* len is OID id */
        if (paramLen != CMS_PKCS9_COMPRESSED_DATA)
        {
            psTraceIntCrypto("Expected compressedData type but got %d", paramLen);
            return PS_PARSE_FAIL;
        }

        if (end - p < 1)
        {
            return PS_LIMIT_FAIL;
        }
        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Expected EXPLICIT content for contentInfo");
            return PS_PARSE_FAIL;
        }
        p++;
        if (end - p < 1)
        {
            return PS_LIMIT_FAIL;
        }
        if ((*contentIndef = getAsnLength32(&p, (uint32_t) (end - p), &len,
                 stream ? 1 : 0)) < 0)
        {
            psTraceCrypto("getAsnLength failure in ContentType parse\n");
            return *contentIndef;
        }
    }
    else
    {
        *contentIndef = 0;
    }

    /* OK, we've passed the General Syntax

        CompressedData ::= SEQUENCE {
            version CMSVersion,
            compressionAlgorithm CompressionAlgorithmIdentifier,
            encapContentInfo EncapsulatedContentInfo
        }
     */
    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }
    if (stream == 0)
    {
        if ((*cdIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, stream)) < 0)
        {
            psTraceCrypto("Initial parse error CompressedData\n");
            return *cdIndef;
        }
    }
    else
    {
        if ((*cdIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, stream))
            < 0)
        {
            psTraceCrypto("Initial parse error CompressedData\n");
            return *cdIndef;
        }
    }
    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }
    /*  CMSVersion */
    if ((rc = getAsnInteger(&p, (uint32) (end - p), &intOut)) < 0)
    {
        psTraceCrypto("Error getting version for compressed data\n");
        return rc;
    }
    /* This is for the getAsnAlgorithmIdentifier call but do it before the
        allocation to save us the bother */
    if (end - p < 1)
    {
        return PS_LIMIT_FAIL;
    }

    /* Set up the structure to hold the info we want to persist */
    if ((compressedData = psMalloc(pool, sizeof(cmsCompressedData_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(compressedData, 0, sizeof(cmsCompressedData_t));
    compressedData->pool = pool;

    if ((rc = getAsnAlgorithmIdentifier(&p, (int32) (end - p),
             &compressedData->compressAlg, &paramLen)) < 0)
    {
        psTraceCrypto("OID err for compression algorithm\n");
        prc = rc;
        goto LBL_ERR;
    }
    if (paramLen > 0)
    {
        if (end - p < paramLen)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        p += paramLen;
    }
    /* Do we support this algorithm?  Do we care if given to user anyway? */
    if (compressedData->compressAlg != OID_COMPRESSION_ZLIB)
    {
        psTraceCrypto("Warning:  Internally unsupported compression alg\n");
    }

    /*  EncapsulatedContentInfo ::= SEQUENCE {
            eContentType ContentType,
            eContent [0] EXPLICIT OCTET STRING OPTIONAL }

        ContentType ::= OBJECT IDENTIFIER */
    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }

    if ((*encapIndef = getAsnSequence32(&p, (uint32_t) (end - p),
             &l32, stream ? 1 : 0)) < 0)
    {
        psTraceCrypto("Initial parse error EncapsulatedContentInfo\n");
        prc = *encapIndef;
        goto LBL_ERR;
    }

    tmpLenPtr = p;
    if ((rc = mcmsParsePkcsOid(&p, (uint32) (end - p),
             &compressedData->cContentType)) < 0)
    {
        psTraceCrypto("Error parsing OID for cContentType\n");
        prc = rc;
        goto LBL_ERR;
    }
    l32 -= (uint32_t) (p - tmpLenPtr);
    *c = (unsigned char *) p;
    *contentLen = l32;
    *cd = compressedData;
    return rc;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        matrixCmsFreeCompressedData(compressedData);
    }
    return prc;

}

#  ifdef USE_MCMS_STREAMING_CD_PARSE
/*  Return PS_LIMIT_FAIL is indication that not enough ASN.1 has been provided
    to Init (however, also could be a real ASN.1 encoding problem so caller
    needs to give some sanity to calling this with ever growing data lengths
    that continue to return LIMIT_FAIL).

    The requirement is that we need enough data to get all the way to
    the compressed data itself.  This will be known based on the SUCCESS
    return code.

    If we hit compressed data during this call it will be returned in the
    final output parameters as well and that data must be passed on to the
    next Update call.
 */
int32 matrixCmsInitParseCompressedData(psPool_t *pool, unsigned char *cdBuf,
    uint32 cdBufLen, cmsCompressedData_t **retCompressedData,
    unsigned char **compressedOut, int32 *compressedOutLen, int32 flags)
{

    cmsCompressedData_t *compressedData;
    const unsigned char *p, *end;
    uint32_t len, tmpLen;
    int32 prc, fullIndef, contentIndef;
    int32 cdIndef, encapIndef, econIndef, rc;

    p = cdBuf;
    end = p + cdBufLen;

    *compressedOut = NULL;
    *compressedOutLen = 0;

    if (cdBufLen == 0)
    {
        return PS_LIMIT_FAIL;
    }
    prc = PS_PARSE_FAIL;
    *retCompressedData = NULL;

    if (!(flags & MCMS_FLAGS_NO_CONTENT_INFO))
    {
        /* General Syntax content is going to tell us what it is
            ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */

        if ((fullIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1))
            < 0)
        {
            if (fullIndef == PS_LIMIT_FAIL)
            {
                return fullIndef;
            }
            psTraceCrypto("Initial parse error for compressed data type\n");
            return PS_PARSE_FAIL;
        }
        if (end - p < 1)
        {
            return PS_LIMIT_FAIL;
        }
    }
    else
    {
        fullIndef = 0;
    }

    if ((rc = commonCompressedHeaderParse(pool, &p, end, 1, &tmpLen,
             &compressedData, &encapIndef, &cdIndef, &contentIndef, flags)) < 0)
    {
        return rc;
    }
    if (end - p < 1)
    {
        prc = PS_LIMIT_FAIL;
        goto LBL_ERR;
    }

    if (tmpLen)
    {
        /* eContent exists */
        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Initial parse error for cContent\n");
            goto LBL_ERR;
        }
        p++;
        if ((econIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
        {
            psTraceCrypto("Couldn't parse encapsulated content info\n");
            prc = econIndef;
            goto LBL_ERR;
        }
        if (end - p < 1)
        {
            prc = PS_LIMIT_FAIL;
            goto LBL_ERR;
        }
        if (*p == ASN_OCTET_STRING)
        {
            p++;
            if ((rc = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
            {
                prc = rc;
                goto LBL_ERR;
            }
            /* Got what we wanted from init.  Mark how big the compressed data
                is, send back whatever is left here and return success */
            compressedData->compressedDataLen = len; /* Length need to read */
            compressedData->currentLen = 0;          /* How much we've read */
            *compressedOut = (unsigned char *) p;
            *compressedOutLen = (uint32) (end - p);
        }
        else if (*p == (ASN_OCTET_STRING | ASN_CONSTRUCTED))
        {
            p++;
            /* Want to get to the first known length of a component
                OCTET STRING */
            if ((prc = getAsnLength32(&p, (uint32_t) (end - p), &len, 1)) < 0)
            {
                goto LBL_ERR;
            }
            if (prc == ASN_UNKNOWN_LEN)
            {
                compressedData->indefLen += 2;
            }
            if (end - p < 1)
            {
                prc = PS_LIMIT_FAIL;
                goto LBL_ERR;
            }
            /* First pass is to get the length and test integrity */
            if (*p != ASN_OCTET_STRING)
            {
                prc = PS_PARSE_FAIL;
                goto LBL_ERR;
            }
            p++;
            if ((prc = getAsnLength32(&p, (uint32_t) (end - p),
                     &compressedData->compressedDataLen, 1)) < 0)
            {
                goto LBL_ERR;
            }
            compressedData->currentLen = 0; /* How much we've read */
            *compressedOut = (unsigned char *) p;
            *compressedOutLen = (uint32_t) (end - p);

        }
        else
        {
            prc = PS_PARSE_FAIL;
            goto LBL_ERR;
        }
        if (econIndef == ASN_UNKNOWN_LEN)
        {
            compressedData->indefLen += 2;
        }
    }

    /* These were incrementing p by 2 for each that were set to find the end */
    if (encapIndef == ASN_UNKNOWN_LEN)
    {
        compressedData->indefLen += 2;
    }
    if (cdIndef == ASN_UNKNOWN_LEN)
    {
        compressedData->indefLen += 2;
    }
    if (contentIndef == ASN_UNKNOWN_LEN)
    {
        compressedData->indefLen += 2;
    }
    if (fullIndef == ASN_UNKNOWN_LEN)
    {
        compressedData->indefLen += 2;
    }
    *retCompressedData = compressedData;
    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        matrixCmsFreeCompressedData(compressedData);
    }
    return prc;

}

/* Return MCMS_PARTIAL if still more data to read.  Return PS_SUCCESS if got
    it all */
int32 matrixCmsUpdateParseCompressedData(cmsCompressedData_t *ctx,
    unsigned char *cdBuf, uint32 cdBufLen, unsigned char **compressedBuf,
    int32 *compressedBufLen, unsigned char **remainder, int32 *remainderLen)
{
    int32 rc;
    uint32 diff;
    const unsigned char *p, *end;

    *compressedBufLen = *remainderLen = 0;
    if (cdBufLen == 0)
    {
        return MCMS_PARTIAL;
    }

    if (ctx->compressedDataLen > 0)
    {
        /* We aren't decompressing anything so just return what they gave us */
        *compressedBuf = cdBuf;
        *compressedBufLen = cdBufLen;
    }
    else
    {
        /* Indefinate length ending (0x0) or component boundary (OCTET) */
        if (*cdBuf == 0x0)
        {
            if (ctx->indefLen > 0)
            {
                if (ctx->indefLen < cdBufLen)
                {
                    return PS_PARSE_FAIL; /* Too much data to end it */
                }
                /* already read first one */
                cdBuf++; ctx->indefLen--;
                while (--cdBufLen > 0)
                {
                    if (*cdBuf == 0x0)
                    {
                        cdBuf++;
                        ctx->indefLen--;
                    }
                    else
                    {
                        break;
                    }
                }
                /* Get them all? */
                if (ctx->indefLen == 0)
                {
                    return PS_SUCCESS;
                }
                else
                {
                    return MCMS_PARTIAL; /* a few more 0x0 left */
                }
            }
            else
            {
                return PS_SUCCESS; /* Called too many times? */
            }

        }
        else if (*cdBuf == ASN_OCTET_STRING)
        {
            psAssert(ctx->compressedDataLen == 0);
            p = cdBuf + 1; /* just looked at OCTET_STRING byte */
            end = cdBuf + cdBufLen;
            if ((rc = getAsnLength32(&p, (uint32_t) (end - p),
                     &ctx->compressedDataLen, 1)) < 0)
            {
                if (rc == PS_LIMIT_FAIL)
                {
                    /* Couldn't get through the few bytes of len.  Give it
                        all back as remainder with PARTIAL return */
                    *remainder = cdBuf;
                    *remainderLen = cdBufLen;
                    return MCMS_PARTIAL;
                }
                return rc;
            }

            /* Now just carry on at the data boundary */
            cdBufLen -= (p - cdBuf);
            cdBuf = (unsigned char *) p;

            *compressedBuf = cdBuf;
            *compressedBufLen = cdBufLen;
            psAssert(*compressedBufLen >= 0);
        }
        else
        {
            return PS_PARSE_FAIL;
        }
    }

    ctx->currentLen += cdBufLen;

    if (ctx->currentLen >= ctx->compressedDataLen)
    {
        /* If we've exceeded the compressed data length we double check
            the indefinite length to see if that is what we are
            dealing with */
        if (ctx->indefLen == 0)
        {
            psAssert(ctx->currentLen == ctx->compressedDataLen);
            /* Got everything exactly */
            return PS_SUCCESS;
        }
        else
        {
            /* indefinate length stuff */
            /* psTraceBytes("buf", cdBuf, cdBufLen); */
            diff = ctx->currentLen - ctx->compressedDataLen;
            if (diff == 0)
            {
                ctx->currentLen = ctx->compressedDataLen = 0;
                return MCMS_PARTIAL; /* right on end of component */
            }
            /* Move compressedBufLen back to account for "overflow" */
            psAssert(diff <= (uint32) * compressedBufLen);
            *compressedBufLen -= diff;
            if (cdBuf[*compressedBufLen] == 0x0)
            {
                /* Looking at final component */
                psAssert(ctx->indefLen >= diff);
                ctx->indefLen -= diff;
                if (ctx->indefLen > 0)
                {
                    ctx->currentLen = ctx->compressedDataLen = 0;
                    return MCMS_PARTIAL;
                }
                else
                {
                    return PS_SUCCESS;
                }
            }
            else if (cdBuf[*compressedBufLen] == ASN_OCTET_STRING)
            {
                /* Always stopping at componenet boundary rather than
                    continuing to return data because we aren't converting
                    anything so don't want to memmove all the data forward
                    past these little OCTET_STRING bumps */
                *remainder = cdBuf + *compressedBufLen;
                *remainderLen = cdBufLen - *compressedBufLen;
                ctx->currentLen = ctx->compressedDataLen = 0;
                return MCMS_PARTIAL;
            }
            else
            {
                return PS_PARSE_FAIL;
            }

        }
    }
    else
    {
        return MCMS_PARTIAL;
    }
    return PS_LIMIT_FAIL; /* will never reach */
}
#  endif



#  ifdef USE_MCMS_ATOMIC_CD_PARSE
/******************************************************************************/
/*
    Primary Signed-Data Content Type parser.  Starts parsing from the
    General Syntax
 */
int32 matrixCmsParseCompressedData(psPool_t *pool, unsigned char *cdBuf,
    uint32 cdBufLen, cmsCompressedData_t **retCompressedData, int32 flags)
{

    cmsCompressedData_t *compressedData = NULL;
    const unsigned char *p, *end;
    uint32_t len, tmpLen = 0;
    int32 prc, fullIndef, contentIndef;
    int32 cdIndef, encapIndef, econIndef;

    p = cdBuf;
    end = p + cdBufLen;

    prc = PS_PARSE_FAIL;
    *retCompressedData = NULL;

    if (!(flags & MCMS_FLAGS_NO_CONTENT_INFO))
    {
        /* General Syntax content is going to tell us what it is
            ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */

        if ((fullIndef = getAsnSequence32(&p, (uint32_t) (end - p), &len, 1)) < 0)
        {
            /* The very first length is given special return code if length
                provided is too short */
            if (fullIndef == PS_LIMIT_FAIL)
            {
                return MCMS_PARTIAL;
            }
            psTraceCrypto("Initial parse error for compressed data type\n");
            return PS_PARSE_FAIL;
        }
    }
    else
    {
        fullIndef = 0;
    }

    if ((prc = commonCompressedHeaderParse(pool, &p, end, 0, &tmpLen,
             &compressedData, &encapIndef, &cdIndef, &contentIndef, flags)) < 0)
    {
        return prc;
    }

    if (tmpLen)
    {
        /* eContent exists */
        if (*p != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
        {
            psTraceCrypto("Initial parse error for cContent\n");
            goto LBL_ERR;
        }
        p++;
        if ((econIndef = getAsnLength32(&p, (uint32_t) (end - p), &len, 0)) < 0 ||
            (uint32_t) (end - p) < len)
        {
            psTraceCrypto("Couldn't parse encapsulated content info\n");
            goto LBL_ERR;
        }
        if (*p == ASN_OCTET_STRING)
        {
            p++;
            if (getAsnLength32(&p, (uint32_t) (end - p), &len, 0) < 0 ||
                (uint32_t) (end - p) < len)
            {
                goto LBL_ERR;
            }
            if ((compressedData->compressedData = psMalloc(pool, len)) == NULL)
            {
                prc = PS_MEM_FAIL;
                goto LBL_ERR;
            }
            Memcpy(compressedData->compressedData, p, len);
            compressedData->compressedDataLen = len;
            p += len;
        }
        else if (*p == (ASN_OCTET_STRING | ASN_CONSTRUCTED))
        {
            p++;
            if (getAsnConstructedOctetString32(pool, &p, (uint32_t) (end - p),
                    &compressedData->compressedData,
                    &compressedData->compressedDataLen) < 0)
            {
                goto LBL_ERR;
            }
        }
        else
        {
            prc = PS_PARSE_FAIL;
            goto LBL_ERR;
        }
        if (econIndef == ASN_UNKNOWN_LEN)
        {
            p += 2;
        }
    }

    if (encapIndef == ASN_UNKNOWN_LEN)
    {
        p += 2;
    }
    if (cdIndef == ASN_UNKNOWN_LEN)
    {
        p += 2;
    }
    if (contentIndef == ASN_UNKNOWN_LEN)
    {
        p += 2;
    }
    if (fullIndef == ASN_UNKNOWN_LEN)
    {
        p += 2;
    }
    /* should be the end */
    if (p != end)
    {
        psTraceCrypto("Final parse issue for atomic CD parse\n");
        prc = PS_PARSE_FAIL;
        goto LBL_ERR;
    }
    *retCompressedData = compressedData;
    prc = PS_SUCCESS;

LBL_ERR:
    if (prc != PS_SUCCESS)
    {
        matrixCmsFreeCompressedData(compressedData);
    }
    return prc;

}
#  endif /* USE_MCMS_ATOMIC_CD_PARSE */

void matrixCmsFreeCompressedData(cmsCompressedData_t *compressedData)
{
    if (compressedData)
    {
        if (compressedData->compressedData)
        {
            psFree(compressedData->compressedData, compressedData->pool);
        }
        psFree(compressedData, compressedData->pool);
    }
}

# endif /* USE_MCMS_COMPRESSED_DATA_PARSE */
#endif  /* USE_CMS */
