/**
 *      @file    matrixCms.h
 *
 *
 *      Internal header for MatrixCMS.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#ifndef _h_PS_MCMS
# define _h_PS_MCMS

# include "./crypto/cryptoApi.h"

# ifdef USE_CMS

#  include "matrixCmsConfig.h"
#  if defined(USE_MCMS_ATOMIC_CD_CREATE) || \
    defined(USE_MCMS_STREAMING_CD_CREATE) || \
    defined(USE_MCMS_ATOMIC_CD_PARSE) || \
    defined(USE_MCMS_STREAMING_CD_PARSE)
#   include "zlib.h"
#  endif

#  ifndef USE_ECC
#   error "Enable USE_ECC in cryptoConfig.h for MatrixCMS support"
#  endif
#  ifndef USE_AES_CMAC
#   error "Enable USE_AES_CMAC in cryptoConfig.h for MatrixCMS support"
#  endif
#  ifndef USE_AES_GCM
#   error "Enable USE_AES_GCM in cryptoConfig.h for MatrixCMS support"
#  endif
#  ifndef USE_AES_WRAP
#   error "Enable USE_AES_WRAP in cryptoConfig.h for MatrixCMS support"
#  endif
#  ifndef USE_SHA256
#   error "Enable USE_SHA256 in cryptoConfig.h for MatrixCMS support"
#  endif
#  ifndef USE_SHA384
#   error "Enable USE_SHA384 in cryptoConfig.h for MatrixCMS support"
#  endif
#  ifndef USE_SHA512
#   error "Enable USE_SHA512 in cryptoConfig.h for MatrixCMS support"
#  endif
#  ifndef USE_3DES
#   error "Enable USE_3DES in cryptoConfig.h for MatrixCMS support"
#  endif
#  ifndef USE_PKCS5
#   error "Enable USE_PKCS5 in cryptoConfig.h for MatrixCMS support"
#  endif



#  if defined(USE_MCMS_ATOMIC_AED_PARSE) || defined(USE_MCMS_STREAMING_AED_PARSE)
#   define NEED_MCMS_ENCRYPTED_ENVELOPE_PARSE
#  endif

/* MAX */
#  define MCMS_MAX_ECKA           128 /* bytes */
#  define MCMS_MAX_KEY_MAT_GEN    80  /* max bytes for random key material & iv
                                         is 32 byte enc key + 32 byte mac key +
                                         16 byte enc IV */
#  define MCMS_MAX_SIGNERS        3   /* Maximum # of signers of Signed Data. */
#  define MCMS_MAX_RECIPIENTS     3   /* Maximum # of recipients for AED. */


/* Config */
#  define MCMS_GCM_TAG_LEN    12     /* RECOMMENDED in the spec */
#  define MCMS_MASTER_SECRET_LEN  32 /* Could optionally be 16 per RFC 6476 */


/* Universal public flags */
#  define MCMS_FLAGS_NO_CONTENT_INFO  0x80

/* SD Public API flags */
#  define MCMS_FLAGS_SD_NODETACH      0x1/* Include EncapsulatedContentInfo */
/* If this is an "external signature" mode, it is only necessary that the
    caller have the hash of the data.  If this is the case, this flag is used
    to indicate that.  This flag CAN NOT be used with the NODETACH flag */
#  define MCMS_FLAGS_SD_CONTENT_PREHASHED 0x2
/* Attempt to use subjectKeyId extension if it exists.  Fall back to
    IssuerAndSerialNumber (default) if it doesn't */
#  define MCMS_FLAGS_SD_SUBJECT_KEY_ID    0x4
/* Interpret certificate argument as a certificate chain. */
#  define MCMS_FLAGS_SD_CERT_CHAIN        0x100
/* Add CRL to Signed Data. */
#  define MCMS_FLAGS_SD_HAS_CRL           0x200

/* Import certs even with unsupported signature algorithms */
#  define MCMS_FLAGS_PD_CERT_STORE_ONLY   0x2000

/* AED Public API flags */
/* The default key id method is a static DH using IssuerAndSerialNumber
    Otherwise, use ONE of the following two flags to specific the desired
    alternative method */
#  define MCMS_FLAGS_AED_ORIG_DHE_PUBLIC_KEY  0x1 /* Generate DHE key and send */
#  define MCMS_FLAGS_AED_ORIG_SUBJECT_KEY_ID  0x2 /* Use cert ext to id the key */
/* Again, default is IssuerAndSerialNumber so use this to change if needed */
#  define MCMS_FLAGS_AED_RECIP_SUBJECT_KEY_ID 0x4

#  define MCMS_FLAGS_AED_INCLUDE_CERT 0x8 /* Add originatorCert to AED */

#  define MCMS_FLAGS_AED_PROVIDE_KEYMAT 0x100 /* Provide keymat via
                                                 DataExtInfo_t. */

/*      Overwrite ciphertext*/
#  define MCMS_FLAGS_EE_OVERWRITE_CT  0x1
#  define MCMS_FLAGS_EE_STREAM_INIT   0x2

/* matrixCmsCreateAuthEnvDataBuf function paramters */
/*      keyMethod parameter options */
#  define MCMS_AED_KEY_AGREE_METHOD   1
/* encryptMethod parameter options */
#  define MCMS_AES128_GCM         1
#  define MCMS_AES192_GCM         2
#  define MCMS_AES256_GCM         3
#  define MCMS_AES128_CBC_CMAC    4
#  define MCMS_AES192_CBC_CMAC    5
#  define MCMS_AES256_CBC_CMAC    6
/* wrapMethod parameter options */
#  define MCMS_AES128_WRAP    1
#  define MCMS_AES192_WRAP    2
#  define MCMS_AES256_WRAP    3
/* keyAgreeScheme paramter options (if KEY_AGREE_METHOD) */
#  define MCMS_DH_X963KDF_SHA256      1/* dhSinglePass-stdDH-shaXkdf-schemes */
#  define MCMS_DH_X963KDF_SHA384      2
#  define MCMS_DH_X963KDF_SHA512      3
#  define MCMS_ECKA_X963KDF_SHA256    4/* ecka-eg-X963KDF-SHAX schemes */
#  define MCMS_ECKA_X963KDF_SHA384    5
#  define MCMS_ECKA_X963KDF_SHA512    6

/* AuthEncrypt algorithm */
#  define MCMS_AES_GCM_TYPE       1
#  define MCMS_AES_CBC_CMAC_TYPE  2

/* Matrix CMS */
#  define MCMS_SHA1_ALG           OID_SHA1_ALG
#  define MCMS_SHA256_ALG         OID_SHA256_ALG
#  define MCMS_SHA384_ALG         OID_SHA384_ALG
#  define MCMS_SHA512_ALG         OID_SHA512_ALG

#  define MCMS_DER                1
#  define MCMS_PEM                2


#  define MCMS_ORIGIN_ID_ISSUERDN 1
#  define MCMS_ORIGIN_ID_KEYID    2
#  define MCMS_ORIGIN_ID_RAWPUB   3

/* Internal */
#  define MCMS_MAX_ATTRIBS    8


/* OIDs */
#  define CM_MAX_OID_LEN  16

typedef struct
{
    unsigned char oid[CM_MAX_OID_LEN];
    uint32 oidLen;
    int32 cmsId;
} cmsOidTable_t;


#  define CMS_PKCS7_DATA              71
#  define CMS_PKCS7_SIGNED_DATA       72
#  define CMS_PKCS7_ENVELOPED_DATA    73

#  define CMS_PKCS9_CONTENT_TYPE              93
#  define CMS_PKCS9_MESSAGE_DIGEST            94
#  define CMS_PKCS9_SIGNING_TIME              95
#  define CMS_PKCS9_SMIME_CAPABILITIES        96
#  define CMS_PKCS9_AUTH_ENVELOPED_DATA       692
#  define CMS_PKCS9_COMPRESSED_DATA           678
#  define CMS_RFC6211_ALGORITHM_PROTECTION    704

/* AuthEnc OIDs for AES_CMAC mode */
#  define OID_AUTH_ENC_256_LEN    11


#  define OID_PBKDF2_LEN  9



#  define OID_COMPRESSION_ZLIB                679


#  define OID_ECKA_EG_X963KDF_SHA256                  150
#  define OID_ECKA_EG_X963KDF_SHA384                  151
#  define OID_ECKA_EG_X963KDF_SHA512                  152
#  define OID_DHSINGLEPASS_STDDH_SHA1KDF_SCHEME       464
#  define OID_DHSINGLEPASS_COFACTORDH_SHA1KDF_SCHEME  465
#  define OID_MQVSINGLEPASS_SHA1KDF_SCHEME            478
#  define OID_DHSINGLEPASS_STDDH_SHA256KDF_SCHEME     189
#  define OID_DHSINGLEPASS_STDDH_SHA384KDF_SCHEME     190
#  define OID_DHSINGLEPASS_STDDH_SHA512KDF_SCHEME     191

/* Encrypted Envelope structures */
typedef struct cmRecipientEntry
{
    psPool_t *pool;
    int32 version;
    int32 keyEncryptAlgId;
    int32 keyWrapAlgId;
    int32 originatorPubKeyAlg;
    psSize_t eKeyLen;
    psSize_t userKeyingMaterialLen;
    psSize_t originatorSnLen;
    psSize_t recipientSnLen;
    int32 originatorId;                  /* MCMS_ORIGIN_ID_ */
    int32 recipientId;                   /* MCMS_ORIGIN_ID_ */
    x509DNattributes_t originatorDn;
    x509DNattributes_t recipientDn;
    unsigned char *originatorSn;            /* serial number OR subject key id */
    unsigned char *recipientSn;             /* serial number */
    unsigned char *eKey;
    unsigned char *userKeyingMaterial;
    psPubKey_t originatorPubKey;
    struct cmRecipientEntry *next;
} cmsRecipientInfos_t;

typedef struct
{
    psPool_t *pool;
    int32 version;
    uint16_t contentType;
    int32 algId;
    /* int32                                    algIdParamsLen; // GONE */
    psSize_t encKeyIvLen;              /* NEW */
    psSize_t encKeyLen;                /* NEW */
    psSize_t authKeyLen;               /* NEW */
    psSize_t macLen;
    psSize_t authAttribsLen;
    psSize_t unwrappedKeyLen;                /* NEW */
    int32 encryptedContentAllocated;         /* 1 if TRUE */
    uint32_t encryptedContentLen;
    unsigned char *encryptedContent;
    unsigned char *authAttribs;
    /* unsigned char                    *algIdParams; // GONE */
    unsigned char encKeyIv[16];                /* NEW */
    unsigned char encKey[32];                  /* NEW - AES_256 max */
    unsigned char authKey[32];                 /* NEW - CMAC max key size */
    unsigned char mac[32];                     /* AES CMAC or GCM */
    unsigned char unwrappedKey[MCMS_MAX_ECKA]; /* NEW */
    int32 macVerified;
    cmsRecipientInfos_t *recipients;
    psX509Cert_t *originator;
    psCipherContext_t ctx;
    psAesCmac_t cmacCtx;
#  ifdef USE_MCMS_STREAMING_AED_PARSE
    int32 encIndef, aedIndef, contentIndef, fullIndef, indef;
#  endif
} cmsEncryptedEnvelope_t;


/* SignedData strctures */
typedef struct
{
    int32 version;               /* 1 for dn and 3 for key id */
    psSize_t snLen;              /* len of sn */
    x509DNattributes_t dn;
    unsigned char *sn;           /* serial number OR subject key id */
} cmsSignerId_t;

typedef struct cmSignerEntry
{
    psPool_t *pool;
    int32 sigAlg;
    psSize_t sigLen;
    int32 digestId;
    psSize_t digestLen;
    psSize_t signedAttrsLen;
    unsigned char *digest;
    unsigned char *sig;
    cmsSignerId_t *signerId;
    unsigned char *signedAttrs;
    struct cmSignerEntry *next;
} cmsSignerInfos_t;

typedef struct
{
    psPool_t *pool;
    int32 version;
    int32 digestId;
    uint16_t eContentType;
    uint32_t eContentLen;
    unsigned char *eContent;
    psX509Cert_t *cert;
    cmsSignerInfos_t *signers;
#  ifdef USE_MCMS_STREAMING_SD_PARSE
    int32 eContentIndef, encapIndef, sdIndef;
    int32 contentIndef, initialIndef, constructedIndef;
#  endif
} cmsSignedData_t;


typedef struct cmsAttribEntry
{
    psPool_t *pool;
    unsigned char oid[CM_MAX_OID_LEN];
    unsigned char *data;
    psSize_t oidLen;
    psSize_t dataLen;
    struct cmsAttribEntry *next;
} cmsAttributeSet_t;

#  ifdef USE_MCMS_STREAMING_SD_CREATE
typedef struct
{
    psPool_t *pool;
    int32 flags;
    int32 version;
    uint16_t contentType;
    psSize_t hashLen;
    psDigestContext_t hashCtx;
    cmsSignerInfos_t *signers;
    psX509Cert_t *cert;
    psPubKey_t *key;
} cmsSdStream_t;
#  endif

/* Authenticated Enveloped Data structures */
typedef struct
{
    psPool_t *pool;
    int32 type;               /* encrypt method.  AES_CBC, AES_GCM */
    int32 wrapMethod;
    int32 keyAgreeScheme;
    int32 encryptMethod;
    int32 authMethod;
    psSize_t keyLen;
    psSize_t ivLen;
    psSize_t macLen;
    psSize_t asnLen;
    psSize_t authAttributesLen;
    unsigned char *authAttributes;
    psSize_t eKeyLen;            /* encrypted key */
    psCipherContext_t ctx;
    psAesCmac_t cmacCtx;
    psEccKey_t *eccKey;         /* If DHE key agreement */
    unsigned char key[32];      /* Max for 256 bit keys */
    unsigned char macKey[32];   /* Same max as encryption key */
    unsigned char iv[16];       /* AES_CBC max */
    unsigned char eKey[72];     /* Max CBC_CMAC 32 byte keys + 8 byte block */
#  ifdef USE_MCMS_STREAMING_AED_CREATE
    unsigned char leftover[16];
    int32 leftoverLen;
    int32 omitContentInfo;
#  endif
} cmsAuthEnvelopedData_t;

typedef struct
{
    psPool_t *pool;
    int32 compressAlg;
    uint16_t cContentType;
    uint32_t compressedDataLen;
    unsigned char *compressedData;
#  ifdef USE_MCMS_STREAMING_CD_PARSE
    int32 currentLen;
    uint32 indefLen;
    int32 leftoverLen;
    unsigned char leftover[16];   /* Just a few bytes of OCTET STRING */
#  endif
} cmsCompressedData_t;


#  define MCMS_PARTIAL                        -155
#  define MCMS_UNKNOWN                        -156

/* SignedData return codes */
#  define MCMS_SIG_FAIL_CONTENT_MISMATCH      -130
#  define MCMS_SIG_FAIL_NO_CONTENT            -132
#  define MCMS_SIG_FAIL_SIGNATURE_MISMATCH    -133
#  define MCMS_SIG_FAIL_CONTENT_HASH_MISMATCH -134
#  define MCMS_SIG_FAIL_BAD_USER_CERT         -135
#  define MCMS_SIG_FAIL_SIGNATURE_FAIL        -136
#  define MCMS_SIG_FAIL_NO_CERT               -137

/* AuthEnvData confirm return codes */
#  define MCMS_AED_KEY_AGREED_BUT_AUTH_FAILED -138
#  define MCMS_AED_FAIL_NO_CERT               -139
#  define MCMS_AED_FAIL_KEY_AGREE             -140
#  define MCMS_AED_FAIL_KEY_UNWRAP            -141

typedef struct matrixCmsCreateSignedDataExtInfo
{
    int32 flags;
    const unsigned char *tbsCertListBin;
    psSize32_t tbsCertListLen;
}
matrixCmsCreateSignedDataExtInfo_t;

typedef struct matrixCmsCreateAuthEnvDataExtInfo
{
    int32 flags;
    const unsigned char *authEncryptKeyMat;
    psSize_t authEncryptKeyMatLen;
}
matrixCmsCreateAuthEnvDataExtInfo_t;

/* Internals */
extern int32 mcmsParsePkcsOid(const unsigned char **pp, uint32 len, uint16_t *oi);
extern int32 cmsParsePkcs9ContentType(const unsigned char **pp, uint32_t len,
                                      uint16_t *oi);
extern int32 cmsParsePkcs9SignedTime(const unsigned char **pp, uint32 len);
extern int32 cmsParsePkcs9MessageDigest(psPool_t *pool,
                                        const unsigned char **pp, uint32 len, unsigned char **digest,
                                        psSize_t *digestLen);
extern int32_t cmsGetOctetString(psPool_t *pool, const unsigned char **pp,
                                 uint32 len, unsigned char **octetString, uint32_t *octetLen);

extern void mcmsFreeSignerInfos(cmsSignerInfos_t *signers);

extern int32 mcmsMoveAttribToDER(psPool_t *pool, cmsAttributeSet_t *attribSet,
                                 unsigned char **out, psSize_t *outLen);
extern void mcmsFreeAttributes(cmsAttributeSet_t *attribSet);


extern int32 mcmsGetAlgOidFromId(int32 id, unsigned char *oid, psSize_t *oidLen);
extern int32 mcmsGetPkcsOidFromId(int32 id, unsigned char *oid, psSize_t *oidLen);
extern int32 mcmsGetSchemeOidFromId(int32 id, unsigned char *oid, psSize_t *oidLen);
extern int32 mcmsGetSymOidFromId(int32 id, unsigned char *oid, psSize_t *oidLen);
extern int32 mcmsCmpPbkdf2Params(unsigned char *oid, psSize_t oidLen);
extern void mcmsGetOidAuthEnc(unsigned char *oid, psSize_t *oidLen);
extern void mcmsGetOidPBKDF2(unsigned char *oid, psSize_t *oidLen);

extern int32 matrixCmsParseRecipientInfos(psPool_t *pool,
                                          const unsigned char *buf, uint32 bufLen, cmsEncryptedEnvelope_t *ee);
extern int32 matrixCmsParseEncryptedContentInfo(psPool_t *pool,
                                                const unsigned char *buf,   uint32 bufLen, cmsEncryptedEnvelope_t *ee);

extern void psX963KeyDerivation(int32 hashSize, unsigned char *secret,
                                int32 secretLen, unsigned char *out, int32 outKeyLen);

extern int32 matrixCmsConfirmRecipient(psPool_t *pool,
                                       cmsEncryptedEnvelope_t *ee, const psX509Cert_t *originatorCert,
                                       const psPubKey_t *privKey);
extern int32 matrixCmsDecryptAED(psPool_t *pool, cmsEncryptedEnvelope_t *ee,
                                 unsigned char **content, int32 *contentLen, int32 flags);

# else
#  error "Must define USE_CMS in cryptoConfig.h"
# endif /* USE_CMS */
#endif  /* _h_PS_MCMS */
