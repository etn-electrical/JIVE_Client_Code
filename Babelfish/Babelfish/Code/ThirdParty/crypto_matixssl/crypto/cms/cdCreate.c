/**
 *      @file    cdCreate.c
 *
 *
 *      Compresssed-Data creation.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "matrixCmsApi.h"
#include "cryptoImpl.h"

#ifdef USE_CMS

# if defined(USE_MCMS_ATOMIC_CD_CREATE) || defined(USE_MCMS_STREAMING_CD_CREATE)

#  ifdef USE_MCMS_ATOMIC_CD_CREATE
/*
    The atomic version.  Pass in the fully compressed data and it will be
        mem copied into the right spot

    CompressedData ::= SEQUENCE {
        version CMSVersion,
        compressionAlgorithm CompressionAlgorithmIdentifier,
        encapContentInfo EncapsulatedContentInfo
        }
 */
int32 matrixCmsCreateCompressedData(psPool_t *pool,
    unsigned char *compressedData, int32 compressedDataLen,
    unsigned char **compressedDataType, int32 *compressedDataTypeLen,
    int32 flags)
{
    unsigned char *p, *start;
    unsigned char gsoid[CM_MAX_OID_LEN];
    unsigned char zliboid[CM_MAX_OID_LEN];
    int32 rc, zliblen;
    psSize_t cLen, tLen, sLen, gsLen, gsoidLen, zliboidLen;

    /* EncapsulatedContentInfo */
    unsigned char oid[CM_MAX_OID_LEN];
    psSize_t ceLen, tencapLen, aLen, ctLen, oidLen;

    /* Octet string */
    ceLen = compressedDataLen + asn1TLOverhead(compressedDataLen);
    aLen = ceLen;
    /* EXPLICIT OPTIONAL wrap */
    ceLen += asn1TLOverhead(ceLen);

    mcmsGetPkcsOidFromId(CMS_PKCS9_CONTENT_TYPE, &oid[0], &oidLen);
    ctLen =  oidLen + asn1TLOverhead(oidLen); /* OBJECT ID wrap */

    /* A SEQUENCE wraps the EncapsulatedContentInfo */
    tencapLen = ceLen + ctLen + asn1TLOverhead(ceLen + ctLen);

    /* CompressionAlgorithm */
    mcmsGetAlgOidFromId(OID_COMPRESSION_ZLIB, &zliboid[0], &zliboidLen);


    zliblen = zliboidLen + asn1TLOverhead(zliboidLen);
    cLen = tencapLen +  zliblen + asn1TLOverhead(zliblen) +
           1 + asn1TLOverhead(1);

    sLen = cLen + asn1TLOverhead(cLen);

    /* General syntax */
    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        gsLen = 0;
    }
    else
    {
        mcmsGetPkcsOidFromId(CMS_PKCS9_COMPRESSED_DATA, &gsoid[0], &gsoidLen);
        gsLen = gsoidLen + asn1TLOverhead(gsoidLen); /* OID wrap */
        gsLen += asn1TLOverhead(sLen);               /* EXPLICIT */
    }

    tLen = gsLen + sLen + asn1TLOverhead(sLen + gsLen);

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        rc = PS_MEM_FAIL;
        goto LBL_ERR;
    }

    /* Doing the write */
    start = p;

    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        /* Already didn't include outer sequence and OID.  Now removing
            CONTEXT_SPECIFIC and length bytes */
        tLen -= asn1TLOverhead(sLen);
    }
    else
    {
        /*      ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        p += asnHelpWriteLength(p, sLen + gsLen);

        p += asnWriteOidChars(p, gsoid, gsoidLen);

        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
        p += asnHelpWriteLength(p, sLen);
    }

    /* CompressedData */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, cLen);

    /*  CMSVersion MUST be 0. */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = 0 & 0xFF; p++;

    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, zliblen);
    p += asnWriteOidChars(p, zliboid, zliboidLen);

    /* EncapsulatedContentInfo ::= SEQUENCE {
            eContentType ContentType,
            eContent [0] EXPLICIT OCTET STRING OPTIONAL }

        ContentType ::= OBJECT IDENTIFIER */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, ceLen + ctLen);

    p += asnWriteOidChars(p, oid, oidLen);

    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, aLen);

    *p = ASN_OCTET_STRING; p++;
    p += asnHelpWriteLength(p, compressedDataLen);
    Memcpy(p, compressedData, compressedDataLen);
    p += compressedDataLen;

    /* sanity */
    cLen = (int32) (p - start);
    psAssert(cLen == tLen);

    *compressedDataType = start;
    *compressedDataTypeLen = cLen;

    rc = PS_SUCCESS;

LBL_ERR:
    return rc;
}

#  endif /* USE_MCMS_ATOMIC_CD_CREATE */

#  ifdef USE_MCMS_STREAMING_CD_CREATE
/*
    The streaming init function can return all of the CMS data up to
    the content itself.  This requires BER indefinite-length encoding.

    The dataOut can be freed (psFree) as soon as it is used.  It is not
    needed for any of the subsequent Update or Final calls */
int32 matrixCmsInitCreateCompressedData(psPool_t *pool,
    unsigned char **dataOut, int32 *dataOutLen, int32 flags)
{
    unsigned char *p, *start;
    unsigned char gsoid[CM_MAX_OID_LEN];
    unsigned char zliboid[CM_MAX_OID_LEN];
    unsigned char oid[CM_MAX_OID_LEN];
    int32 zliblen;
    psSize_t tLen, sLen, gsoidLen, zliboidLen, ctLen, oidLen;

    mcmsGetPkcsOidFromId(CMS_PKCS9_CONTENT_TYPE, &oid[0], &oidLen);
    ctLen =  oidLen + asn1TLOverhead(oidLen); /* OBJECT ID wrap */

    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        sLen =  0;
    }
    else
    {
        mcmsGetPkcsOidFromId(CMS_PKCS9_COMPRESSED_DATA, &gsoid[0], &gsoidLen);
        sLen = gsoidLen + asn1TLOverhead(gsoidLen);
    }

    mcmsGetAlgOidFromId(OID_COMPRESSION_ZLIB, &zliboid[0], &zliboidLen);
    zliblen = zliboidLen + asn1TLOverhead(zliboidLen);

    /* Indefinite-lengths for overall SEQ, contentType, and SignedData SEQ */
    tLen = asn1TLOverhead(1) + asn1TLOverhead(1) + asn1TLOverhead(1) +
           /* Indefinite-lengths for the EncapsulatedContent */
           asn1TLOverhead(1) + asn1TLOverhead(1) + asn1TLOverhead(1) +
           /* SEQ around CompressionAlg and 1 byte for version */
           asn1TLOverhead(zliblen) + 1 + asn1TLOverhead(1) +
           ctLen + sLen + zliblen;

    if ((p = psMalloc(pool, tLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }

    start = p;

    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        /* Now removing outer sequence and indefinite length byte */
        tLen -= (asn1TLOverhead(1) + asn1TLOverhead(1));
    }
    else
    {
        /*      General Syntax
            ContentInfo ::= SEQUENCE {
                contentType ContentType,
                content [0] EXPLICIT ANY DEFINED BY contentType }

            ContentType ::= OBJECT IDENTIFIER */
        *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
        *p = 0x80; p++;

        p += asnWriteOidChars(p, gsoid, gsoidLen);

        *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0; p++;
        *p = 0x80; p++;
    }

    /* CompressedData ::= SEQUENCE {
        version CMSVersion,
        compressionAlgorithm CompressionAlgorithmIdentifier,
        encapContentInfo EncapsulatedContentInfo
        }
     */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    /*  CMSVersion MUST be 0. */
    *p = ASN_INTEGER; p++;
    p += asnHelpWriteLength(p, 1);
    *p = 0 & 0xFF; p++;

    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    p += asnHelpWriteLength(p, zliblen);
    p += asnWriteOidChars(p, zliboid, zliboidLen);

    /*  EncapsulatedContentInfo ::= SEQUENCE {
            eContentType ContentType,
            eContent [0] EXPLICIT OCTET STRING OPTIONAL }

        ContentType ::= OBJECT IDENTIFIER */
    *p = ASN_SEQUENCE | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    p += asnWriteOidChars(p, oid, oidLen);

    *p = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    /* CONSTRUCTED OCTET string */
    *p = ASN_OCTET_STRING | ASN_CONSTRUCTED; p++;
    *p = 0x80; p++;

    /* sanity */
    ctLen = (int32) (p - start);
    psAssert(ctLen == tLen);

    *dataOutLen = ctLen;
    *dataOut = start;

    return 0;
}

/* Writes the continuation of a constructed OCTET string type */
int32 matrixCmsUpdateCreateCompressedData(psPool_t *pool,
    unsigned char *compressedIn, int32 compressedInLen,
    unsigned char **dataOut, int32 *dataOutLen)
{
    unsigned char *p, *start;
    int32 conLen, tLen;

    conLen = compressedInLen + asn1TLOverhead(compressedInLen);

    if ((p = psMalloc(pool, conLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }

    start = p;

    *p = ASN_OCTET_STRING; p++;
    p += asnHelpWriteLength(p, compressedInLen);
    Memcpy(p, compressedIn, compressedInLen);
    p += compressedInLen;

    /* sanity */
    tLen = (int32) (p - start);
    psAssert(tLen == conLen);

    *dataOut = start;
    *dataOutLen = tLen;
    return 0;
}


/* Finalizes the compressed data CONSTRUCTED octet string with the two
    end-of-contents bytes AND also has to close all the other
    indefinite-length constructs that were created in the init call.  There
    are 6 total at 2 bytes each

    In the NO_CONTENT case, there are two ends (4 total bytes) that are not
    used.  There is no CD context here so this final call must take the same
    flags value passed to matrixCmsInitCreateCompressedData.
 */
int32 matrixCmsFinalCreateCompressedData(psPool_t *pool,
    unsigned char **dataOut, int32 *dataOutLen, int32 flags)
{
    int32 emptyBytes;

    if (flags & MCMS_FLAGS_NO_CONTENT_INFO)
    {
        emptyBytes = 8;
    }
    else
    {
        emptyBytes = 12;
    }

    /* Final data are two 0 bytes to indicate end of CONSTRUCTED octet string */
    if ((*dataOut = psMalloc(pool, emptyBytes)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    *dataOutLen = emptyBytes;
    Memset(*dataOut, 0x0, emptyBytes);
    return 0;
}

#  endif /* USE_MCMS_STREAMING_CD_CREATE */
# endif  /* ATOMIC or STREAMING */
#endif   /* USE_CMS */
