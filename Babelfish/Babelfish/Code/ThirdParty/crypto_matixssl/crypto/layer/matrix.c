/**
 *      @file    matrix.c
 *
 *
 *      Matrix Crypto Initialization and utility layer.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

#ifdef USE_ROT_CRYPTO
# include "../../crypto-rot/rotCommon.h"
#endif

/******************************************************************************/
/**
    Open (initialize) the Crypto module.

    The config param should always be passed as:
        PSCRYPTO_CONFIG
 */
static char g_config[32] = "N";

int32_t psCryptoOpen(const char *config)
{
    uint32_t clen;
    
    if (*g_config == 'Y')
    {
        return PS_SUCCESS; /* Function has been called previously */
    }

    /* 'config' is cryptoconfig + coreconfig */
    clen = Strlen(PSCRYPTO_CONFIG) - Strlen(PSCORE_CONFIG);
    if (Strncmp(PSCRYPTO_CONFIG, config, clen) != 0)
    {
        psErrorStr( "Crypto config mismatch.\n" \
            "Library: " PSCRYPTO_CONFIG \
            "\nCurrent: %s\n", config);
        return PS_FAILURE;
    }
    if (psCoreOpen(config + clen) < 0)
    {
        psError("pscore open failure\n");
        return PS_FAILURE;
    }

#ifdef USE_FLPS_BINDING
    flps_binding();
    /* Check if FIPS Library Open failed. */
    if ((int)CLS_LibStatus(flps_getCLS()) < 0)
    {
        return PS_SELFTEST_FAILED;
    }
#endif /* USE_FLPS_BINDING */
#ifdef USE_ROT_ECC
    /* Pre-allocate domain assets for all ECC curves supported by the
       compile-time configuration. */
# ifdef USE_SECP256R1
    if (psRotLoadCurve(IANA_SECP256R1, NULL) != PS_SUCCESS)
    {
        psError("psRotLoadCurve failed during psCryptoOpen\n");
        return PS_FAILURE;
    }
# endif /* USE_SECP256R1 */
# ifdef USE_SECP384R1
    if (psRotLoadCurve(IANA_SECP384R1, NULL) != PS_SUCCESS)
    {
        psError("psRotLoadCurve failed during psCryptoOpen\n");
        return PS_FAILURE;
    }
# endif /* USE_SECP384R1 */
# ifdef USE_SECP521R1
    if (psRotLoadCurve(IANA_SECP521R1, NULL) != PS_SUCCESS)
    {
        psError("psRotLoadCurve failed during psCryptoOpen\n");
        return PS_FAILURE;
    }
# endif /* USE_SECP521R1 */
#endif /* USE_ROT_ECC */
#ifdef USE_LIBSODIUM_CRYPTO
    if (sodium_init() == -1)
    {
        return PS_FAILURE;
    }
#endif /* USE_LIBSODIUM_CRYPTO */
#ifdef USE_MATRIX_CHACHA20_POLY1305_IETF
    /* Pick chacha20-poly1305 implementation. */
    {
        psChacha20Poly1305Ietf_t tmp;
        (void) psChacha20Poly1305IetfInit(
                &tmp,
                (const unsigned char *)g_config /* at least 32 bytes */);
    }
#endif

    psOpenPrng();
#ifdef USE_CRL
    psCrlOpen();
#endif
    /* Everything successful, store configuration. */
    Strncpy(g_config, PSCRYPTO_CONFIG, sizeof(g_config) - 1);

    return PS_SUCCESS;
}

void psCryptoClose(void)
{
#ifdef USE_ROT_ECC
# ifdef USE_SECP256R1
    psRotFreeCurveAsset(IANA_SECP256R1);
# endif
# ifdef USE_SECP384R1
    psRotFreeCurveAsset(IANA_SECP384R1);
# endif
# ifdef USE_SECP521R1
    psRotFreeCurveAsset(IANA_SECP521R1);
# endif
# ifdef DEBUG_ROT_ASSETS
    psRotFreeAllAssets();
# endif
#endif
    if (*g_config == 'Y')
    {
        *g_config = 'N';
        psClosePrng();
        psCoreClose();
#ifdef USE_CRL
        psCrlClose();
#endif
    }
}

/******************************************************************************/
/**
    Give a best guess at the pool size required for a public or private
    key operation, given the key length and type.

    These numbers were calculated by trial and error over many runtimes.
    keylen is the length of the key in bytes (should be a power of 2)
    pubSize is the estimate of the pool size required to do a public key op
    pubSize is the estimate of the pool size required to do a private key op
*/
int32_t psEstimatePkiPoolSize(psSize_t keylen, uint8_t type,
    psSize_t *pubSize, psSize_t *privSize)
{
    switch (type)
    {
    case PS_DH:
    case PS_RSA:
        switch (keylen)
        {
# if (MIN_RSA_BITS <= 512) || (MIN_DH_BITS <= 512)
        case 64:
            *pubSize = 2048;
            *privSize = 3072;
            break;
# endif
# if (MIN_RSA_BITS <= 1024) || (MIN_DH_BITS <= 1024)
        case 128:
            *pubSize = 2472;
            *privSize = 4844;
            break;
# endif
# if (MIN_RSA_BITS <= 2048) || (MIN_DH_BITS <= 2048)
        case 256:
            *pubSize = 5120;
            *privSize = 11264;
            break;
# endif
# if (MIN_RSA_BITS <= 3072) || (MIN_DH_BITS <= 3072)
        case 384:
# endif
# if (MIN_RSA_BITS <= 4096) || (MIN_DH_BITS <= 4096)
        case 512:
            *pubSize = 8192;
            /* server side 4096 DH params and 4096 RSA key hit this */
            *privSize = 22528;
            break;
# endif
        default:
            psTraceIntCrypto("Unsupported RSA keysize: %d\n", keylen);
            return PS_ARG_FAIL;
        } /* switch(keylen) */
        break;

    case PS_ECC:
        switch (keylen)
        {
# if (MIN_ECC_BITS <= 192)
        case 48:
            *pubSize = 6912;
            *privSize = 6912;
            break;
# endif
# if (MIN_ECC_BITS <= 224)
        case 56:
            *pubSize = 6912;
            *privSize = 6912;
            break;
# endif
# if (MIN_ECC_BITS <= 256)
        case 64:
            *pubSize = 8192;
            *privSize = 8192;
            break;
# endif
# if (MIN_ECC_BITS <= 384)
        case 96:
            *pubSize = 9216;
            *privSize = 9216;
            break;
# endif
# if (MIN_ECC_BITS <= 521)
        case 132:
            *pubSize = 10752;
            *privSize = 10752;
            break;
# endif
        default:
            psTraceIntCrypto("Unsupported ECC keysize: %d\n", keylen);
            return PS_ARG_FAIL;
        } /* switch(keylen) */
        break;

    default:
        psTraceIntCrypto("Unsupported key type %d\n", type);
        return PS_ARG_FAIL;
    } /* switch(type) */

    /* TODO - hack in adding 2K to both. */
    *pubSize += sizeof(psPool_t) + 2048;
    *privSize += sizeof(psPool_t) + 2048;
    return PS_SUCCESS;
}

/******************************************************************************/
