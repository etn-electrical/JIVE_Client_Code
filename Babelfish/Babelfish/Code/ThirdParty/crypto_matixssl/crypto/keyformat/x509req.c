/**
 *      @file    x509req.c
 *
 *
 *      Functions to read/write PKCS#10 cert requests.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

#ifdef USE_CERT_GEN

static int32 psAsnParseCertRequest(psPool_t *pool, unsigned char **pp,
                                   int32 size, psPubKey_t *key, x509DNattributes_t **DN,
                                   x509v3extensions_t **certExt, psCertReq_t *csr);

/* These are defined in x509enc.c */
extern int32 md5RSAOID[9];
extern int32 sha1RSAOID[9];
extern int32 sha224RSAOID[9];
extern int32 sha256RSAOID[9];
extern int32 sha384RSAOID[9];
extern int32 sha512RSAOID[9];
extern int32 sha1ECCOID[7];
extern int32 sha224ECCOID[8];
extern int32 sha256ECCOID[8];
extern int32 sha384ECCOID[8];
extern int32 sha512ECCOID[8];

static unsigned char g_extRequest[9] = {
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x0E
};

static unsigned char g_challengePassword[9] = {
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x07
};

# ifdef MATRIX_USE_FILE_SYSTEM
/******************************************************************************/
/*
    Certificate request reading.
    Returns the ASN.1 buffer from a certificate request file
 */
int32 psParseCertReqFile(psPool_t *pool, const char *fileName,
    unsigned char **reqOut, int32 *reqOutLen)
{
    char *start, *end;
    unsigned char *reqBuf, *DERout;
    int32 PEMlen, DERlen;
    psSizeL_t reqBufLen;
    psRes_t rc;

    if (fileName == NULL)
    {
        return 0;
    }
    if ((rc = psGetFileBuf(pool, fileName, &reqBuf, &reqBufLen)) < 0)
    {
        return rc;
    }

    start = end = NULL;

/*
 *      Check header and encryption parameters.
 */
    if ((start = Strstr((char *) reqBuf, "-----BEGIN CERTIFICATE REQUEST-----"))
        == NULL)
    {
        psTraceCrypto("Error parsing cert request buffer\n");
        psFree(reqBuf, pool);
        return -1;
    }
    start += Strlen("-----BEGIN CERTIFICATE REQUEST-----");
    while (*start == '\r' || *start == '\n')
    {
        start++;
    }

    if ((end = Strstr((char *) reqBuf, "-----END CERTIFICATE REQUEST-----"))
        == NULL)
    {
        psTraceCrypto("Error parsing cert request buffer\n");
        psFree(reqBuf, pool);
        return -1;
    }
    PEMlen = (int32) (end - start);

/*
    Take the raw input and do a base64 decode
 */
    if ((DERout = psMalloc(pool, PEMlen)) == NULL)
    {
        psFree(reqBuf, pool);
        return -1;
    }
    DERlen = PEMlen;
    if (psBase64decode((unsigned char *) start, PEMlen, DERout,
            (uint16_t *) &DERlen) != 0)
    {
        psFree(DERout, pool);
        psFree(reqBuf, pool);
        psTraceCrypto("Unable to base64 decode private key\n");
        return -1;
    }
    psFree(reqBuf, pool);

/*
    Assign to output params and leave
 */
    *reqOut = DERout;
    *reqOutLen = DERlen;
    return rc;
}
# endif /* MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/
/*
    Parse a certificate request buffer to populate the public RSA key and
    DN output parameters.
 */
static
int32 parse_csr(psPool_t *pool, unsigned char *reqBuf,
    int32 reqBufLen, x509DNattributes_t **DN, psPubKey_t **key,
    x509v3extensions_t **reqExt, psCertReq_t **parsedReq)
{
    psPubKey_t *lkey;
    psCertReq_t *req = NULL;

    if (psNewPubKey(pool, PS_NOKEY, &lkey) < 0)
    {
        return PS_MEM_FAIL;
    }

    if (parsedReq)
    {
        req = psMalloc(pool, sizeof(psCertReq_t));
        if (req == NULL)
        {
            psDeletePubKey(&lkey);
            return PS_MEM_FAIL;
        }
        Memset(req, 0, sizeof(psCertReq_t));
    }

    if (psAsnParseCertRequest(pool, &reqBuf, reqBufLen, lkey, DN,
            reqExt, req) < 0)
    {
        psDeletePubKey(&lkey);
        psFree(req, pool);
        return -1;
    }
    *key = lkey;

    if (parsedReq)
    {
        *parsedReq = req;
    }

    return 0;
}

int32 psParseCertReqBuf(psPool_t *pool, unsigned char *reqBuf,
    int32 reqBufLen, x509DNattributes_t **DN, psPubKey_t **key,
    x509v3extensions_t **reqExt)
{
    return parse_csr(pool, reqBuf, reqBufLen, DN, key, reqExt, NULL);

}

int32 psParseCertReqBufExt(psPool_t *pool, unsigned char *reqBuf,
    int32 reqBufLen, x509DNattributes_t **DN, psPubKey_t **key,
    x509v3extensions_t **reqExt, psCertReq_t **parsedReq)
{
    return parse_csr(pool, reqBuf, reqBufLen, DN, key, reqExt, parsedReq);
}

int32_t psCertReqGetSignatureAlgorithm(psCertReq_t *req)
{
    return req->sigAlg;
}

int32_t psCertReqGetPubKeyAlgorithm(psCertReq_t *req)
{
    return req->pubKeyAlg;
}

int32_t psCertReqGetVersion(psCertReq_t *req)
{
    return req->version;
}

/* Common worker for all psCertReqGetChallengePassword() variants.
   Parse ASN.1 primitive types or constructed types until idx'th type.
   idx=-1 can be used to find number of items. */
static
const
unsigned char *psCertReqGetChallengePasswordWorker(psCertReq_t *req,
                                                   int32_t idx,
                                                   psStringType_t *type_p,
                                                   psSize_t *len_p,
                                                   int32_t *idx_p)
{
    psRes_t rc;
    const unsigned char *p;
    const unsigned char *old_p;
    psSize_t size;
    psSize_t elemlen;
    psStringType_t type;
    int32_t i;

    if (req->challengeAttribute == NULL || req->challengeAttributeLen == 0)
    {
        return NULL;
    }

    p = req->challengeAttribute;
    size = req->challengeAttributeLen;

    i = 0;
    while(size > 1)
    {
        old_p = p;
        type = (psStringType_t) *(p++);
        rc = getAsnLength(&p, size - 1, &elemlen);
        if (rc != PS_SUCCESS)
        {
            *idx_p = i + 1; /* Add 1 for the extra bytes available. */
            return NULL;
        }

        /* Successfully retrieved the index. */
        if (idx == i)
        {
            /* Found the index. */
            *type_p = type;
            *len_p = elemlen;
            *idx_p = i;
            return p;
        }

        /* Skip to the next element and adjust the size remaining. */
        p += elemlen;
        size -= (psSize_t) (p - old_p);
        i++;
    }

    /* Note: return length if there is one extra byte. */
    *idx_p = i + (int32_t) size;
    return NULL; /* fallback. */
}

int32_t psCertReqNumChallengePassword(psCertReq_t *req)
{
    psStringType_t type;
    psSize_t len;
    int idx = 0;

    if (req->challengeAttribute == NULL || req->challengeAttributeLen == 0)
    {
        return 0;
    }

    /* Use idx == -1 to extract the number of indexes. */
    (void) psCertReqGetChallengePasswordWorker(req, -1, &type, &len, &idx);
    return idx;
}

const unsigned char *psCertReqGetChallengePassword(psCertReq_t *req,
                                                   int32_t idx)
{
    psStringType_t type;
    psSize_t len;
    int idxo;

    return psCertReqGetChallengePasswordWorker(req, idx, &type, &len, &idxo);
}

psSize_t psCertReqGetChallengePasswordLen(psCertReq_t *req, int32_t idx)
{
    psStringType_t type;
    psSize_t len = 0;
    int idxo;

    (void) psCertReqGetChallengePasswordWorker(req, idx, &type, &len, &idxo);
    return len;
}

psStringType_t psCertReqGetChallengePasswordType(psCertReq_t *req, int32_t idx)
{
    psStringType_t type = (psStringType_t) 0; /* String type is undefined. */
    psSize_t len;
    int idxo;

    (void) psCertReqGetChallengePasswordWorker(req, idx, &type, &len, &idxo);
    return type;
}


/******************************************************************************/
/*
    Parse a certificate request file.  Needed for CA issued certs.

    NOTE:  The key param has been allocated already.  If error, we free
    the key here and set to NULL.  The caller tests the error code and the
    value of key to see if needs to free it.
 */
static int32_t psAsnParseCertRequest(psPool_t *pool, unsigned char **pp,
    int32 size, psPubKey_t *key, x509DNattributes_t **DN,
    x509v3extensions_t **certExt, psCertReq_t *csr)
{
    psDigestContext_t hash;
    x509v3extensions_t *ext;
    x509DNattributes_t *DNsubject;
    unsigned char *sig, *sigEnd, *sigStart, *subjectKeyId;
    const unsigned char *p, *end;
    const unsigned char *tag_start;
    unsigned char sha1KeyHash[SHA1_HASH_SIZE];
    int32 version, pubKeyAlg, sigAlg, subjectKeyIdLen;
    psSize_t sigLen, totallen, len, param, arcLen;
    psRes_t rc;
    psBool_t verifyResult;
    psVerifyOptions_t opts;

    p = *pp;
    end = p + size;
/*
    Sequence around entire thing
 */
    if (getAsnSequence(&p, size, &totallen) < 0)
    {
        psTraceCrypto("ASN sequence parse error\n");
        return -1;
    }
    sigStart = (unsigned char *) p;
/*
    Sequence around CertificationRequestInfo portion
 */
    if (getAsnSequence(&p, size, &len) < 0)
    {
        psTraceCrypto("ASN sequence parse error\n");
        return -1;
    }

    if (getAsnInteger(&p, (int32) (end - p), &version) < 0 || version != 0)
    {
        return -1;
    }

    if ((DNsubject = psMalloc(pool, sizeof(x509DNattributes_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(DNsubject, 0x0, sizeof(x509DNattributes_t));
    if (psX509GetDNAttributes(pool, &p, (int32) (end - p), DNsubject,
            CERT_STORE_DN_BUFFER) < 0)
    {
        psFree(DNsubject, pool);
        return -1;
    }

/*
    SubjectPublicKeyInfo  ::=  SEQUENCE  {
        algorithm                       AlgorithmIdentifier,
        subjectPublicKey        BIT STRING      }
 */
    if (getAsnSequence(&p, (int32) (end - p), &len) < 0)
    {
        psX509FreeDNStruct(DNsubject, pool);
        psFree(DNsubject, pool);
        return -1;
    }

    if (getAsnAlgorithmIdentifier(&p, (int32) (end - p), &pubKeyAlg, &param)
        < 0)
    {
        psX509FreeDNStruct(DNsubject, pool);
        psFree(DNsubject, pool);
        return -1;
    }

    switch (pubKeyAlg)
    {
# ifdef USE_RSA
    case OID_RSA_KEY_ALG:
        psAssert(param == 0);
        psInitPubKey(key->pool, key, PS_RSA);
        if (psRsaParseAsnPubKey(pool, &p, (uint16_t) (end - p), &key->key.rsa,
                sha1KeyHash) < 0)
        {
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            return -1;
        }
        key->keysize = psRsaSize(&key->key.rsa);
        break;
# endif
# ifdef USE_ECC
    case OID_ECDSA_KEY_ALG:
        psInitPubKey(key->pool, key, PS_ECC);
        /* getEcPubKey is picking up at the "parameters" of the ECpubKey OID */
        if (getEcPubKey(pool, &p, (uint16_t) (end - p), &key->key.ecc,
                sha1KeyHash) < 0)
        {
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            return -1;
        }
        break;
# endif
    default:
        psX509FreeDNStruct(DNsubject, pool);
        psFree(DNsubject, pool);
        return PS_UNSUPPORTED_FAIL;
    }

    /* Always making an extension structure because we want to create our own
        SubjectKeyId in the extension */
    if (x509NewExtensions(&ext, pool) < 0)
    {
        psFree(DNsubject, pool);
        return PS_MEM_FAIL;
    }

    /* Attributes */
    if (*(p++) != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED))
    {
        psX509FreeDNStruct(DNsubject, pool);
        psFree(DNsubject, pool);
        psFree(ext, pool);
        return -1;
    }
    if (*p != 0)
    {
        /* Attributes */
        if (getAsnLength(&p, (uint32) (end - p), &len) < 0 ||
            (uint32) (end - p) < len)
        {
            psTraceCrypto("Attribute len parse failed\n");
            x509FreeExtensions(ext);
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            psFree(ext, pool);
            return PS_PARSE_FAIL;
        }
        const unsigned char *endAttrib = p + len;

        psTracefCrypto("Parsing CSR attributes: "PSF"\n",
                       PSA_DER(p, len, 0, 0, 32, 0));

    more_oids:
        if (getAsnSequence(&p, (int32) (end - p), &len) < 0)
        {
            x509FreeExtensions(ext);
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            psFree(ext, pool);
            return -1;
        }

        tag_start = p; /* remember beginning of OID tag. */
        if (*(p++) != ASN_OID ||
            getAsnLength(&p, (int32) (end - p), &arcLen) < 0)
        {
            x509FreeExtensions(ext);
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            psFree(ext, pool);
            return -1;
        }

        if (end - p < arcLen)
        {
            x509FreeExtensions(ext);
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            psFree(ext, pool);
            return -1;
        }
        /* Supporting pkcs-9-ub-challengePassword
            2A 86 48 86 F7 0D 01 09 07 */
        if (arcLen == 9 && Memcmp(p, g_challengePassword, arcLen) == 0)
        {
            psSize_t len2;

            /* adjust ptr and length: the OID tag header [2] + tag length. */
            p = p + arcLen;
            len = len - (int) (p - tag_start);

            tag_start = p;
            if (getAsnSet(&p, (int)len, &len2) < 0 ||
                tag_start + len != p + len2)
            {
                x509FreeExtensions(ext);
                psX509FreeDNStruct(DNsubject, pool);
                psFree(DNsubject, pool);
                psFree(ext, pool);
                return -1;
            }

            /* Skip to the beginning of SET element. */
            psTracefCrypto("challengePassword received: "PSF"\n",
                           PSA_DER(p, len2, 0, 0, 32, 0));

            if (csr)
            {
                /* Store pointer. */
                csr->challengeAttribute = p;
                csr->challengeAttributeLen = len2;
            }

            p += len2; /* Skip until end of the challenge password. */
            goto skip_after_challenge_password;
        }
        /* Supporting pkcs-9-at-extensionRequest
            2A 86 48 86 F7 0D 01 09 0E */
        if (arcLen != 9 || Memcmp(p, g_extRequest, arcLen) != 0)
        {
            psTracefCrypto("Unsupported extension OID: "PSF"\n",
                           PSA_DER(tag_start, len, 0, 0, 32, 0));
            x509FreeExtensions(ext);
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            psFree(ext, pool);
            return -1;
        }

        p += arcLen;
        if (getAsnSet(&p, (int32) (end - p), &len) < 0)
        {
            x509FreeExtensions(ext);
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            psFree(ext, pool);
            return -1;
        }

        psTracefCrypto("Parsing pkcs-9-at-extensionRequest: "PSF"\n",
                       PSA_DER(p, len, 0, 0, 32, 0));

        if (getExplicitExtensions(pool, &p, (uint32) (end - p), 0, ext, 1)
            < 0)
        {
            x509FreeExtensions(ext);
            psFree(ext, pool);
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            return -1;
        }
    skip_after_challenge_password:
        ;
        if (p < endAttrib)
        {
            psTraceIntCrypto("Parsing more attributes (%d bytes left)\n",
                             (int) (endAttrib - p));

            if (*p == (ASN_SEQUENCE | ASN_CONSTRUCTED))
            {
                goto more_oids;
            }
            else
            {
                x509FreeExtensions(ext);
                psFree(ext, pool);
                psX509FreeDNStruct(DNsubject, pool);
                psFree(DNsubject, pool);
                return -1;
            }
        }
    }
    else
    {
        p++;
    }

    /* Saving SubjectKeyId.  Doing after parse so we can override if exists */

    if (ext->sk.id != NULL)
    {
        psTraceCrypto("WARNING: Certificate request contained SubjectKeyId.\n");
        psTraceCrypto("Ignoring that extension and re-creating SubjectKeyId.\n");
        psFree(ext->sk.id, pool);
    }
    if ((ext->sk.id = psMalloc(pool, 20)) == NULL)
    {
        x509FreeExtensions(ext);
        psFree(ext, pool);
        psX509FreeDNStruct(DNsubject, pool);
        psFree(DNsubject, pool);
        return PS_MEM_FAIL;
    }
    /* RFC 3280 - (1) The keyIdentifier is composed of the 160-bit SHA-1
        hash of the value of the BIT STRING subjectPublicKey (excluding the
        tag, length, and number of unused bits). */
    ext->sk.len = 20; /* SHA1 */
    switch (pubKeyAlg)
    {
# ifdef USE_RSA
    case OID_RSA_KEY_ALG:
        subjectKeyIdLen = pstm_unsigned_bin_size(&key->key.rsa.N);
        if ((subjectKeyId = psMalloc(pool, subjectKeyIdLen)) == NULL)
        {
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            x509FreeExtensions(ext);
            psFree(ext, pool);
            return PS_MEM_FAIL;
        }
        pstm_to_unsigned_bin(pool, &key->key.rsa.N, subjectKeyId);
        break;
# endif /* USE_RSA */
# ifdef USE_ECC
    case OID_ECDSA_KEY_ALG:
        /* Magic 1 is 0x4 uncompressed key type byte */
        subjectKeyIdLen = pstm_unsigned_bin_size(&key->key.ecc.pubkey.x) +
                          pstm_unsigned_bin_size(&key->key.ecc.pubkey.y) + 1;
        if ((subjectKeyId = psMalloc(pool, subjectKeyIdLen)) == NULL)
        {
            psX509FreeDNStruct(DNsubject, pool);
            psFree(DNsubject, pool);
            x509FreeExtensions(ext);
            psFree(ext, pool);
            return PS_MEM_FAIL;
        }
        *subjectKeyId = 0x4; /* uncompressed format */
        pstm_to_unsigned_bin(pool, &key->key.ecc.pubkey.x, subjectKeyId + 1);
        pstm_to_unsigned_bin(pool, &key->key.ecc.pubkey.y, subjectKeyId + 1 +
            pstm_unsigned_bin_size(&key->key.ecc.pubkey.x));
        break;
# endif /* USE_ECC */
    default:
        psTraceIntCrypto("Unsupported pub key alg: %d\n", pubKeyAlg);
        return PS_UNSUPPORTED_FAIL;
    }

    psSha1PreInit(&hash.u.sha1);
    psSha1Init(&hash.u.sha1);
    psSha1Update(&hash.u.sha1, subjectKeyId, subjectKeyIdLen);
    psSha1Final(&hash.u.sha1, ext->sk.id);
    psFree(subjectKeyId, pool);

    sigEnd = (unsigned char *) p;

/*
    Down to the signature algorithm stuff now
 */
    if (getAsnAlgorithmIdentifier(&p, (int32) (end - p), &sigAlg, &param)
        < 0)
    {
        x509FreeExtensions(ext);
        psFree(ext, pool);
        psX509FreeDNStruct(DNsubject, pool);
        psFree(DNsubject, pool);
        return -1;
    }

    /*
       Store some additional information about the parsed CSR.
     */
    if (csr)
    {
        csr->sigAlg = sigAlg;
        csr->pubKeyAlg = pubKeyAlg;
        csr->version = version;
    }

    psAssert(param == 0);
    sigLen = 0;
    if (psX509GetSignature(pool, &p, (int32) (end - p), &sig,
            (uint16_t *) &sigLen) < 0)
    {
        x509FreeExtensions(ext);
        psFree(ext, pool);
        psX509FreeDNStruct(DNsubject, pool);
        psFree(DNsubject, pool);
        return -1;
    }

    /*
       Verify the signature of the CSR.
     */
    Memset(&opts, 0, sizeof(psVerifyOptions_t));
    opts.msgIsDigestInfo = PS_TRUE;

    rc = psHashDataAndVerifySig(pool,
        sigStart, sigEnd - sigStart,
        sig, sigLen,
        key, sigAlg, &verifyResult, &opts);
    if (rc < 0 || verifyResult == PS_FALSE)
    {
        psTraceCrypto("psHashDataAndVerifySig failed\n");
        x509FreeExtensions(ext);
        psFree(ext, pool);
        psX509FreeDNStruct(DNsubject, pool);
        psFree(DNsubject, pool);
        psFree(sig, pool);
        return PS_FAILURE;
    }

    psFree(sig, pool);

    psTraceCrypto("Cert request authenticated\n");

    *DN = DNsubject;
    *certExt = ext;

    return 0;
}

/******************************************************************************/
/*
    psWriteCertReqMem: Mem version of cert request.
 */

/* Write a cert request using a binary config buffer. */
int32 psWriteCertReqMem_BinConfig(psPool_t *pool, psPubKey_t *key,
    unsigned char *confBin, int32 confBinLen,
    unsigned char **requestMem, int32 *requestMemLen)
{
    psCertConfig_t *reqConfig;
    int32 rc;

    if ((reqConfig = psMalloc(pool, sizeof(psCertConfig_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(reqConfig, 0x0, sizeof(psCertConfig_t));
    if (psX509ParseCertConfigBin(pool, confBin, confBinLen, reqConfig) < 0)
    {
        psFree(reqConfig, pool);
        return -1;
    }

    rc = psWriteCertReqMem(pool, key, reqConfig, requestMem, requestMemLen);
    if (rc < 0)
    {
        psX509FreeCertConfig(reqConfig);
        psFree(reqConfig, pool);
        return rc;
    }

    psX509FreeCertConfig(reqConfig);
    psFree(reqConfig, pool);
    return rc;
}

/* Write a cert request using a filled-in psCertConfig_t struct. */
int32 psWriteCertReqMem(psPool_t *pool, psPubKey_t *key,
    psCertConfig_t *reqConfig,
    unsigned char **requestMem, int32 *requestMemLen)
{
    psBuf_t *reqInfoBuf;
    psCertReqParts_t *reqParts;
    int32 versionLen, subjectDNLen, size;
    int32 pubKeyLen, oidLen, reqAlgIdLen, attribLen;
    int32 *reqAlg;
    psPubKey_t *pubkey;

    pubkey = reqConfig->publicKey ? reqConfig->publicKey : key;

    attribLen = 0;

/*
    Need to init all ASN parts to NULL for easy cleanup if any errors happen
    mid-routine
 */
    if ((reqParts = psMalloc(pool, sizeof(psCertReqParts_t))) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memset(reqParts, 0x0, sizeof(psCertReqParts_t));

/*
    This isn't a proper version ASN.1 type as found in the certs.
    Just a 0 integer type.  Hardcoded.
 */
    versionLen = 3;
    if ((reqParts->versionBuf = psMalloc(pool, versionLen)) == NULL)
    {
        psFree(reqParts, pool);
        return PS_MEM_FAIL;
    }
    reqParts->versionBuf[0] = ASN_INTEGER;
    reqParts->versionBuf[1] = 1;
    reqParts->versionBuf[2] = 0;

    /* Write DN attributes. */
    if (psWriteCertDNAttributes(pool, &reqParts->subjectDNBuf,
                    reqConfig->DNPairs, reqConfig->DNPairsLen, &subjectDNLen,
                    reqConfig->DNPairsEncoding) < 0)
    {
        psTraceCrypto("Error writing subject DN attributes\n");
        psFree(reqParts->versionBuf, pool);
        psFree(reqParts, pool);
        return -1;
    }

    /* Write public key info.  Includes all the algorithm ID info */
    if (psWriteCertPublicKey(pool, &reqParts->pubKeyBuf, pubkey,
            &pubKeyLen) < 0)
    {
        psTraceCrypto("Error writing certificate public key\n");
        if (reqParts->pubKeyBuf.buf)
        {
            psFree(reqParts->pubKeyBuf.buf, pool);
        }
        psFree(reqParts->versionBuf, pool);
        psFree(reqParts->subjectDNBuf.buf, pool);
        psFree(reqParts, pool);
        return -1;
    }

    /* Any extensions?  */
    if (reqConfig->ext)
    {
        if (psWriteCertReqExt(pool, &reqParts->reqExt, reqConfig->ext,
                &attribLen, reqConfig) < 0)
        {
            psFree(reqParts->versionBuf, pool);
            psFree(reqParts->subjectDNBuf.buf, pool);
            psFree(reqParts->pubKeyBuf.buf, pool);
            psFree(reqParts, pool);
            return -1;
        }
    }

    /* Can do the signature algorithm here as well.  This */
    if (reqConfig->certAlg == ALG_SHA1)
    {
        if (key->type == PS_RSA)
        {
            reqAlg = sha1RSAOID;
            oidLen = sizeof(sha1RSAOID) / sizeof(int32);
        }
        else
        {
            reqAlg = sha1ECCOID;
            oidLen = sizeof(sha1ECCOID) / sizeof(int32);
        }
    }
#ifdef USE_SHA224
    else if (reqConfig->certAlg == ALG_SHA224)
    {
        if (key->type == PS_RSA)
        {
            reqAlg = sha224RSAOID;
            oidLen = sizeof(sha224RSAOID) / sizeof(int32);
        }
        else
        {
            reqAlg = sha224ECCOID;
            oidLen = sizeof(sha224ECCOID) / sizeof(int32);
        }
    }
#endif /* USE_SHA224 */
    else if (reqConfig->certAlg == ALG_SHA256)
    {
        if (key->type == PS_RSA)
        {
            reqAlg = sha256RSAOID;
            oidLen = sizeof(sha256RSAOID) / sizeof(int32);
        }
        else
        {
            reqAlg = sha256ECCOID;
            oidLen = sizeof(sha256ECCOID) / sizeof(int32);
        }
    }
    else if (reqConfig->certAlg == ALG_SHA384)
    {
        if (key->type == PS_RSA)
        {
            reqAlg = sha384RSAOID;
            oidLen = sizeof(sha384RSAOID) / sizeof(int32);
        }
        else
        {
            reqAlg = sha384ECCOID;
            oidLen = sizeof(sha384ECCOID) / sizeof(int32);
        }
    }
    else if (reqConfig->certAlg == ALG_SHA512)
    {
        if (key->type == PS_RSA)
        {
            reqAlg = sha512RSAOID;
            oidLen = sizeof(sha512RSAOID) / sizeof(int32);
        }
        else
        {
            reqAlg = sha512ECCOID;
            oidLen = sizeof(sha512ECCOID) / sizeof(int32);
        }
    }
    else
    {
        psFree(reqParts->pubKeyBuf.buf, pool);
        psFree(reqParts->versionBuf, pool);
        psFree(reqParts->subjectDNBuf.buf, pool);
        psFree(reqParts, pool);
        return -1; /* never happens, but makes compiler happy */
    }

    if (psWriteCertAlgorithmId(pool, &reqParts->reqAlgIdBuf, reqAlg,
            oidLen, &reqAlgIdLen) < 0)
    {
        psTraceCrypto("Error constructing digestInfo\n");
        psFree(reqParts->pubKeyBuf.buf, pool);
        psFree(reqParts->versionBuf, pool);
        psFree(reqParts->subjectDNBuf.buf, pool);
        psFree(reqParts, pool);
        return -1;
    }

/*
    Buffer size will be existing lengths as computed above + 2 for the
    attribute member + the signature (SEQUENCE, keySize, bitstring, ignore byte)
 */
    size = versionLen + subjectDNLen + pubKeyLen + reqAlgIdLen + attribLen +
           2 + (ASN_SEQUENCE_OH * 2) + key->keysize + ASN_BIT_STRING_OH + 1 + 2;

    if (key->type == PS_ECC)
    {
        /* Account for the ECC signature overhead */
        if (key->keysize != 132)
        {
            size += 1;
        }
        /* Signature portion */
        size += 6; /* 6 = 2 ASN_SEQ, 4 ASN_BIG */
        /* BIG EC KEY.  The sig is 2 bytes len, 1 byte SEQ,
            1 byte length (+1 OPTIONAL byte if length is >=128),
            1 byte INT, 1 byte rLen, r, 1 byte INT, 1 byte sLen, s.
            So the +4 here are the 2 INT and 2 rLen/sLen bytes on
            top of the keysize */
        if (key->keysize + 4 >= 128)
        {
            size += 1; /* Extra byte for 'long' asn.1 encode */
        }
    }

    if ((reqInfoBuf = psMalloc(pool, sizeof(psBuf_t))) == NULL)
    {
        psFree(reqParts->pubKeyBuf.buf, pool);
        psFree(reqParts->versionBuf, pool);
        psFree(reqParts->subjectDNBuf.buf, pool);
        psFree(reqParts->reqAlgIdBuf.buf, pool);
        psFree(reqParts, pool);
        return PS_MEM_FAIL;
    }

    reqInfoBuf->size = size;
    reqInfoBuf->start = reqInfoBuf->end = reqInfoBuf->buf = psMalloc(pool, size);
    if (reqInfoBuf->start == NULL)
    {
        psFree(reqParts->pubKeyBuf.buf, pool);
        psFree(reqParts->versionBuf, pool);
        psFree(reqParts->subjectDNBuf.buf, pool);
        psFree(reqParts->reqAlgIdBuf.buf, pool);
        psFree(reqParts, pool);
        psFree(reqInfoBuf, pool);
        return PS_MEM_FAIL;
    }

    /* Will be doing two asnPrependSequence calls */
    reqInfoBuf->end = reqInfoBuf->start += (ASN_SEQUENCE_OH * 2);

    Memcpy(reqInfoBuf->end, reqParts->versionBuf, versionLen);
    reqInfoBuf->end += versionLen;
    psFree(reqParts->versionBuf, pool);

    Memcpy(reqInfoBuf->end, reqParts->subjectDNBuf.start, subjectDNLen);
    reqInfoBuf->end += subjectDNLen;
    psFree(reqParts->subjectDNBuf.buf, pool);

    Memcpy(reqInfoBuf->end, reqParts->pubKeyBuf.start, pubKeyLen);
    reqInfoBuf->end += pubKeyLen;
    psFree(reqParts->pubKeyBuf.buf, pool);

    /* Any attributes? */
    *reqInfoBuf->end = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED;
    reqInfoBuf->end++;
    reqInfoBuf->end += asnHelpWriteLength(reqInfoBuf->end, attribLen);

    if (attribLen  > 0)
    {
        Memcpy(reqInfoBuf->end, reqParts->reqExt.start, attribLen);
        reqInfoBuf->end += attribLen;
        psFree(reqParts->reqExt.buf, pool);
    }

    asnPrependSequence(reqInfoBuf);

    if (psWriteSignature(pool, reqInfoBuf, reqParts->reqAlgIdBuf.start,
            reqAlgIdLen, key, reqConfig->certAlg) < 0)
    {
        psFree(reqParts->reqAlgIdBuf.buf, pool);
        psFree(reqParts, pool);
        psFree(reqInfoBuf->buf, pool);
        psFree(reqInfoBuf, pool);
        return -1;
    }

    /* Clean up */
    psFree(reqParts->reqAlgIdBuf.buf, pool);
    psFree(reqParts, pool);

    /* Malloc callers buf and copy */
    *requestMemLen = (int32) (reqInfoBuf->end - reqInfoBuf->start);
    if ((*requestMem = psMalloc(pool, *requestMemLen)) == NULL)
    {
        psFree(reqInfoBuf->buf, pool);
        psFree(reqInfoBuf, pool);
        return PS_MEM_FAIL;
    }

    Memcpy(*requestMem, reqInfoBuf->start, *requestMemLen);

    psFree(reqInfoBuf->buf, pool);
    psFree(reqInfoBuf, pool);

    return 0;
}

#endif /* USE_CERT_GEN */

/******************************************************************************/
