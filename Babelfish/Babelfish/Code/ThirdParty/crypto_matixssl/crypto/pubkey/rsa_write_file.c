/**
 *      @file    rsa_write_file.c
 *
 *
 *      Functions for writing RSA keys to file.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "osdep_stdio.h"
#include "../cryptoImpl.h"

# ifdef USE_RSA
#  ifdef MATRIX_USE_FILE_SYSTEM
#   ifdef USE_CERT_GEN
/******************************************************************************/
/*
    Write out a private key file given the RSA key.  Optionally password
    protect it.
 */
int32_t psRsaWritePrivKeyFile(psPool_t *pool, const psRsaKey_t *key,
    const char *fileName, const char *password, uint8_t pemFlag)
{
    FILE *outFile;
    psBuf_t keyBuf;
    char *hexCipherIV;
    unsigned char *keyMem;
    psSize_t keyMemLen, hexCipherIVLen;

# if defined(USE_PKCS5) && defined(USE_PBKDF1)
    psDes3_t ctx;
    psSize_t padLen;
    unsigned char passKey[DES3_KEYLEN];
    unsigned char cipherIV[DES3_IVLEN];
# endif /* USE_PKCS5 && USE_PBKDF1 */

    if (psRsaWritePrivKeyMem(pool, key, &keyMem, &keyMemLen) < 0)
    {
        _psTrace("Unable to generate PEM encoded private key\n");
        if (keyMem)
        {
            psFree(keyMem, pool);
        }
        return -1;
    }

    if (pemFlag)
    {
/*
        There may be some additional padding for the keyMem so we allocate a new
        buffer type here and work with that.
 */
        keyBuf.size = keyMemLen + DES3_IVLEN;
        keyBuf.buf = keyBuf.start = keyBuf.end = psMalloc(pool, keyBuf.size);
        if (keyBuf.buf == NULL)
        {
            psFree(keyMem, pool);
            return PS_MEM_FAIL;
        }
        Memcpy(keyBuf.end, keyMem, keyMemLen);
        keyBuf.end += keyMemLen;
        psFree(keyMem, pool);
/*
        Have the binary file contents.  Check if we need to password protect now
 */
        hexCipherIV = NULL;
        hexCipherIVLen = 0;
        if (password)
        {
# if defined(USE_PKCS5) && defined(USE_PBKDF1)
            psGetEntropy(cipherIV, DES3_IVLEN, NULL);
            hexCipherIVLen = DES3_IVLEN * 2;
            if ((hexCipherIV = psMalloc(pool, hexCipherIVLen + 1)) == NULL)
            {
                psFree(keyBuf.buf, pool);
                return PS_MEM_FAIL;
            }
            psBinaryToHex(cipherIV, DES3_IVLEN, hexCipherIV);

            if (psPkcs5Pbkdf1((unsigned char *) password, (int32) Strlen(password),
                    cipherIV, 1, (unsigned char *) passKey) < 0)
            {
                _psTrace("psPkcs5Pbkdf1 failed\n");
                psFree(keyBuf.buf, pool);
                psFree(hexCipherIV, pool);
                return PS_FAILURE;
            }
            /* Need to pad the input to be multiple of blocklen */
            padLen = psPadLenPwr2(keyMemLen, DES3_IVLEN);
            keyBuf.end += blockCipherWritePad(keyBuf.end,
                (unsigned char) padLen);
            /* 3DES encryption */
            psDes3Init(&ctx, cipherIV, passKey);
            psDes3Encrypt(&ctx, keyBuf.start, keyBuf.start,
                (int32) (keyBuf.end - keyBuf.start));
# else
            _psTrace("Can't encrypt private key file\n");
#  ifndef USE_PKCS5
            _psTrace("PKCS5 is not enabled\n");
#  endif    /* USE_PKCS5 */
#  ifndef USE_PBKDF1
            _psTrace("USE_PBKDF1 is not enabled\n");
#  endif /* USE_PBKDF1 */
# endif  /* USE_PKCS5 && USE_PBKDF1 */
        }

        if (psBase64EncodeAndWrite(pool, fileName, keyBuf.start,
                (int32) (keyBuf.end - keyBuf.start), RSAKEY_FILE_TYPE,
                hexCipherIV, hexCipherIVLen) < 0)
        {
            _psTrace("Unable to encode and write private key file\n");
            if (hexCipherIV)
            {
                psFree(hexCipherIV, pool);
            }
            psFree(keyBuf.buf, pool);
            return -1;
        }
        if (hexCipherIV)
        {
            psFree(hexCipherIV, pool);
        }
        psFree(keyBuf.buf, pool);

    }
    else
    {
        /* DER format is ready to go */
        if ((outFile = Fopen(fileName, "w")) == NULL)
        {
            _psTrace("Unable to open cert file for writing.\n");
            psFree(keyMem, pool);
            return -1;
        }
        if (Fwrite(keyMem, sizeof(char), keyMemLen, outFile) != keyMemLen)
        {
            _psTrace("Error writing to file.\n");
            psFree(keyMem, pool);
            Fclose(outFile);
            return -1;
        }
        psFree(keyMem, pool);
        Fclose(outFile);
    }
    return 0;
}

#   endif /* USE_CERT_GEN */
#  endif /* USE_RSA */
# endif /* MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/
