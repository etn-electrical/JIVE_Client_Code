/**
 *      @file    rsa_keygen.c
 *
 *
 *      RSA key generation.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

#ifdef USE_MATRIX_RSA
# ifdef USE_CERT_GEN

/******************************************************************************/

/* Primality generation flags */
#  define PSTM_PRIME_BBS      0x0001 /* BBS style prime */
#  define PSTM_PRIME_SAFE     0x0002 /* Safe prime (p-1)/2 == prime */
#  define PSTM_PRIME_2MSB_OFF 0x0004 /* force 2nd MSB to 0 */
#  define PSTM_PRIME_2MSB_ON  0x0008 /* force first two MSB to 1 */

/* MIN_RSA_BITS already defined in cryptoConfig.h */
#  define MAX_RSA_BITS    4096

#  define PRIME_SANITY    1000000

/**
    Makes a truly random prime of a given size (bits).
 *
 * Flags are as follows:
 *
 *   PSTM_PRIME_BBS      - make prime congruent to 3 mod 4
 *   PSTM_PRIME_SAFE     - make sure (p-1)/2 is prime as well
 *   PSTM_PRIME_2MSB_OFF - make the 2nd highest bit zero
 *   PSTM_PRIME_2MSB_ON  - make the 2nd highest bit one
 *
 */
static int32 prime_random_ex(psPool_t *pool, pstm_int *a, int32 size,
    int32 flags)
{
    unsigned char *tmp, maskAND, maskOR_msb, maskOR_lsb;
    int32_t res, err, bsize, sanity;

/*      int32_t         maskOR_msb_offset; */

    /* sanity check the input */
    if (size <= 1)
    {
        return PS_ARG_FAIL;
    }

    /* TFM_PRIME_SAFE implies TFM_PRIME_BBS */
    if (flags & PSTM_PRIME_SAFE)
    {
        flags |= PSTM_PRIME_BBS;
    }

    /* calc the byte size */
    bsize = (size >> 3) + (size & 7 ? 1 : 0);

    /* we need a buffer of bsize bytes */
    tmp = psMalloc(pool, bsize);
    if (tmp == NULL)
    {
        return PS_MEM_FAIL;
    }

    /* calc the maskAND value for the MSbyte*/
    maskAND = 0xFF >> (8 - (size & 7));

    /* calc the maskOR_msb */
    maskOR_msb        = 0;
/*      maskOR_msb_offset = (size - 2) >> 3; */
    if (flags & PSTM_PRIME_2MSB_ON)
    {
/*
        Setting top two bytes to guarantee a modulus size that was requested
 */
        maskOR_msb     |= 3 << ((size - 2) & 7);
    }
    else if (flags & PSTM_PRIME_2MSB_OFF)
    {
        maskAND        &= ~(1 << ((size - 2) & 7));
    }

    /* get the maskOR_lsb */
    maskOR_lsb         = 1;
    if (flags & PSTM_PRIME_BBS)
    {
        maskOR_lsb     |= 3;
    }

    for (sanity = 0; sanity < PRIME_SANITY; sanity++)
    {
        /* read the bytes */
        if (psGetEntropy(tmp, bsize, NULL) != bsize)
        {
            err = PS_PLATFORM_FAIL;
            goto error;
        }
        tmp[0]          |= maskOR_msb;
        tmp[bsize - 1]    |= maskOR_lsb;

        /* read it in */
        if ((err = pstm_read_unsigned_bin(a, tmp, bsize)) != PSTM_OKAY)
        {
            goto error;
        }

        /* is it prime? */
        if ((err = pstm_isprime(pool, a, &res)) != PSTM_OKAY)
        {
            goto error;
        }

        if (res == PSTM_NO)
        {
            continue;
        }

        if (flags & PSTM_PRIME_SAFE)
        {
            /* see if (a-1)/2 is prime */
            if ((err = pstm_sub_d(pool, a, 1, a)) != PSTM_OKAY)
            {
                goto error;
            }
            if ((err = pstm_div_2(a, a)) != PSTM_OKAY)
            {
                goto error;
            }

            /* is it prime? */
            if ((err = pstm_isprime(pool, a, &res)) != PSTM_OKAY)
            {
                goto error;
            }
            if (res == PSTM_NO)
            {
                continue;
            }
        }
        break;
    }

    if (sanity >= PRIME_SANITY)
    {
        psAssert(sanity < PRIME_SANITY);
        goto error;
    }

    if (flags & PSTM_PRIME_SAFE)
    {
        /* restore a to the original value */
        if ((err = pstm_mul_2(a, a)) != PSTM_OKAY)
        {
            goto error;
        }
        if ((err = pstm_add_d(pool, a, 1, a)) != PSTM_OKAY)
        {
            goto error;
        }
    }

    err = PSTM_OKAY;
error:
    psFree(tmp, pool);
    return err;
}

static int32_t rand_prime(psPool_t *pool, pstm_int *N, long len)
{
    /* allow sizes between 2 and 256 bytes for a prime size */
    if (len < 16 || len > 4096)
    {
        return PS_ARG_FAIL;
    }

    return prime_random_ex(pool, N, len, PSTM_PRIME_2MSB_ON);
}

/******************************************************************************/
/**
   Create an RSA private/public key.
   @param[in] size     The size of the modulus (key size) desired (bits)
   @param[in] e        The "e" value (public key).  e==65537 is a good choice
   @param[out] key     Destination of a newly allocated private key pair
   @return PS_SUCCESS if successful, upon error all allocated ram is freed
 */
int32_t psRsaMakeKey(psPool_t *pool, psSize_t size, uint32_t e, psRsaKey_t **ptrKey)
{
    psRsaKey_t *key = NULL;
    pstm_int p, q, tmp1, tmp2, tmp3;
    int32 err;

    err = PS_FAILURE;
    *ptrKey = NULL;
/*
    Bit input
 */
    size = size / 8;

    if ((size < (MIN_RSA_BITS / 8)) || (size > (MAX_RSA_BITS / 8)))
    {
        _psTraceInt("Invalid key size: %d bytes\n", size);
        return err;
    }

    if ((e < 3) || ((e & 1) == 0))
    {
        _psTraceInt("Invalid exponent value %d.  65537 is recommended\n", e);
        return err;
    }

#  ifdef USE_MATRIX_MEMORY_MANAGEMENT
/*
    Known used cache sizes
 */
    psAddPoolCache(pool, ((size / sizeof(pstm_word) + 1) * sizeof(pstm_digit)));
    psAddPoolCache(pool, 2 * ((size / sizeof(pstm_word) + 1) * sizeof(pstm_digit)));
    psAddPoolCache(pool, 128);
    psAddPoolCache(pool, 256);
#  endif /* USE_MATRIX_MEMORY_MANAGEMENT */

    if ((err = pstm_init_size(pool, &p, size / sizeof(pstm_word) + 1)) !=
        PSTM_OKAY)
    {
        return err;
    }
    if ((err = pstm_init_size(pool, &q, size / sizeof(pstm_word) + 1)) !=
        PSTM_OKAY)
    {
        goto LBL_P;
    }
    if ((err = pstm_init_size(pool, &tmp1, size / sizeof(pstm_word) + 1)) !=
        PSTM_OKAY)
    {
        goto LBL_Q;
    }
    if ((err = pstm_init_size(pool, &tmp2, size / sizeof(pstm_word) + 1)) !=
        PSTM_OKAY)
    {
        goto LBL_TMP1;
    }
    if ((err = pstm_init_size(pool, &tmp3, sizeof(pstm_digit))) != PSTM_OKAY)
    {
        goto LBL_TMP2;
    }

    /* make primes p and q (optimization provided by Wayne Scott) */
    pstm_set(&tmp3, e);

    /* make prime "p" */
    do
    {
        if ((err = rand_prime(pool, &p, size * 4)) != PSTM_OKAY)
        {
            goto LBL_CLR;
        }
        if ((err = pstm_sub_d(pool, &p, 1, &tmp1)) != PSTM_OKAY)
        {
            goto LBL_CLR;
        }
        if ((err = pstm_gcd(pool, &tmp1, &tmp3, &tmp2)) != PSTM_OKAY)
        {
            goto LBL_CLR;
        }
    }
    while (pstm_cmp_d(&tmp2, 1) != 0);

    /* make prime "q" */
    do
    {
        if ((err = rand_prime(pool, &q, size * 4)) != PSTM_OKAY)
        {
            goto LBL_CLR;
        }
        if ((err = pstm_sub_d(pool, &q, 1, &tmp1)) != PSTM_OKAY)
        {
            goto LBL_CLR;
        }
        if ((err = pstm_gcd(pool, &tmp1, &tmp3, &tmp2)) != PSTM_OKAY)
        {
            goto LBL_CLR;
        }
    }
    while (pstm_cmp_d(&tmp2, 1) != 0);

    /* tmp1 = lcm(p-1, q-1) */
    if ((err = pstm_sub_d(pool, &p, 1, &tmp2)) != PSTM_OKAY)
    {
        goto LBL_CLR;
    }
    if ((err = pstm_lcm(pool, &tmp1, &tmp2, &tmp1)) != PSTM_OKAY)
    {
        goto LBL_CLR;
    }

    /* make key */
    key = psMalloc(pool, sizeof(psRsaKey_t));
    if (key == NULL)
    {
        err = PS_MEM_FAIL;
        goto LBL_CLR;
    }
    Memset(key, 0x0, sizeof(psRsaKey_t));
    err = PS_MEM_FAIL;
    if (pstm_init_copy(pool, &key->e, &tmp3, 0) != PSTM_OKAY)
    {
        goto error;
    }
    if (pstm_init_size(pool, &key->d, tmp1.alloc + 1) != PSTM_OKAY)
    {
        goto error;
    }
    if (pstm_init_size(pool, &key->N, p.alloc + q.alloc) != PSTM_OKAY)
    {
        goto error;
    }
    if (pstm_init_size(pool, &key->dQ, q.alloc) != PSTM_OKAY)
    {
        goto error;
    }
    if (pstm_init_size(pool, &key->dP, p.alloc) != PSTM_OKAY)
    {
        goto error;
    }
    if (pstm_init_size(pool, &key->qP, p.alloc) != PSTM_OKAY)
    {
        goto error;
    }
    if (pstm_init_size(pool, &key->p, p.alloc) != PSTM_OKAY)
    {
        goto error;
    }
    if (pstm_init_size(pool, &key->q, q.alloc) != PSTM_OKAY)
    {
        goto error;
    }

    /* pstm_set(&key->e, e); */
    if ((err = pstm_invmod(pool, &key->e, &tmp1, &key->d)) != PSTM_OKAY)
    {
        goto error;
    }
    if ((err = pstm_mul_comba(pool, &p, &q, &key->N, NULL, 0)) != PSTM_OKAY)
    {
        goto error;
    }

    /* optimize for CRT now */
    /* find d mod q-1 and d mod p-1 */
    if ((err = pstm_sub_d(pool, &p, 1, &tmp1)) != PSTM_OKAY)
    {
        goto error;
    }
    if ((err = pstm_sub_d(pool, &q, 1, &tmp2)) != PSTM_OKAY)
    {
        goto error;
    }
    if ((err = pstm_mod(pool, &key->d, &tmp1, &key->dP)) != PSTM_OKAY)
    {
        goto error;
    }
    if ((err = pstm_mod(pool, &key->d, &tmp2, &key->dQ)) != PSTM_OKAY)
    {
        goto error;
    }
    if ((err = pstm_invmod(pool, &q, &p, &key->qP)) != PSTM_OKAY)
    {
        goto error;
    }

    if ((err = pstm_copy(&p, &key->p)) != PSTM_OKAY)
    {
        goto error;
    }
    if ((err = pstm_copy(&q, &key->q)) != PSTM_OKAY)
    {
        goto error;
    }

    key->optimized = 1;
    key->size = pstm_unsigned_bin_size(&key->N);

    /* return ok and free temps */
    err       = PSTM_OKAY;
    goto LBL_CLR;

error:
    pstm_clear_multi(&key->d, &key->e, &key->N, &key->dQ, &key->dP,
        &key->qP, &key->p, &key->q);
    psFree(key, pool);
    key = NULL;

LBL_CLR:    pstm_clear(&tmp3);
LBL_TMP2:   pstm_clear(&tmp2);
LBL_TMP1:   pstm_clear(&tmp1);
LBL_Q:      pstm_clear(&q);
LBL_P:      pstm_clear(&p);
    *ptrKey = key;
    return err;
}
# endif /* USE_CERT_GEN */
#endif  /* USE_MATRIX_RSA */

/******************************************************************************/

