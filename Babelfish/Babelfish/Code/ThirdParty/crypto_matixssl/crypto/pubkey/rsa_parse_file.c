/**
 *      @file    rsa_parse_file.c
 *
 *
 *      Functions for parsing RSA keys from file.
 */
/*
 *      Copyright (c) 2013-2018 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

#  ifdef MATRIX_USE_FILE_SYSTEM

#   ifdef USE_RSA
int32_t psPkcs1ParsePubFile(psPool_t *pool, const char *fileName,
        psRsaKey_t *key)
{
#   ifdef USE_PEM_DECODE
    unsigned char *DERout;
    unsigned char sha1KeyHash[SHA1_HASH_SIZE];
    const unsigned char *p, *end;
    int32_t rc, oi;
    psSizeL_t DERlen;
    const unsigned char *publicKey;

    rc = psPemFileToDer(pool,
            fileName, NULL,
            PEM_TYPE_KEY, &DERout, &DERlen);
    if (rc < PS_SUCCESS)
    {
        return rc;
    }
    p = DERout;
    end = p + DERlen;

    rc = psParseSubjectPublicKeyInfo(pool,
            DERout,
            DERlen,
            &oi,
            NULL, NULL,
            &publicKey);
    if (rc != PS_SUCCESS)
    {
        psTraceCrypto("Couldn't parse PKCS#1 RSA public key file\n");
        goto pubKeyFail;
    }

    if (oi != OID_RSA_KEY_ALG)
    {
        psTraceCrypto("psPkcs1ParsePubFile: not an RSA key\n");
        goto pubKeyFail;
    }

    rc = psRsaParseAsnPubKey(pool,
            &publicKey,
            (int32) (end - publicKey),
            key,
            sha1KeyHash);
    if (rc < 0)
    {
        psTraceCrypto("Couldn't parse PKCS#1 RSA public key file\n");
        goto pubKeyFail;
    }

    psFree(DERout, pool);
    return PS_SUCCESS;

pubKeyFail:
    psFree(DERout, pool);
    return PS_PARSE_FAIL;
#   else
    return PS_UNSUPPORTED_FAIL;
#   endif
}

#  ifdef USE_PRIVATE_KEY_PARSING

/******************************************************************************/
/**
    Parse a PEM format private key file.

    @pre File must be a PEM format RSA keys.
    @return < 0 on error
 */
int32_t psPkcs1ParsePrivFile(psPool_t *pool, const char *fileName,
    const char *password, psRsaKey_t *key)
{
    unsigned char *DERout;
    int32_t rc;
    psSize_t DERlen;

#   ifdef USE_PKCS8
    psPubKey_t pubkey;
#   endif

    rc = psPkcs1DecodePrivFile(pool, fileName, password, &DERout, &DERlen);
    if (rc < PS_SUCCESS)
    {
        return rc;
    }

    rc = psRsaParsePkcs1PrivKey(pool, DERout, DERlen, key);
    if (rc < 0)
    {
#   ifdef USE_PKCS8
        /* This logic works for processing PKCS#8 files because the above file
            and bin decodes will always leave the unprocessed buffer intact and
            the password protection is done in the internal ASN.1 encoding */
        rc = psPkcs8ParsePrivBin(pool,
                DERout,
                DERlen,
                (char *) password,
                &pubkey);
        if (rc < 0)
        {
            psFree(DERout, pool);
            return rc;
        }
        rc = psRsaCopyKey(key, &pubkey.key.rsa);
        psClearPubKey(&pubkey);
#   else
        psFree(DERout, pool);
        return rc;
#   endif
    }

    psFree(DERout, pool);
    return rc;
}
#  endif /* USE_RSA */

#  endif  /* USE_PRIVATE_KEY_PARSING */
# endif /* MATRIX_USE_FILE_SYSTEM */
