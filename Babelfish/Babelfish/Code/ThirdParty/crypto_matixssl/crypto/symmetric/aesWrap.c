/**
 *      @file    aesWrap.c
 *
 */
/*
 *      Copyright (c) 2014-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

#ifdef USE_MATRIX_AES_WRAP

/******************************************************************************/
/*
    Caller can pass in pt to overwrite ct
 */
int32_t psAesUnwrap(const unsigned char *kek, psSize_t kekLen,
    const unsigned char *ct, uint32_t ctLen,
    unsigned char *pt, uint32_t *ptLen)
{
    unsigned char A[8], B[16];
    unsigned char *R;
    uint32_t ptBlocks;
    int i, j;
    psAesKey_t ctx;

    if (kekLen != 16 && kekLen != 24 && kekLen != 32)
    {
        return PS_UNSUPPORTED_FAIL; /* Should be an AES_128 variant */
    }
    *ptLen = ctLen - 8;
    ptBlocks = *ptLen / 8;  /* 64-bit blocks */

    /* Init */
    Memcpy(A, ct, 8);
    R = pt;
    Memcpy(R, ct + 8, ctLen - 8);

    /* Compute */
    psAesInitBlockKey(&ctx, kek, kekLen, PS_AES_DECRYPT);
    for (j = 5; j >= 0; j--)
    {
        R = pt + (ptBlocks - 1) * 8;
        for (i = ptBlocks; i >= 1; i--)
        {
            Memcpy(B, A, 8);
            B[7] ^= ptBlocks * j + i;
            Memcpy(B + 8, R, 8);
            psAesDecryptBlock(&ctx, B, B);
            Memcpy(A, B, 8);
            Memcpy(R, B + 8, 8);
            R -= 8;
        }
    }
    psAesClearBlockKey(&ctx);
    memset_s(B, sizeof(B), 0x0, sizeof(B));

    /* Confirm */
    for (i = 0; i < 8; i++)
    {
        if (A[i] != 0xa6)
        {
            memset_s(A, sizeof(A), 0x0, sizeof(A));
            return -1;
        }
    }
    memset_s(A, sizeof(A), 0x0, sizeof(A));

    return PS_SUCCESS;
}

/******************************************************************************/

int32_t psAesWrap(const unsigned char *kek, psSize_t kekLen,
    const unsigned char *pt, uint32_t ptLen,
    unsigned char *ct, uint32_t *ctLen)
{
    unsigned char B[16];
    unsigned char *R, *A;
    uint32_t ptBlocks, i, j;
    psAesKey_t ctx;

    if (kekLen != 16 && kekLen != 24 && kekLen != 32)
    {
        return PS_UNSUPPORTED_FAIL; /* Should be an AES_128 variant */
    }

    ptBlocks = ptLen / 8;

    /* Init */
    A = ct;
    R = ct + 8;
    Memset(A, 0xA6, 8);
    Memcpy(R, pt, ptLen);

    /* Compute */
    psAesInitBlockKey(&ctx, kek, kekLen, PS_AES_ENCRYPT);
    for (j = 0; j <= 5; j++)
    {
        R = ct + 8;
        for (i = 1; i <= ptBlocks; i++)
        {
            Memcpy(B, A, 8);
            Memcpy(B + 8, R, 8);
            psAesEncryptBlock(&ctx, B, B);
            Memcpy(A, B, 8);
            A[7] ^= ptBlocks * j + i;
            Memcpy(R, B + 8, 8);
            R += 8;
        }
    }
    *ctLen = ptLen + 8;
    psAesClearBlockKey(&ctx);
    memset_s(B, sizeof(B), 0x0, sizeof(B));
    return PS_SUCCESS;
}

#endif /* USE_MATRIX_AES_WRAP */

/******************************************************************************/

