/**
 *      @file    aesCTR.c
 *
 *
 *      AES CTR block cipher implementation.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "../cryptoImpl.h"

#ifdef USE_MATRIX_AES_CTR

void psAesClearCTR(psAesCtr_t *ctx)
{
    /* Only need to clear block if it's implemented externally, Matrix block
        is part of CipherContext and will be cleared below */
# ifndef USE_MATRIX_AES_BLOCK
    psAesClearBlockKey(&ctx->key);
# endif
    memset_s(ctx, sizeof(psAesCtr_t), 0x0, sizeof(psAesCtr_t));
}
/******************************************************************************/
/*
    Initialize an AES CTR context
        ctx         The CTR state to initialize
        IV          The initial vector
        key         The secret key
        keylen      The length of the secret key (octets)
        ctrMode         CTR_COUNTER_LITTLE_ENDIAN or CTR_COUNTER_BIG_ENDIAN
                    and/or LTC_CTR_RFC3686
 */
int32_t psAesInitExCTR(psAesCtr_t *ctx, const unsigned char IV[AES_IVLEN],
    const unsigned char key[AES_MAXKEYLEN], uint8_t keylen,
    uint32_t ctrMode, uint32_t flags)
{
    int32 x, err;

# ifdef AES_ASSERT
    if (IV == NULL || key == NULL || ctx == NULL)
    {
        psError("psAesInit arg fail\n");
        return PS_ARG_FAIL;
    }
# endif

    /* ctrlen == counter width */
    ctx->ctrlen = (ctrMode & 0xFF) ? (ctrMode & 0xFF) : AES_BLOCKLEN;
    if (ctx->ctrlen > AES_BLOCKLEN)
    {
        return PS_ARG_FAIL;
    }

    if ((ctrMode & 0x1000) == CTR_COUNTER_BIG_ENDIAN)
    {
        ctx->ctrlen = AES_BLOCKLEN - ctx->ctrlen;
    }

    /* setup cipher */
    if ((err = psAesInitBlockKey(&ctx->key, key, keylen, flags))
        != PS_SUCCESS)
    {
        return err;
    }

    /* copy CTR */
    ctx->padlen   = 0;
    ctx->mode     = ctrMode & 0x1000;
    for (x = 0; x < AES_BLOCKLEN; x++)
    {
        ctx->ctr[x] = IV[x];
    }

    if (ctrMode & LTC_CTR_RFC3686)
    {
        /* increment the IV as per RFC 3686 */
        if (ctx->mode == CTR_COUNTER_LITTLE_ENDIAN)
        {
            /* little-endian */
            for (x = 0; x < ctx->ctrlen; x++)
            {
                ctx->ctr[x] = (ctx->ctr[x] +
                               (unsigned char) 1) & (unsigned char) 255;
                if (ctx->ctr[x] != (unsigned char) 0)
                {
                    break;
                }
            }
        }
        else
        {
            /* big-endian */
            for (x = (AES_BLOCKLEN - 1); x >= ctx->ctrlen; x--)
            {
                ctx->ctr[x] = (ctx->ctr[x] +
                               (unsigned char) 1) & (unsigned char) 255;
                if (ctx->ctr[x] != (unsigned char) 0)
                {
                    break;
                }
            }
        }
    }

    psAesEncryptBlock(&ctx->key, ctx->ctr, ctx->pad);
    return PS_SUCCESS;
}

/******************************************************************************/
/*
    The default Init routine will use BIG_ENDIAN counting
 */
int32_t psAesInitCTR(psAesCtr_t *ctx, const unsigned char IV[AES_IVLEN],
    const unsigned char key[AES_MAXKEYLEN], uint8_t keylen,
    uint32_t flags)
{
    return psAesInitExCTR(ctx, IV, key, keylen, CTR_COUNTER_BIG_ENDIAN, flags);
}

/******************************************************************************/
/*
   AES CTR encrypt
    pt     Plaintext
    ct     [out] Ciphertext
    len    Length of plaintext (octets)
 */
void psAesEncryptCTR(psAesCtr_t *ctx, const unsigned char *pt,
    unsigned char *ct, uint32_t len)
{
    int32 x;

# ifdef AES_ASSERT
    if (pt == NULL || ct == NULL || ctx == NULL)
    {
        psError("Bad parameters to psAesEncryptCTR\n");
        return;
    }
    if (ctx->padlen < 0 || ctx->padlen > (int32) sizeof(ctx->pad))
    {
        return;
    }
# endif

    while (len)
    {
        /* is the pad empty? */
        if (ctx->padlen == AES_BLOCKLEN)
        {
            /* increment counter */
            if (ctx->mode == CTR_COUNTER_LITTLE_ENDIAN)
            {
                /* little-endian */
                for (x = 0; x < ctx->ctrlen; x++)
                {
                    ctx->ctr[x] = (ctx->ctr[x] +
                                   (unsigned char) 1) & (unsigned char) 255;
                    if (ctx->ctr[x] != (unsigned char) 0)
                    {
                        break;
                    }
                }
            }
            else
            {
                /* big-endian */
                for (x = (AES_BLOCKLEN - 1); x >= ctx->ctrlen; x--)
                {
                    ctx->ctr[x] = (ctx->ctr[x] +
                                   (unsigned char) 1) & (unsigned char) 255;
                    if (ctx->ctr[x] != (unsigned char) 0)
                    {
                        break;
                    }
                }
            }

            /* encrypt it */
            psAesEncryptBlock(&ctx->key, ctx->ctr, ctx->pad);
            ctx->padlen = 0;
        }
        *ct++ = *pt++ ^ ctx->pad[ctx->padlen++];
        --len;
    }
    return;
}

/******************************************************************************/
/*
    Just an encrypt
 */
void psAesDecryptCTR(psAesCtr_t *ctx, const unsigned char *ct,
    unsigned char *pt, uint32_t len)
{
    return psAesEncryptCTR(ctx, ct, pt, len);
}
#endif /* USE_AES_CTR */

/******************************************************************************/

