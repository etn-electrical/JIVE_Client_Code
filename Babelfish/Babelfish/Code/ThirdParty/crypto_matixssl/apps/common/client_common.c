/**
 *      @file    client_common.c
 *
 *
 *      MatrixSSL client common code.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "client_common.h"
#include "sockets.h"
# if defined(USE_EXT_CERTIFICATE_VERIFY_SIGNING) && defined(USE_EXT_EXAMPLE_MODULE)
/*
   Enable external certificate verify signing for the next connection?

   We assume that the private key is contained within the external
   module, and that we have no direct access.

   When loading keys, we pass a NULL pointer to MatrixSSL, instead of
   the actual private key.

   To perform the signature operation, we shall call an example
   external module via the psExt API (defined in matrixssl/psExt.h).

   @note Can be turned on/off with the command line arg '-e 0' or '-e 1'.
 */
int g_enable_ext_cv_sig_op = 1; /* On by default. */
# else
int g_enable_ext_cv_sig_op = 0;
# endif /* USE_EXT_CERTIFICATE_VERIFY_SIGNING && USE_EXT_EXAMPLE_MODULE */

/* Default RSA key length */
int g_key_len = 2048;

/* Append data of size datasize to buf of bufsize
   Bufused must be the number of bytes used of buf and is updated at return
   Returns 0 if failed, 1 otherwise.
 */
int appendCACert(unsigned char *buf, const size_t bufsize, size_t *bufused,
                 const unsigned char *data, const size_t datasize)
{
    if (datasize > bufsize - *bufused ) {
        return 0; /* Does not fit into the buffer */
    }

    Memcpy(buf + *bufused, data, datasize);
    *bufused += datasize;
    return 1;
}

/* Append str to strbuf, adding separator between the strings
   Returns 0 if failed, 1 otherwise.
 */
int appendCAFilename(char *strbuf, const size_t strbufsize, const char *str)
{
    static const char *sep = ";";
    const size_t strbuflen = Strlen(strbuf);
    const size_t strseplen = (strbuflen == 0 ? 0 : Strlen(sep));
    const size_t bufUnused = strbufsize - strbuflen - 1;
    const size_t len = Strlen(str);

    if (len == 0) {
        return 1;
    }

    if (len + strseplen > bufUnused) {
        return 0; /* Does not fit into the buffer */
    }

    if (strseplen) {
        strncat(strbuf, sep, bufUnused - len);
    }

    strncat(strbuf, str, bufUnused - strseplen);
    return 1;
}
