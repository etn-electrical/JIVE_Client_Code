/**
 *      @file    certgen.c
 *
 *
 *      Command line utility for X.509 certificate file generation.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "crypto/cryptoApi.h"
/* Currently this example uses _psTrace for tracing, so osdep.h is needed: */
#include "core/osdep.h"

#if defined(USE_CERT_GEN) && defined(MATRIX_USE_FILE_SYSTEM)

/******************************************************************************/

static void certgenUsage(void);
static int32 getOptions(psPool_t *pool, unsigned char **confBin, int32 *confLen,
                        int32 caIssued);

/* fgets wrapper with basic error handling */
static void xfgets(char *s, int size, FILE *stream)
{
    s = fgets(s, size, stream);
    /* Exit if write failed. */
    if (s == NULL)
    {
        perror("certgen");
        exit(1);
    }
}
int fgetc(FILE *stream);

/******************************************************************************/
/*
 */
#  define REQUIRE_INTERACTION

int32 main(int32 argc, char **argv)
{
    psPool_t *pool;
    char *certfile, *certconf, *privKey, *privKeyPass;
    char *CAcert, *CAprivKey, *CAprivKeyPass, *reqFile;
    unsigned char *confBin, *reqBin;
    x509DNattributes_t *subjectDN;

# ifdef REQUIRE_INTERACTION
    char otfCertFile[80], otfPrivKey[80], otfCAcert[80], otfCAPriv[80];
    char otfCAPrivPass[80], otfPrivKeyPass[80], yorn[8];
    int32 tryagain, len;
# endif
    psPubKey_t privKeyMem, *reqPubKey;
    psCertConfig_t certConfig;
    x509v3extensions_t *reqExt;
    x509GeneralName_t *gn;
    psX509Cert_t *caX509;
    int32 selfsign, reqLen;
    psSizeL_t confBinLen;
# ifdef USE_FULL_CERT_PARSE
    char *oneline_subject_dn;
    size_t oneline_subject_dn_len = 0;
# else
    x509OrgUnit_t *orgUnit;
# endif

/*
    command line parse
 */
    reqPubKey = NULL;
    reqExt = NULL;
    certfile = certconf = privKey = privKeyPass = NULL;
    CAcert = CAprivKey = CAprivKeyPass = reqFile = NULL;
    confBin = NULL;
/*
    Assume self-sign until a request file is found (-req)
 */
    selfsign = 1;

    argv++;  argc--; /* skip exe name */

    while (*argv)
    {
        if (Strcmp(*argv, "-out") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                certfile = *argv;
            }
            else
            {
                certgenUsage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-certconf") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                certconf = *argv;
            }
            else
            {
                certgenUsage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-key") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                if (reqFile != NULL)
                {
                    certgenUsage();
                    return EXIT_FAILURE;
                }
                privKey = *argv;
            }
            else
            {
                certgenUsage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-pass") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                privKeyPass = *argv;
            }
            else
            {
                certgenUsage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-CAcert") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                CAcert = *argv;
            }
            else
            {
                certgenUsage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-CAkey") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                CAprivKey = *argv;
            }
            else
            {
                certgenUsage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-CApass") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                CAprivKeyPass = *argv;
            }
            else
            {
                certgenUsage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-req") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                if (privKey != NULL)
                {
                    certgenUsage();
                    return EXIT_FAILURE;
                }
                selfsign = 0;
                reqFile = *argv;
            }
            else
            {
                certgenUsage();
                return EXIT_FAILURE;
            }
        }
        else
        {
            certgenUsage();
            return EXIT_FAILURE;
        }
        argv++; argc--;
    }

    if (selfsign)
    {
        _psTrace("*** Self-signed CA certificate ***\n");
    }
    else
    {
        _psTrace("*** Certificate Authority issued certificate ***\n");
    }

/*
    Load the library
 */
    if (psCryptoOpen(PSCRYPTO_CONFIG) < PS_SUCCESS)
    {
        _psTrace("Failed to initialize library:  psCryptoOpen failed\n");
        return EXIT_FAILURE;
    }

# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    if ((pool = psOpenPool("certgen", 1024 * 64, 0, NULL, NULL)) == NULL)
    {
        _psTrace("Failed to open memory pool\n");
        psCryptoClose();
        return EXIT_FAILURE;
    }
# else
    pool = NULL;
# endif /* USE_MATRIX_MEMORY_MANAGEMENT */

/*
    Get information that wasn't provided through the command line
 */
# ifdef REQUIRE_INTERACTION
    if (certfile == NULL)
    {
        tryagain = 1;
/*
        Add a .pem extension to the file if not provided
 */
        while (tryagain)
        {
            _psTrace("Output certificate file name: ");
            if (fgets(otfCertFile, 72, stdin) != NULL)
            {
                len = (int32) Strlen(otfCertFile);
                if ((len == 1) && (otfCertFile[0] == '\n'))
                {
                    continue;
                }
                if (otfCertFile[len - 1] == '\n')
                {
                    len -= 1;
                }
                if (len < 5)
                {
                    Memcpy(&otfCertFile[len], ".pem", 4);
                    otfCertFile[len + 4] = '\0';
                }
                else
                {
                    if (Memcmp(&otfCertFile[len - 4], ".pem", 4) != 0)
                    {
                        Memcpy(&otfCertFile[len], ".pem", 4);
                    }
                    else
                    {
                        otfCertFile[len] = '\0';
                    }
                }
                tryagain = 0;
            }
        }
        certfile = otfCertFile;
    }

/*
    Self-signed cert requires private key
 */
    if (selfsign == 1 && privKey == NULL)
    {
        tryagain = 1;
        while (tryagain)
        {
            _psTrace("Private key file for self-signed cert: ");
            if (fgets(otfPrivKey, 72, stdin) != NULL)
            {
                len = (int32) Strlen(otfPrivKey);
                if ((len == 1) && (otfPrivKey[0] == '\n'))
                {
                    continue;
                }
                if (otfPrivKey[len - 1] == '\n')
                {
                    otfPrivKey[len - 1] = '\0';
                }
                privKey = otfPrivKey;
                if (privKeyPass == NULL)
                {
                    _psTrace("Private key password: ");
                    xfgets(otfPrivKeyPass, 64, stdin);
                    len = (int32) Strlen(otfPrivKeyPass);
                    if (otfPrivKeyPass[len - 1] == '\n')
                    {
                        otfPrivKeyPass[len - 1] = '\0';
                    }
                    if (Strcmp(otfPrivKeyPass, "") != 0)
                    {
                        privKeyPass = otfPrivKeyPass;
                    }
                }
                tryagain = 0;
            }
        }
    }
# endif

/*
    A request file was provided on the command line so make sure we
    have the info for a CA to issue one
 */
    subjectDN = NULL;
    if (selfsign == 0)
    {

        if (psParseCertReqFile(pool, reqFile, &reqBin, &reqLen) < 0)
        {
            _psTraceStr("Couldn't read request file %s\n", (char *) reqFile);
            goto error;
        }
/*
        Get the subject DN AND the public key of the cert from the request file
 */
        if (psParseCertReqBuf(pool, reqBin, reqLen, &subjectDN,
                &reqPubKey, &reqExt) < 0)
        {
            _psTrace("Error parsing request file\n");
            psFree(reqBin, pool);
            goto error;
        }
        psFree(reqBin, pool);

        _psTrace("Certificate being requested reports a Distinguished Name\n");
# ifdef USE_FULL_CERT_PARSE
        if (psX509GetOnelineDN(subjectDN, &oneline_subject_dn,
                               &oneline_subject_dn_len, 0) < 0)
        {
            _psTrace("psX509GetOnelineDN failed\n");
            goto error;
        }
        _psTraceStr("%s\n", oneline_subject_dn);
        psFree(oneline_subject_dn, pool);
# else  /* !(USE_FULL_CERT_PARSE) */
        _psTraceStr("Common Name:       %s\n", subjectDN->commonName);
        _psTraceStr("Organization:      %s\n", subjectDN->organization);
        for (orgUnit = subjectDN->orgUnit; orgUnit != NULL; orgUnit = orgUnit->next)
        {
            _psTraceStr("Org Unit:              %s\n", orgUnit->name);
        }
        _psTraceStr("Country:           %s\n", subjectDN->country);
        _psTraceStr("State:                     %s\n", subjectDN->state);
#  ifdef USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD
        _psTraceStr("Locality:          %s\n\n", subjectDN->locality);
#  endif /* USE_EXTRA_DN_ATTRIBUTES_RFC5280_SHOULD */
# endif  /* USE_FULL_CERT_PARSE */
        if (reqExt && reqExt->san)
        {
            _psTrace("Certificate being requested reports a SubjectAltName\n");
            gn = reqExt->san;
            while (gn)
            {
                _psTraceStr("%s:        ", (char *) gn->name);
                if (gn->id == GN_IP)
                {
                    _psTraceInt("%d.", (int32) gn->data[0]);
                    _psTraceInt("%d.", (int32) gn->data[1]);
                    _psTraceInt("%d.", (int32) gn->data[2]);
                    _psTraceInt("%d\n", (int32) gn->data[3]);
                }
                else
                {
                    _psTraceStr("%s \n", (char *) gn->data);
                }
                gn = gn->next;
            }
        }
# ifdef REQUIRE_INTERACTION
        _psTrace("Does this information match the requesting entity (y/n): ");
        xfgets(yorn, 6, stdin);
        if (yorn[0] != 'y')
        {
            _psTrace("Exiting\n");
            psX509FreeDNStruct(subjectDN, pool);
            psFree(subjectDN, pool);
            psDeletePubKey(&reqPubKey);
            if (reqExt)
            {
                x509FreeExtensions(reqExt);
                psFree(reqExt, pool);
            }
            goto error;
        }


        if (CAcert == NULL)
        {
            tryagain = 1;
            while (tryagain)
            {
                _psTrace("Certificate Authority certificate file: ");
                if (fgets(otfCAcert, 64, stdin) != NULL)
                {
                    len = (int32) Strlen(otfCAcert);
                    if (otfCAcert[len - 1] == '\n')
                    {
                        otfCAcert[len - 1] = '\0';
                    }
                    CAcert = otfCAcert;
                    tryagain = 0;
                }
            }
        }
        if (CAprivKey == NULL)
        {
            tryagain = 1;
            while (tryagain)
            {
                _psTrace("Certificate Authority private key file: ");
                if (fgets(otfCAPriv, 64, stdin) != NULL)
                {
                    len = (int32) Strlen(otfCAPriv);
                    if (otfCAPriv[len - 1] == '\n')
                    {
                        otfCAPriv[len - 1] = '\0';
                    }
                    CAprivKey = otfCAPriv;
                    tryagain = 0;
                }
            }
        }
        if (CAprivKeyPass == NULL)
        {
            _psTrace("Certificate Authority private key file password: ");
            xfgets(otfCAPrivPass, 64, stdin);
            len = (int32) Strlen(otfCAPrivPass);
            if (otfCAPrivPass[len - 1] == '\n')
            {
                otfCAPrivPass[len - 1] = '\0';
            }
            if (Strcmp(otfCAPrivPass, "") != 0)
            {
                CAprivKeyPass = otfCAPrivPass;
            }
        }
# endif
    }

/*
    Get config file options for cert type (if not supplied)
 */
    if (certconf == NULL)
    {
        int32 binlen;
        if (selfsign)
        {

            if (getOptions(pool, &confBin, &binlen, 0) < PS_SUCCESS)
            {
                _psTrace("Error parsing config file options from cmd line\n");
                goto error;
            }
        }
        else
        {
            if (getOptions(pool, &confBin, &binlen, 1) < PS_SUCCESS)
            {
                _psTrace("Error parsing config file options from cmd line\n");
                goto error;
            }
        }
        confBinLen = (psSizeL_t)binlen;
    }
    else
    {
        if (psGetFileBuf(pool, certconf, &confBin, &confBinLen) < PS_SUCCESS)
        {
            _psTraceStr("Unable to open configuration file %s\n", certconf);
            if (subjectDN)
            {
                psX509FreeDNStruct(subjectDN, pool);
                psFree(subjectDN, pool);
            }
            if (reqPubKey)
            {
                psDeletePubKey(&reqPubKey);
            }
            if (reqExt)
            {
                x509FreeExtensions(reqExt);
                psFree(reqExt, pool);
            }
            goto error;
        }
    }

    if (psX509ParseCertConfigBin(pool, confBin, confBinLen, &certConfig)
        < PS_SUCCESS)
    {
        _psTrace("Unable to parse configuration buffer\n");
        if (subjectDN)
        {
            psX509FreeDNStruct(subjectDN, pool);
            psFree(subjectDN, pool);
        }
        if (reqPubKey)
        {
            psDeletePubKey(&reqPubKey);
        }
        if (reqExt)
        {
            x509FreeExtensions(reqExt);
            psFree(reqExt, pool);
        }
        psFree(confBin, pool);
        goto error;
    }
    psFree(confBin, pool);

/*
    Have all the info now.  The writing starts here
 */
    _psTrace("\n");
/*
    Self-signed
 */
    if (selfsign)
    {
        _psTrace("Reading private key file... ");
        /* Try PEM format first. */
        if (psParseUnknownPrivKey(pool, 1, privKey, privKeyPass, &privKeyMem)
            < 0)
        {
            _psTrace("File not in PEM format, trying DER...\n");
            /* Now try DER. */
            if (psParseUnknownPrivKey(pool, 0, privKey, privKeyPass, &privKeyMem)
                < 0)
            {
                if (subjectDN)
                {
                    psX509FreeDNStruct(subjectDN, pool);
                    psFree(subjectDN, pool);
                }
                if (reqPubKey)
                {
                    psDeletePubKey(&reqPubKey);
                }
                if (reqExt)
                {
                    x509FreeExtensions(reqExt);
                    psFree(reqExt, pool);
                }
                psX509FreeCertConfig(&certConfig);
                _psTrace("FAILURE\n");
                goto error;
            }
        }
        _psTrace("SUCCESS\n");
        _psTrace("Generating self-signed certificate... ");

        if (psX509WriteSelfSignedCert(pool, &certConfig, &privKeyMem,
                certfile) < 0)
        {
            _psTrace("FAILURE\n");
        }
        else
        {
            _psTrace("SUCCESS\n");
        }
        if (subjectDN)
        {
            psX509FreeDNStruct(subjectDN, pool);
            psFree(subjectDN, pool);
        }
        if (reqPubKey)
        {
            psDeletePubKey(&reqPubKey);
        }
        if (reqExt)
        {
            x509FreeExtensions(reqExt);
            psFree(reqExt, pool);
        }
        psX509FreeCertConfig(&certConfig);
        psClearPubKey(&privKeyMem);

    }
    else
    {
/*
        CA-issued cert
 */
        _psTrace("Reading private key file... ");
        /* Try PEM first. */
        if (psParseUnknownPrivKey(pool, 1, CAprivKey, CAprivKeyPass,
                &privKeyMem) < 0)
        {
            /* Now try DER. */
            if (psParseUnknownPrivKey(pool, 0, CAprivKey, CAprivKeyPass,
                    &privKeyMem) < 0)
            {
                if (subjectDN)
                {
                    psX509FreeDNStruct(subjectDN, pool);
                    psFree(subjectDN, pool);
                }
                if (reqPubKey)
                {
                    psDeletePubKey(&reqPubKey);
                }
                if (reqExt)
                {
                    x509FreeExtensions(reqExt);
                    psFree(reqExt, pool);
                }
                psX509FreeCertConfig(&certConfig);
                _psTrace("FAILURE\n");
                goto error;
            }
        }
        _psTrace("SUCCESS\n");

        _psTrace("Reading CA certificate... ");
        if (psX509ParseCertFile(pool, CAcert, &caX509, CERT_STORE_DN_BUFFER)
            < PS_SUCCESS)
        {
            if (subjectDN)
            {
                psX509FreeDNStruct(subjectDN, pool);
                psFree(subjectDN, pool);
            }
            if (reqPubKey)
            {
                psDeletePubKey(&reqPubKey);
            }
            if (reqExt)
            {
                x509FreeExtensions(reqExt);
                psFree(reqExt, pool);
            }
            psX509FreeCertConfig(&certConfig);
            psClearPubKey(&privKeyMem);
            _psTrace("FAILURE\n");
            goto error;
        }
        _psTrace("SUCCESS\n");

                if (psX509SetCAIssuedCertExtensions(pool, &certConfig, reqExt, caX509)
                < PS_SUCCESS)
                {
                        psX509FreeCert(caX509);
                        if (subjectDN)
                        {
                                psX509FreeDNStruct(subjectDN, pool);
                                psFree(subjectDN, pool);
                        }
                        if (reqPubKey)
                        {
                                psDeletePubKey(&reqPubKey);
                        }
                        if (reqExt)
                        {
                                x509FreeExtensions(reqExt);
                                psFree(reqExt, pool);
                        }
                        psX509FreeCertConfig(&certConfig);
                        psClearPubKey(&privKeyMem);
                        goto error;
                }

        _psTrace("Generating CA issued certificate... ");
        if (psX509WriteCAIssuedCert(pool, &certConfig, reqPubKey,
                subjectDN->dnenc, subjectDN->dnencLen, caX509, &privKeyMem,
                certfile) < 0)
        {
            _psTrace("FAILURE\n");
        }
        else
        {
            _psTrace("SUCCESS\n");
        }
        psX509FreeCert(caX509);
        if (subjectDN)
        {
            psX509FreeDNStruct(subjectDN, pool);
            psFree(subjectDN, pool);
        }
        if (reqPubKey)
        {
            psDeletePubKey(&reqPubKey);
        }
        if (reqExt)
        {
            x509FreeExtensions(reqExt);
            psFree(reqExt, pool);
        }
        psX509FreeCertConfig(&certConfig);
        psClearPubKey(&privKeyMem);
    }

# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
# endif
    psCryptoClose();
    return 0;

error:
# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
# endif
    psCryptoClose();
    return EXIT_FAILURE;
}

/*
    Usage
 */
static void certgenUsage(void)
{
    _psTrace("Self-signing usage: \n");
    _psTrace("  matrixCertGen -out filename -certconf caConfDNFile\n");
    _psTrace("          -key privkeyfile [-pass pass]\n\n");

    _psTrace("CA issued cert usage: \n");
    _psTrace("  matrixCertGen -out filename -certconf caConfFile\n");
    _psTrace("          -req certRequestFile \n");
    _psTrace("          -CAcert cacert -CAkey caprivkey [-CApass pass]\n\n");
}

/******************************************************************************/
/*
    Get config options from stdin.  This is used only if a configuration
    file was not provided at all.  If a configuration file is used, it must
    contain all the information necessary.
 */
static int32 getOptions(psPool_t *pool, unsigned char **confBin, int32 *confLen,
    int32 caIssued)
{
    char conf[2048];
    char temp[80];
    char *pci;
    int32 tryagain, ca, len, i;

    Memset(conf, 0x0, 2048);
    pci = conf;

    /* Serial num */
    Memcpy(pci, "serialNum=\"", 11);
    pci += 11;

    tryagain = 1;
    while (tryagain)
    {
        _psTrace("Serial Number: ");
        xfgets(temp, 64, stdin);
        len = (int32) Strlen(temp);
        if (temp[len - 1] == '\n')
        {
            temp[--len] = '\0';
        }
        for (i = 0; i < len; i++)
        {
            if (temp[i] > '9')
            {
                break;
            }
        }
        if (i == len)
        {
            break;
        }
    }
    Memcpy(pci, temp, Strlen(temp));
    pci += Strlen(temp);
    Memcpy(pci, "\";", 2);
    pci += 2;

    /* CA */
    Memcpy(pci, "ca=\"", 4);
    pci += 4;

    ca = 0;
    while (tryagain)
    {
        _psTrace("Do you want this certifcate to be a CA (y/n): ");
        xfgets(temp, 64, stdin);
        if (temp[0] == 'y')
        {
            ca = 1;
            break;
        }
        else if (temp[0] == 'n')
        {
            ca = 0;
            break;
        }
    }


/*
    Only ask about pathLen if this is CA
 */
    if (ca)
    {
        Memcpy(pci, "1\";", 3);
        pci += 3;
        Memcpy(pci, "pathLen=\"", 9);
        pci += 9;
        while (tryagain)
        {
            _psTrace("What is the maximum certificate chain length: ");
            xfgets(temp, 64, stdin);
            len = (int32) Strlen(temp);
            if (temp[len - 1] == '\n')
            {
                temp[--len] = '\0';
            }
            for (i = 0; i < len; i++)
            {
                if (temp[i] > '9')
                {
                    break;
                }
            }
            if (i == len)
            {
                break;
            }
        }

        Memcpy(pci, temp, Strlen(temp));
        pci += Strlen(temp);
        Memcpy(pci, "\";", 2);
        pci += 2;
    }
    else
    {
        Memcpy(pci, "0\";", 3);
        pci += 3;
        Memcpy(pci, "pathLen=\"0\";", 12);
        pci += 12;
    }


    Memcpy(pci, "validDays=\"", 11);
    pci += 11;
    while (tryagain)
    {
        _psTrace("How many days from today is the certificate valid: ");
        xfgets(temp, 64, stdin);
        len = (int32) Strlen(temp);
        if (temp[len - 1] == '\n')
        {
            temp[--len] = '\0';
        }
        for (i = 0; i < len; i++)
        {
            if (temp[i] > '9')
            {
                break;
            }
        }
        if (i == len)
        {
            break;
        }
    }

    Memcpy(pci, temp, Strlen(temp));
    pci += Strlen(temp);
    Memcpy(pci, "\";", 2);
    pci += 2;

    Memcpy(pci, "algorithm=\"", 11);
    pci += 11;
    while (tryagain)
    {
        _psTrace("Signing algorithm (sha1/sha256/sha384/md5): ");
        xfgets(temp, 64, stdin);
        if (Strncmp(temp, "md5", 3) == 0)
        {
            Memcpy(pci, "md5\";", 5);
            pci += 5;
            break;
        }
        else if (Strncmp(temp, "sha1", 4) == 0)
        {
            Memcpy(pci, "sha1\";", 6);
            pci += 6;
            break;
        }
        else if (Strncmp(temp, "sha256", 6) == 0)
        {
            Memcpy(pci, "sha256\";", 8);
            pci += 8;
            break;
        }
        else if (Strncmp(temp, "sha384", 6) == 0)
        {
            Memcpy(pci, "sha384\";", 8);
            pci += 8;
            break;
        }
    }
/*
    DN portion for self-signed and no
 */
    if (caIssued == 0)
    {
        Memcpy(pci, "commonName=\"", 12);
        pci += 12;
        _psTrace("Certificate common name: ");
        xfgets(temp, 64, stdin);
        len = (int32) Strlen(temp);
        if (temp[len - 1] == '\n')
        {
            temp[--len] = '\0';
        }
        Memcpy(pci, temp, Strlen(temp));
        pci += Strlen(temp);
        Memcpy(pci, "\";", 2);
        pci += 2;

        Memcpy(pci, "country=\"", 9);
        pci += 9;
        _psTrace("Country name: ");
        xfgets(temp, 64, stdin);
        len = (int32) Strlen(temp);
        if (temp[len - 1] == '\n')
        {
            temp[--len] = '\0';
        }
        Memcpy(pci, temp, Strlen(temp));
        pci += Strlen(temp);
        Memcpy(pci, "\";", 2);
        pci += 2;

        Memcpy(pci, "stateOrProvince=\"", 17);
        pci += 17;
        _psTrace("State or Province: ");
        xfgets(temp, 64, stdin);
        len = (int32) Strlen(temp);
        if (temp[len - 1] == '\n')
        {
            temp[--len] = '\0';
        }
        Memcpy(pci, temp, Strlen(temp));
        pci += Strlen(temp);
        Memcpy(pci, "\";", 2);
        pci += 2;

        Memcpy(pci, "locality=\"", 10);
        pci += 10;
        _psTrace("City or locality: ");
        xfgets(temp, 64, stdin);
        len = (int32) Strlen(temp);
        if (temp[len - 1] == '\n')
        {
            temp[--len] = '\0';
        }
        Memcpy(pci, temp, Strlen(temp));
        pci += Strlen(temp);
        Memcpy(pci, "\";", 2);
        pci += 2;

        Memcpy(pci, "organization=\"", 14);
        pci += 14;
        _psTrace("Organization name: ");
        xfgets(temp, 64, stdin);
        len = (int32) Strlen(temp);
        if (temp[len - 1] == '\n')
        {
            temp[--len] = '\0';
        }
        Memcpy(pci, temp, Strlen(temp));
        pci += Strlen(temp);
        Memcpy(pci, "\";", 2);
        pci += 2;

        Memcpy(pci, "organizationalUnit=\"", 20);
        pci += 20;
        _psTrace("Organizational Unit: ");
        xfgets(temp, 64, stdin);
        len = (int32) Strlen(temp);
        if (temp[len - 1] == '\n')
        {
            temp[--len] = '\0';
        }
        Memcpy(pci, temp, Strlen(temp));
        pci += Strlen(temp);
        Memcpy(pci, "\";", 2);
        pci += 2;
    }

    *confLen = (int32) (Strlen(conf));
    *confBin = psMalloc(pool, *confLen);
    if (*confBin == NULL)
    {
        return PS_FAILURE;
    }
    Memcpy(*confBin, conf, *confLen);

    return PS_SUCCESS;
}

#else

/******************************************************************************/
/*
    Stub main for compiling without features enabled
 */
int32 main(int32 argc, char **argv)
{
    Printf("USE_CERT_GEN && MATRIX_USE_FILE_SYSTEM must be enabled "
        "to run this application.\n");
    return EXIT_FAILURE;
}

#endif /* USE_CERT_GEN && MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/
