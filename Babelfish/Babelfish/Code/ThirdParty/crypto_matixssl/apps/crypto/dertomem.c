/**
 *      @file    dertomem.c
 *
 *
 *      Command line utility to convert DER files to header files without parse.
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "crypto/cryptoApi.h"
/* Currently this example uses _psTrace for tracing, so osdep.h is needed: */
#include "core/osdep.h"

#if defined(MATRIX_USE_FILE_SYSTEM)

# include "osdep_stdlib.h"
# include "osdep_stdio.h"
# include "osdep_string.h"
# include <sys/stat.h>

/******************************************************************************/

static void createKeyMemHeader(char *fileName, char *structName,
                               unsigned char *certBin, uint32 certBinLen);
static void createNames(char *fileName, char *outfile, char *varname);

/******************************************************************************/

static void usage()
{
    _psTrace("usage: matrixDer2Mem -file file.der\n");
    return;
}

int32 main(int argc, char **argv)
{
    char *fileName;
    unsigned char *file;
    char outfile[64];
    char varname[64];
    psSizeL_t len;

    /* command line parse */
    fileName = NULL;
    argv++;  argc--; /* skip exe name */

    while (*argv)
    {
        if (Strcmp(*argv, "-file") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                fileName = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else
        {
            usage();
            return EXIT_FAILURE;
        }
        argv++; argc--;
    }

    /* Command line usage verification */
    if (fileName == NULL)
    {
        _psTrace("Must specifiy a DER formatted file with -file\n");
        usage();
        return EXIT_FAILURE;
    }

    if (psCryptoOpen(PSCRYPTO_CONFIG) < PS_SUCCESS)
    {
        _psTrace("Failed to initialize library:  psCryptoOpen failed\n");
        return EXIT_FAILURE;
    }

    if (psGetFileBuf(NULL, fileName, &file, &len) < PS_SUCCESS)
    {
        _psTraceStr("Unable to open %s.  Not converted\n", fileName);
        return EXIT_FAILURE;
    }

    /* Construct a file and variable name based off the file name */
    createNames(fileName, outfile, varname);
    createKeyMemHeader(outfile, varname, file, len);

    psCryptoClose();
    return 0;
}


static void createNames(char *fileName, char *outfile, char *varname)
{
    uint32 varindex, i;

    varindex = i = 0;

    Memset(outfile, 0, 64);
    Memset(varname, 0, 64);
    while (fileName[i] != '\0')
    {
        if (i == 48)
        {
            break;
        }
        /* Stop at first '.' */
        if (fileName[i] == '.')
        {
            break;
        }
        /* Only put alpha-numeric in var name */
        if ((fileName[i] >= 'a' && fileName[i] <= 'z') ||
            (fileName[i] >= 'A' && fileName[i] <= 'Z') ||
            (fileName[i] >= '0' && fileName[i] <= '9'))
        {
            varname[varindex++] = fileName[i];
        }
        outfile[i] = fileName[i];
        i++;
    }
    Memcpy(&outfile[i], ".h", 2);
}

/*****************************************************************************/
/*
    Accept a DER binary stream and create a C header file with the hex
    representation for use in matrixSslReadKeysMem
 */
static void createKeyMemHeader(char *fileName, char *structName,
    unsigned char *certBin, uint32 certBinLen)
{
    FILE *outFile;
    int32 i;

    if ((outFile = Fopen(fileName, "w")) == NULL)
    {
        _psTraceStr("Unable to open %s for writing\n", fileName);
        return;
    }

    Fprintf(outFile, "const unsigned char ");
    Fprintf(outFile, "%s[] = { \n", structName);
    for (i = 0; i < certBinLen; i++)
    {
        Fprintf(outFile, "%d", certBin[i]);
        if ((i + 1) != certBinLen)
        {
            Fprintf(outFile, ", ");
        }
        if (i % 13 == 12)
        {
            Fprintf(outFile, "\n");
        }
    }
    Fprintf(outFile, "};\n");
    Fclose(outFile);
    _psTraceStr("Successfully wrote %s\n", fileName);
    return;
}

#else

/******************************************************************************/
/*
    Stub main for compiling without features enabled
 */
int32 main(int32 argc, char **argv)
{
    Printf("MATRIX_USE_FILE_SYSTEM must be enabled "
        "to run this application.\n");
    return EXIT_FAILURE;
}

#endif /* MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/
