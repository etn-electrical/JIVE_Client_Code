/**
 *      @file    certrequest.c
 *
 *
 *      Command line utility for generating a PKCS#10 cert request.
 *
 *      This tool can be used to generate the material necessary to request a
 *      signed certificate from a Certificate Authority
 */
/*
 *      Copyright (c) 2013-2017 INSIDE Secure Corporation
 *      All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF INSIDE.
 *
 *      Please do not edit this file without first consulting INSIDE support.
 *      Unauthorized changes to this file are not supported by INSIDE.
 *
 *      The copyright notice above does not evidence any actual or intended
 *      publication of such source code.
 *
 *      This Module contains Proprietary Information of INSIDE and should be
 *      treated as Confidential.
 *
 *      The information in this file is provided for the exclusive use of the
 *      licensees of INSIDE. Such users have the right to use, modify,
 *      and incorporate this code into products for purposes authorized by the
 *      license agreement provided they include this notice and the associated
 *      copyright notice with any such product.
 *
 *      The information in this file is provided "AS IS" without warranty.
 */
/******************************************************************************/

#include "crypto/cryptoApi.h"
/* Currently this example uses _psTrace for tracing, so osdep.h is needed: */
#include "core/osdep.h"

#if defined(USE_CERT_GEN) && defined(MATRIX_USE_FILE_SYSTEM)

/******************************************************************************/

static char pemExt[4] = ".pem";

static int32 getOptions(psPool_t *pool, unsigned char **confBin,
                        int32 *confLen);

/******************************************************************************/

static void usage()
{
    _psTrace("usage: matrixCertReq -out reqFile -key privKey [-pass pass] [-reqconf configFile]\n");
}

int32 main(int32 argc, char **argv)
{
    psPool_t *pool;
    char *keyfile, *password, *requestFile, *requestConf;
    unsigned char *requestMem, *confBin;
    char otfKeyFile[80];
    psPubKey_t privkey;
    psSizeL_t confBinLen;
    int32 requestMemLen, len;
    int32 pemOrDer, tryagain;
    int keytype;
    int32 rc = PS_FAILURE;

    /* command line parse */
    keyfile = password = requestFile = requestConf = NULL;
    argv++;  argc--; /* skip exe name */

    while (*argv)
    {
        if (Strcmp(*argv, "-out") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                requestFile = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-pass") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                password = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-key") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                keyfile = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else if (Strcmp(*argv, "-reqconf") == 0)
        {
            argv++; argc--;
            if (*argv)
            {
                requestConf = *argv;
            }
            else
            {
                usage();
                return EXIT_FAILURE;
            }
        }
        else
        {
            usage();
            return EXIT_FAILURE;
        }
        argv++; argc--;
    }

    /* Command line sanity */
    if (keyfile == NULL)
    {
        _psTrace("Must provide a private key file via -key option\n");
        usage();
        return EXIT_FAILURE;
    }

    len = (int32) Strlen(keyfile);
    if (Memcmp(&keyfile[len - 4], pemExt, 4) == 0)
    {
        pemOrDer = 1;
    }
    else
    {
        /* If the file does not have pem extension, assume DER format. */
        pemOrDer = 0;
    }

    /* Get it going */
    if (psCryptoOpen(PSCRYPTO_CONFIG) < PS_SUCCESS)
    {
        _psTrace("Failed to initialize library:  psCryptoOpen failed\n");
        return EXIT_FAILURE;
    }

# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    pool = psOpenPool("certreq", 1024 * 48, 0, NULL, NULL);
# else
    pool = NULL;
# endif

    /* Read existing keyfile to psPubKey_t privkey */
    keytype = psParseUnknownPrivKey(pool, pemOrDer, keyfile, password,
                                    &privkey);
    if (keytype < 0)
    {
        rc = PS_FAILURE;
        goto err;
    }

    if (requestFile == NULL)
    {
/*
        If no file name provided, prompt for one and add a .req file
        extension if not given
 */
        tryagain = 1;
        Memset(otfKeyFile, 0x0, 32);
        while (tryagain)
        {
            _psTrace("Output request file name: ");
            if (fgets(otfKeyFile, 28, stdin) != NULL)
            {
                len = (int32) Strlen(otfKeyFile);
                if (Memcmp(&otfKeyFile[len - 5], ".req", 4) != 0)
                {
                    Memcpy(&otfKeyFile[--len], ".req", 4);
                }
                else
                {
                    otfKeyFile[--len] = '\0';
                }
                tryagain = 0;
            }
        }
        requestFile = otfKeyFile;
    }

    /* Request configuration */
    confBin = NULL;
    if (requestConf == NULL)
    {
        int32 binlen;
        _psTrace("Certifiate Request configuration information needed\n");
        if (getOptions(pool, &confBin, &binlen) != PS_SUCCESS)
        {
            _psTrace("Invalid configuration information input");
            goto err;
        }
        confBinLen = (psSizeL_t)binlen;
    }
    else
    {
        if (psGetFileBuf(pool, requestConf, &confBin, &confBinLen) < 0)
        {
            _psTraceStr("Couldn't open config file: %s\n", requestConf);
            psClearPubKey(&privkey);
            rc = PS_FAILURE;
            goto err;
        }
    }

    _psTrace("Writing certificate request file... ");

    /* Using a configuration file or have the user prompted string?  */
    if (psWriteCertReqMem_BinConfig(pool, &privkey, confBin, confBinLen,
            &requestMem, &requestMemLen) < 0)
    {
        psFree(confBin, pool);
        psClearPubKey(&privkey);
        _psTrace("FAILED TO ENCODE\n");
        rc = PS_FAILURE;
        goto err;
    }
    psFree(confBin, pool);

    if (psBase64EncodeAndWrite(pool, requestFile, requestMem, requestMemLen,
            REQ_FILE_TYPE, NULL, 0) < 0)
    {
        _psTrace("FAILED TO WRITE OUT\n");
        rc = PS_FAILURE;
    }
    else
    {
        _psTrace("SUCCESS\n");
        rc = PS_SUCCESS;
    }

    psFree(requestMem, pool);
    psClearPubKey(&privkey);

err:
# ifdef USE_MATRIX_MEMORY_MANAGEMENT
    psClosePool(pool);
# endif
    psCryptoClose();
    if (rc == PS_SUCCESS)
    {
        return 0;
    }
    else
    {
        return EXIT_FAILURE;
    }
}

/******************************************************************************/
/*
    Get config file options from the command line and format
 */
static int32 getOptions(psPool_t *pool, unsigned char **confBin, int32 *confLen)
{
    char conf[2048];
    char temp[80];
    char *pci;
    int32 getslen;

    Memset(conf, 0x0, 2048);
    pci = conf;

    /* Sig alg */
    Memcpy(pci, "algorithm=\"", 11);
    pci += 11;
    while (1)
    {
        _psTrace("Signing algorithm (sha1/sha256/sha384): ");
        if (!fgets(temp, 64, stdin))
        {
            goto error;
        }
        if (Strncmp(temp, "sha1", 4) == 0)
        {
            Memcpy(pci, "sha1\";", 6);
            pci += 6;
            break;
        }
        else if (Strncmp(temp, "sha256", 6) == 0)
        {
            Memcpy(pci, "sha256\";", 8);
            pci += 8;
            break;
        }
        else if (Strncmp(temp, "sha384", 6) == 0)
        {
            Memcpy(pci, "sha384\";", 8);
            pci += 8;
            break;
        }
    }

    /* DN portion */
    Memcpy(pci, "commonName=\"", 12);
    pci += 12;
    _psTrace("Certificate common name: ");
    if (!fgets(temp, 80, stdin))
    {
        goto error;
    }
    getslen = (int32) Strlen(temp) - 1; /* fgets includes the \n char */
    Memcpy(pci, temp, getslen);
    pci += getslen;
    Memcpy(pci, "\";", 2);
    pci += 2;

    Memcpy(pci, "serialNumber=\"", 14);
    pci += 14;
    _psTrace("Serial number: ");
    if (!fgets(temp, 80, stdin))
    {
        goto error;
    }
    getslen = (int32) Strlen(temp) - 1;
    Memcpy(pci, temp, getslen);
    pci += getslen;
    Memcpy(pci, "\";", 2);
    pci += 2;

    Memcpy(pci, "country=\"", 9);
    pci += 9;
    _psTrace("Country name: ");
    if (!fgets(temp, 80, stdin))
    {
        goto error;
    }
    getslen = (int32) Strlen(temp) - 1;
    Memcpy(pci, temp, getslen);
    pci += getslen;
    Memcpy(pci, "\";", 2);
    pci += 2;

    Memcpy(pci, "stateOrProvince=\"", 17);
    pci += 17;
    _psTrace("State or Province: ");
    if (!fgets(temp, 80, stdin))
    {
        goto error;
    }
    getslen = (int32) Strlen(temp) - 1;
    Memcpy(pci, temp, getslen);
    pci += getslen;
    Memcpy(pci, "\";", 2);
    pci += 2;

    Memcpy(pci, "locality=\"", 10);
    pci += 10;
    _psTrace("City or locality: ");
    if (!fgets(temp, 80, stdin))
    {
        goto error;
    }
    getslen = (int32) Strlen(temp) - 1;
    Memcpy(pci, temp, getslen);
    pci += getslen;
    Memcpy(pci, "\";", 2);
    pci += 2;

    Memcpy(pci, "organization=\"", 14);
    pci += 14;
    _psTrace("Organization name: ");
    if (!fgets(temp, 80, stdin))
    {
        goto error;
    }
    getslen = (int32) Strlen(temp) - 1;
    Memcpy(pci, temp, getslen);
    pci += getslen;
    Memcpy(pci, "\";", 2);
    pci += 2;

    Memcpy(pci, "organizationalUnit=\"", 20);
    pci += 20;
    _psTrace("Organizational Unit: ");
    if (!fgets(temp, 80, stdin))
    {
        goto error;
    }
    getslen = (int32) Strlen(temp) - 1;
    Memcpy(pci, temp, getslen);
    pci += getslen;
    Memcpy(pci, "\";", 2);
    pci += 2;

    *confLen = (int32) (Strlen(conf));
    if ((*confBin = psMalloc(pool, *confLen)) == NULL)
    {
        return PS_MEM_FAIL;
    }
    Memcpy(*confBin, conf, *confLen);

    return PS_SUCCESS;
error:
    return PS_FAILURE;
}

/******************************************************************************/

#else

/******************************************************************************/
/*
    Stub main for compiling without features enabled
 */
int32 main(int32 argc, char **argv)
{
    Printf("USE_CERT_GEN && MATRIX_USE_FILE_SYSTEM must be enabled "
        "to run this application.\n");
    return EXIT_FAILURE;
}

#endif /* USE_CERT_GEN && MATRIX_USE_FILE_SYSTEM */

/******************************************************************************/
