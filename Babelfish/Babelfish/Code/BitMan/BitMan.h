/**
 *****************************************************************************************
 * @file
 *
 * @brief
 *
 * @details
 *
 * @copyright 2014 Eaton Corporation. All Rights Reserved.
 *
 *****************************************************************************************
 */
#ifndef BITMAN_H_
	#define BITMAN_H_

// Global includes
#include "Includes.h"

// Local includes
#include "BitMan_Defines.h"

// Babelfish Includes
#include "DCI_Defines.h"
#include "DCI_Workers.h"

/**
 *****************************************************************************************
 * @brief The "Logic" namespace contains all code related to logic functions such as
 * Bitman and Logic Engine in the future
 *
 *****************************************************************************************
 */
namespace Logic
{
/**
 * @brief Different options for loading a new profile, used by Load_BitMap
 * @see Load_BitMap
 */
typedef enum MAP_LOAD_MODE_t
{
	MAP_NORMAL = 0,					// In this mode existing will not be overridden. Exception is thrown if there is a
									// collision
	CLEAR_EXISTING_MAP,			// Will clear all linkages in the current map
	KEEP_EXISTING_LINKS,		// If the sink is already mapped, the link will not be altered (i.e) new link request
								// will be ignored
	OVERRIDE_EXISTING_LINKS		// If the sink is already mapped, the old link will be removed and new link will be
								// created based on the request
} MAP_LOAD_MODE;

/**
 ****************************************************************************************
 * @brief The BitMan class serves as main class and the interface class for the BitMan
 * functionality
 *
 ****************************************************************************************
 */
class BitMan
{
	public:

		// Public Methods/Interfaces
		/**
		 * @brief The only allowed constructor prototype for BitMan
		 * @param[in] base - Pointer to the BitMan_Base_Structure auto generated by BitMan config tool
		 * @see [Package Name]_BitMan_Base.h
		 */
		BitMan( BitMan_Base_Structure const* base );

		/**
		 * @brief Destructor
		 */
		~BitMan( void );

		/**
		 * @brief Load a new profile map into the BitMan
		 * @param[in] profile - pointer to the BitMan_Profile auto generated by BitMan config tool
		 * @see [Package Name]_[Profile Name]_Profile.h
		 * @param[in] load_mode - Different options for loading a new Profile Map
		 *							CLEAR_EXISTING_MAP - Will clear all linkages in the current map
		 *							KEEP_EXISTING_LINKS - If the sink is already mapped, the link will not be altered
		 *(i.e) new link request will be ignored
		 *							OVERRIDE_EXISTING_LINKS - If the sink is already mapped, the old link will be
		 * removed and new link will be created based on the request
		 * @see MAP_LOAD_MODE
		 */
		Bitman_Error_t Load_BitMap( BitMan_Profile const* profile, MAP_LOAD_MODE load_mode );

		/**
		 * @brief Maps or Links a source and a sink Bitfield.
		 * 			The list of mappable bitfields are available in [Package Name]_BitMan_Bitfields.h
		 * @param[in] source_dcid_bitfield - Source Bitfield to be mapped
		 * @param[in] sink_dcid_bitfield - Sink Bitfield to be mapped
		 * @see [Package Name]_BitMan_Bitfields.h
		 */
		void Map( BITMAN_TD source_dcid_bitfield, BITMAN_TD sink_dcid_bitfield );

		/**
		 * @brief Unlinks a sink Bitfield if it was previously linked to any source Bitfield
		 * @param[in] sink_dcid_bitfield - Sink Bitfield to be unlinked
		 * @see [Package Name]_BitMan_Bitfields.h
		 */
		void UnLink( BITMAN_TD sink_dcid_bitfield );

		/**
		 * @brief Checks if a source and a sink Bitfields are mapped
		 * @param source_dcid_bitfield - Source Bitfield to be checked
		 * @param sink_dcid_bitfield - Sink Bitfield to be checked
		 * @return true - If source and sink Bitfields are mapped
		 * 		   false - If source and sink Bitfields are not mapped
		 */
		bool Mapped( BITMAN_TD source_dcid_bitfield, BITMAN_TD sink_dcid_bitfield ) const;

		/**
		 * @brief Checks if a sink Bitfield is linked to any source Bitfield
		 * @param sink_dcid_bitfield - Sink Bitfield to be checked
		 * @return true - If the sink Bitfields is mapped
		 * 		   false - If the sink Bitfields is not mapped
		 */
		bool Sink_Bit_Is_Linked( BITMAN_TD sink_dcid_bitfield ) const;

	private:
		// Private Members
		// Parton handle to access various DCIDs
		DCI_Workers* m_dci_access;
		// Length of the sink Bitlist
		BITMAN_TD m_sink_bitlist_len;
		// Array of sink DCIDs
		DCI_ID_TD const* m_sink_dcid_list;
		// Length of source Bitlist
		BITMAN_TD m_source_bitlist_len;
		// Array of source DCIDs
		DCI_ID_TD const* m_source_dcid_list;
		// Sink Bitlist Array/Map
		BITMAN_TD* m_sink_bitlist_map;
		// Array of bytes to hold the sink DCID values
		uint8_t* m_sink_dci_buffer;
		// Array of bytes that holds change masks for the sink DCIDs
		uint8_t* m_sink_change_mask;
		// Source Bitlist/Map
		BITMAN_TD* m_source_bitlist_map;
		// Array of bytes that hold a copy of the last updated source DCIDs.
		uint8_t* m_source_shadow;
		// Array of bytes used as a holding buffer to read or write DCIDs
		uint8_t* m_receive_buffer;
		// Length of m_source_dcid_list and m_source_shadow
		BITMAN_TD m_source_byte_array_len;
		// Length of m_sink_dcid_list, m_sink_dci_buffer and m_sink_change_mask
		BITMAN_TD m_sink_byte_array_len;

		// Private constants
		// Invalid node indicator used in m_source_bitlist_map and m_sink_bitlist_map
		static const BITMAN_TD INVALID_BITLIST_ENTRY = static_cast<BITMAN_TD>( ~static_cast<BITMAN_TD>( 0U ) );
		// Number of bits in a byte
		static const uint16_t BITS_IN_BYTE = 8U;

		// Private Methods
		/**
		 * @brief - Use of this constructor is prohibited
		 */
		BitMan( void );

		/**
		 * @brief - Initializes the BitMan object
		 */
		void Initialize();

		/**
		 * @brief Clears all source to sink Bitfield mappings
		 */
		void ClearAllMapping();

		/**
		 * @brief Examines a single byte of a sink DCID by comparing with m_sink_dci_buffer and m_sink_change_mask
		 * @param[in] sink_byte_offset - Offset into the m_sink_dcid_list/m_sink_dci_buffer/m_sink_change_mask
		 * @param[in] change_mask - XOR of the sink_data and m_sink_dci_buffer[sink_byte_offset]
		 */
		void Update_Sink_Writeback( BITMAN_TD sink_byte_offset, uint8_t change_mask );

		/**
		 * @brief Pushes down bit changes in a source DCID byte to all the connected sink bits
		 * @param[in] source_byte_offset - Offset into the m_source_dcid_list/m_source_shadow
		 * @param[in] source_data - the newly received source DCI data
		 * @param[in] change_mask - XOR of source_data and m_source_shadow[source_byte_offset]
		 */
		void Update_Sink_Bitlist( BITMAN_TD source_byte_offset, uint8_t source_data, uint8_t change_mask );

		/**
		 * @brief Pushes down a single source bit down to the sink bit chain
		 * @param[in] source_bitlist_index - Index into the m_source_bitlist_map that needs to be pushed down
		 * @param[in] bit_set true - Bit Set
		 * 					  false - Bit Clear
		 */
		void Update_Sink_Bitlist_Chain( BITMAN_TD source_bitlist_index, bool bit_set );

		/**
		 * @brief Sets or clears a single bit in the sink Bitlist
		 * @param sink_bitlist_index - Index into the m_sink_bitlist_map
		 * @param[in] bit_set true - Bit Set
		 * 					  false - Bit Clear
		 */
		void Update_Sink_Bit( BITMAN_TD sink_bitlist_index, bool bit_set );

		/**
		 * @brief Writes all the changed sink DCIDs in m_sink_dci_buffer into the DCI server based on the
		 * m_sink_change_mask
		 */
		void Flush_Sink_Bitlist();

		/**
		 * @brief Writes a single sink DCIDs in m_sink_dci_buffer into the DCI server based on the m_sink_change_mask
		 * @param sink_byte_offset - Offset into the m_sink_dcid_list/m_sink_dci_buffer/m_sink_change_mask
		 * @return
		 */
		BITMAN_TD Flush_Sink_Dcid( BITMAN_TD sink_byte_offset );

		/**
		 * @brief Clears the sink change mask m_sink_change_mask
		 */
		void Clear_Sink_Change_Mask();

		/**
		 * @brief Change_Tracker callback for all source and sink DCIDs
		 * @param dci_id - DCI ID that changed
		 * @param attribute_mask - type of change related to the DCI change
		 */
		void Control_Bits_Changed( DCI_ID_TD dci_id, Change_Tracker::attrib_mask_t attribute_mask );

		/**
		 * @brief Static change_Tracker callback for all source and sink DCIDs
		 * @param param - "this" pointer for BitMan
		 * @param dci_id - DCI ID that changed
		 * @param attribute - type of change related to the DCI change
		 */
		static void Control_Bits_Changed_Static( Change_Tracker::cback_param_t param,
												 DCI_ID_TD dci_id, Change_Tracker::attrib_mask_t attribute_mask )
		{ reinterpret_cast<BitMan*>( param )->Control_Bits_Changed( dci_id, attribute_mask ); }

};

}



#endif	/* BITMAN_H_ */
